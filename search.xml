<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程课程总结</title>
      <link href="/2023/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"/>
      <url>/2023/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="🍒01章-软件工程学概述"><a href="#🍒01章-软件工程学概述" class="headerlink" title="🍒01章 软件工程学概述"></a>🍒01章 软件工程学概述</h1><h4 id="软件的定义："><a href="#软件的定义：" class="headerlink" title="软件的定义："></a>软件的定义：</h4><p>软件是多种术语和对象的集合，并将这些术语和对象有效地配置在一起。软件包括三个组成部分——<strong>程序、文档和数据</strong><br>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><h4 id="软件的特点："><a href="#软件的特点：" class="headerlink" title="软件的特点："></a>软件的特点：</h4><ol><li>软件是被工程化的逻辑系统</li><li>软件一般没有磨损</li><li>软件具有不同于一般实物系统的复杂性</li></ol><h4 id="软件危机定义："><a href="#软件危机定义：" class="headerlink" title="软件危机定义："></a>软件危机定义：</h4><p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。这些问题不是在解决具体问题时遇到的，而是软件开发过程中所面临的具有<strong>普适性的问题</strong>。<br>软件危机的典型表现：概括的来说，<strong>开发周期长、成本高、质量差、适应性差和难以维护</strong></p><h4 id="软件工程方法学三要素："><a href="#软件工程方法学三要素：" class="headerlink" title="软件工程方法学三要素："></a>软件工程方法学三要素：</h4><p>软件工程的三个基本要素：<strong>方法、工具和过程</strong></p><ol><li><strong>过程：</strong>规定了完成各项任务的过程</li></ol><p>为了获得高质量软件所需要完成的一系列任务的<strong>框架</strong>，规定了完成各项任务的<br>工作步骤。</p><ol start="2"><li><strong>方法：</strong>完成软件开发的各项任务的技术方法，回答“怎样做”的问题</li><li><strong>工具：</strong>（为运用方法而提供的自动的或半自动的）软件工程的支撑环境</li></ol><p>目前使用最广泛的软件工程方法学，分别是<strong>传统方法学</strong>和<strong>面向对象方法学</strong></p><h4 id="软件生命周期各阶段定义："><a href="#软件生命周期各阶段定义：" class="headerlink" title="软件生命周期各阶段定义："></a>软件生命周期各阶段定义：</h4><p>三个时期：<strong>软件定义、软件开发和运行维护（软件维护）</strong></p><ol><li><strong>软件定义：问题定义、可行性研究和需求分析</strong></li></ol><p>软件定义时期的任务是：</p><ol><li>确定软件开发工程必须完成的总目标；</li><li>确定工程的可行性；</li><li>导出实现工程目标应该采用的策略及系统必须完成的功能；</li><li>估计完成该项工程需要的资源和成本，并且制定工程进度表。</li></ol><p>这个时期的工作通常又称为系统分析，由系统分析员负责完成。</p><ol start="2"><li><strong>软件开发：总体设计、详细设计、编码和单元测试、综合测试</strong>（前两个为系统设计，后两个为系统实现）</li></ol><p>开发时期具体设计和实现在前一个时期定义的软件</p><ol start="3"><li><strong>软件维护：</strong>主要任务是使软件持久地满足用户的需要</li></ol><h4 id="Scrum模型的框架图："><a href="#Scrum模型的框架图：" class="headerlink" title="Scrum模型的框架图："></a>Scrum模型的框架图：</h4><p>Scrum 是一个轻量级的项目管理的框架，它的核心在于迭代。<br><img src="https://s1.ax1x.com/2023/05/16/p92yWAH.png#height=324&id=N4BMo&originHeight=648&originWidth=1152&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=576"></p><h4 id="Scrum三大特点："><a href="#Scrum三大特点：" class="headerlink" title="Scrum三大特点："></a>Scrum三大特点：</h4><ol><li>关注当下——“可能性的”艺术</li><li>放权——团队自组织、自管理</li><li>提高沟通效率——面对面沟通</li></ol><h4 id="Scrum团队模型的三种角色："><a href="#Scrum团队模型的三种角色：" class="headerlink" title="Scrum团队模型的三种角色："></a>Scrum团队模型的三种角色：</h4><ol><li>Scrum Master——不要管理团队</li><li>Product Owner</li><li>团队</li></ol><p><img src="https://s1.ax1x.com/2023/05/13/p96rlLj.png#height=327&id=wJKbc&originHeight=654&originWidth=1398&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=699"></p><h1 id="🍒02章-可行性研究"><a href="#🍒02章-可行性研究" class="headerlink" title="🍒02章 可行性研究"></a>🍒02章 可行性研究</h1><h4 id="可行性分析定义："><a href="#可行性分析定义：" class="headerlink" title="可行性分析定义："></a>可行性分析定义：</h4><p>对需求内容进行初步的分析，确定解决问题的可能性，分析不同解决方案的优劣，并提出建议。其本质实际上就是一个粗略的系统分析和设计过程，通常由客户完成。<br>可行性研究的目的，就是用<strong>最小的代价</strong>在<strong>尽可能短的时间</strong>内确定问题是否能够解决<br>可行性研究的类型：</p><ol><li>研究型项目的可行性研究分析</li><li>委托型可行性研究分析</li><li>自主开发型可行性研究分析</li></ol><p>可行性研究分析过程：</p><ol><li>首先，进一步分析和澄清<strong>问题定义</strong></li><li>然后，分析员应该导出系统的<strong>逻辑模型</strong></li><li>最后，探索若干可供选择的<strong>主要解法</strong></li></ol><h4 id="可行性分析三个方面："><a href="#可行性分析三个方面：" class="headerlink" title="可行性分析三个方面："></a>可行性分析三个方面：</h4><ol><li>技术可行性</li><li>经济可行性</li><li>操作可行性</li></ol><p>技术可行性——使用现有的技术能实现这个系统吗?<br>经济可行性——这个系统的经济效益能超过它的开发成本吗?<br>操作可行性——系统的操作方式在这个用户组织内行得通吗?</p><h1 id="🍒03章-需求分析"><a href="#🍒03章-需求分析" class="headerlink" title="🍒03章 需求分析"></a>🍒03章 需求分析</h1><h4 id="需求分析定义："><a href="#需求分析定义：" class="headerlink" title="需求分析定义："></a>需求分析定义：</h4><p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答”系统必须做什么“这个问题。<br>需求分析的任务就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统“做什么”的问题。</p><h4 id="需求分析（面向过程）需要建立的三类模型："><a href="#需求分析（面向过程）需要建立的三类模型：" class="headerlink" title="需求分析（面向过程）需要建立的三类模型："></a>需求分析（面向过程）需要建立的三类模型：</h4><ol><li><strong>数据模型</strong>：主要采用实体联系图ERD图描述，描述数据对象及数据对象之间的关系</li><li><strong>功能模型</strong>：主要采用数据流图描述，描述当数据在软件系统中移动时被变换的逻辑过程，指明系统具有的变换数据的功能</li><li><strong>行为模型</strong>：采用状态转换图，指明了作为外部事件结果的系统行为。为此，状态转换图描述了系统各种行为模式（状态）和在不同状态间转换的方式</li></ol><h4 id="实体联系图定义："><a href="#实体联系图定义：" class="headerlink" title="实体联系图定义："></a>实体联系图定义：</h4><p>ER实体联系图，描述数据对象及数据对象之间的关系，是用于建立数据模型的图形<br>数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系</p><h4 id="数据流图定义："><a href="#数据流图定义：" class="headerlink" title="数据流图定义："></a>数据流图定义：</h4><p><strong>数据流图（DFD）</strong>是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。<br>数据流图是建立功能模型的基础<br>数据流图让软件工程师能够建模同时建模信息模型和功能模型。</p><h4 id="加油站-x2F-数据流图："><a href="#加油站-x2F-数据流图：" class="headerlink" title="加油站&#x2F;数据流图："></a>加油站&#x2F;数据流图：</h4><p>0层：<br><img src="https://s1.ax1x.com/2023/05/13/p96c5gf.png#height=141&id=J84Ho&originHeight=282&originWidth=1147&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574"><br>1层：<br><img src="https://s1.ax1x.com/2023/05/13/p96c48P.png#height=304&id=XPhm2&originHeight=607&originWidth=1192&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=596"><br>2层：<br><img src="https://s1.ax1x.com/2023/05/13/p96cIv8.png#height=364&id=IZ83a&originHeight=727&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=693"><br>3层：<br><img src="https://s1.ax1x.com/2023/05/13/p96chCt.png#height=387&id=CaN22&originHeight=773&originWidth=1373&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=687"></p><h4 id="登录-x2F-状态转换图："><a href="#登录-x2F-状态转换图：" class="headerlink" title="登录&#x2F;状态转换图："></a>登录&#x2F;状态转换图：</h4><p>密码验证状态转换图<br><img src="https://s1.ax1x.com/2023/05/13/p96WurT.png#id=F2nKx&originHeight=519&originWidth=838&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍒05章-总体设计"><a href="#🍒05章-总体设计" class="headerlink" title="🍒05章 总体设计"></a>🍒05章 总体设计</h1><h4 id="总体设计定义："><a href="#总体设计定义：" class="headerlink" title="总体设计定义："></a>总体设计定义：</h4><p>总体设计的基本目的就是回答”概括地说，系统应该如何实现“这个问题，又叫<strong>概要设计</strong>、<strong>初步设计</strong><br>总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系</p><h4 id="模块的三个基本要素："><a href="#模块的三个基本要素：" class="headerlink" title="模块的三个基本要素："></a>模块的三个基本要素：</h4><ol><li><strong>功能</strong>：描述该模块实现什么功能</li><li><strong>逻辑</strong>：描述模块内部该怎么做</li><li><strong>状态</strong>：该模块使用时的环境和条件</li></ol><p><strong>模块化</strong>是为了使一个复杂的大型程序能被人的智力所管理，<strong>是软件应该具备的唯一属性</strong></p><h4 id="信息隐藏："><a href="#信息隐藏：" class="headerlink" title="信息隐藏："></a>信息隐藏：</h4><p>应该这样设计和确定模块，使得一个模块内包含的信息（过程、数据）对于不需要这些信息的模块来说，是不能访问的<br>每个模块的实现细节对于其他模块来说是隐蔽的，也就是说，模块中所包含的信息（包括数据和过程）不允许其他不需要这些信息的模块使用</p><h4 id="模块独立性："><a href="#模块独立性：" class="headerlink" title="模块独立性："></a>模块独立性：</h4><p>模块的独立程度可以由两个定性标准度量，这两个标准分别为：<strong>内聚和耦合</strong><br><strong>模块独立性</strong>，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他模块的接口是简单的<br><strong>耦合</strong>，是模块之间的互相连接的紧密程度的度量(非数标控外公内)<br><img src="https://s1.ax1x.com/2023/05/14/p9cYjAS.png#height=144&id=bWIbT&originHeight=288&originWidth=805&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=403"><br><strong>内聚</strong>，标志一个模块内各个元素彼此结合的紧密程度（功信通过时逻巧）<br><img src="https://s1.ax1x.com/2023/05/14/p9cYO78.png#height=144&id=jcZ9T&originHeight=288&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=410"><br>模块独立性的重要原因：</p><ol><li>有效的模块化（即具有独立的模块）的软件比较容易开发出来</li><li>独立的模块比较容易测试和维护</li></ol><h4 id="作用域、控制域："><a href="#作用域、控制域：" class="headerlink" title="作用域、控制域："></a>作用域、控制域：</h4><p><strong>模块的作用域应该在控制域之内</strong><br><strong>作用域</strong>：受该模块内一个判定影响的所有模块的集合<br><strong>控制域</strong>：模块本身以及所有直接或间接从属与它的模块的集合</p><h4 id="总体设计原则："><a href="#总体设计原则：" class="headerlink" title="总体设计原则："></a>总体设计原则：</h4><p>（莫愁逐藏巨毒）</p><ol><li>模块化</li><li>抽象</li><li>逐步求精</li><li>信息隐藏和局部化</li><li>模块独立</li></ol><h4 id="变换流，事务流定义："><a href="#变换流，事务流定义：" class="headerlink" title="变换流，事务流定义："></a>变换流，事务流定义：</h4><p>面向数据流的式设计方法把信息流映射成软件结构，信息流的类型决定了映射方法。<br><strong>变换流</strong>：信息沿输入通路进入系统，由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫做变换流<br><strong>事务流</strong>：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类数据流应该划分为一类特殊的数据流，称为事务流<br>T称为事务中心，它完成下述任务：接收输入数据（输入数据又称为事务）；分析每个事务以确定它的类型；根据事务类型选取一条活动通路</p><h4 id="格式化123-x2F-软件结构图："><a href="#格式化123-x2F-软件结构图：" class="headerlink" title="格式化123&#x2F;软件结构图："></a>格式化123&#x2F;软件结构图：</h4><p><img src="https://s1.ax1x.com/2023/05/13/p96RTKK.png#height=404&id=TG027&originHeight=808&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=675"></p><h1 id="🍒06章-详细设计"><a href="#🍒06章-详细设计" class="headerlink" title="🍒06章 详细设计"></a>🍒06章 详细设计</h1><h4 id="详细设计定义："><a href="#详细设计定义：" class="headerlink" title="详细设计定义："></a>详细设计定义：</h4><p>根本目标：确定应该怎样具体地实现所要求的系统。详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。<br>详细设计的结果基本上决定了最终的程序代码的质量。</p><ol><li>确定软件各个组成部分内的算法以及各部分的内部数据结构</li><li>选定某种过程的表达形式来描述各种算法</li><li>进行详细设计的评审</li></ol><h4 id="结构化程序的三种基本控制结构："><a href="#结构化程序的三种基本控制结构：" class="headerlink" title="结构化程序的三种基本控制结构："></a>结构化程序的三种基本控制结构：</h4><p>顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这3种基本控制结构，则称为<strong>经典的结构程序设计</strong></p><ol><li>顺序</li><li>选择</li><li>循环</li></ol><h1 id="🍒07章-实现"><a href="#🍒07章-实现" class="headerlink" title="🍒07章 实现"></a>🍒07章 实现</h1><h4 id="软件测试的原则："><a href="#软件测试的原则：" class="headerlink" title="软件测试的原则："></a>软件测试的原则：</h4><p>（需前 P小 穷三 早两 合检妥）</p><ol><li>所有测试都应该能追溯到用户需求</li><li>应该远在测试之前就制定出测试计划</li><li>把Pareto原理应用到软件测试中（测试存在群集现象）</li><li>该从“小规模”测试开始，并逐步进行“大规模”的测试</li><li>穷举测试是不可能的</li><li>为了达到最佳测试效果，应该由独立的第三方从事测试工作</li><li>应当把“尽早地和不断地进行软件测试”作为软件开发者的座右铭</li><li>测试用例应由测试输入数据和对应的预计输出结果这两部分组成</li><li>在设计测试用例时，应当包括合理的输入条件和不合理的输入条件</li><li>应当对每个测试结果做全面检查</li><li>妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便</li></ol><p>测试过程按4个步骤进行，即<strong>单元测试、集成测试、确认测试和系统测试</strong></p><h4 id="单元测试定义："><a href="#单元测试定义：" class="headerlink" title="单元测试定义："></a>单元测试定义：</h4><p>单元测试又称<strong>模块测试</strong>，是针对软件设计的最小单元——程序模块，进行<strong>正确性检验</strong>的测试工作。其目的在于发现各模块内部可能存在的各种差错（采用的方法主要是白盒测试）单元测试需要从模块内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。<br>在单元测试期间着重从以下5个方面对模块进行测试：<br>（摩羯局指错边）</p><ol><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件（最重要）</li></ol><h4 id="驱动程序："><a href="#驱动程序：" class="headerlink" title="驱动程序："></a>驱动程序：</h4><p>驱动程序是一个<strong>“主程序”</strong>，它<strong>接收测试数据</strong>，把这些数据传送给被测试的模块，并且印出有关的结果。</p><h4 id="白盒测试定义-x2F-类型-x2F-步骤："><a href="#白盒测试定义-x2F-类型-x2F-步骤：" class="headerlink" title="白盒测试定义&#x2F;类型&#x2F;步骤："></a>白盒测试定义&#x2F;类型&#x2F;步骤：</h4><p>白盒测试<strong>把测试对象看作一个透明的盒子</strong>，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<br>通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。因此白盒测试又称为<strong>结构测试或逻辑驱动测试</strong>。<br>类型：白盒测试的测试方法有代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径测试法、域测试、符号测试、Z路径覆盖、程序变异。<br>（带境节制罗录迂腐Z变）<br>其中运用最为广泛的是<strong>基本路径测试法</strong>。<br>白盒测试类型：</p><ol><li><strong>逻辑覆盖</strong></li></ol><p>（预判条件组合点边）</p><ol><li><strong>语句覆盖</strong>——选择足够多的测试数据，是被测程序中每个语句至少执行一次</li><li><strong>判定覆盖</strong>——分支覆盖，不仅每个语句必须至少执行一次，而且<strong>每个判定的每种可能的结果</strong>都应该至少执行一次，也就是每个判定的每个分支都至少执行一次</li><li><strong>条件覆盖</strong>——不仅每个语句至少执行一次，而且使<strong>判定表达式中的每个条件</strong>都取到各种可能的结果</li><li><strong>判定&#x2F;条件覆盖</strong>——选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</li><li><strong>条件组合覆盖</strong>——它要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。<strong>最强的，但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到</strong></li><li><strong>点覆盖</strong>——点覆盖标准和语句覆盖标准是相同的</li><li><strong>边覆盖</strong>——通常边覆盖和判定覆盖是一致的</li></ol><p>白盒测试技术：</p><ol><li><strong>基本路径测试</strong></li></ol><p>（流环线测）</p><ol><li>根据过程设计结果画出相应的<strong>流图</strong></li><li>计算流图的<strong>环形复杂度</strong></li><li>确定线性独立路径的基本集合</li><li>设计<strong>可强制执行基本集合中</strong>每条路径的测试用例</li><li><strong>条件测试</strong></li></ol><p>优点：容易度量条件的测试覆盖率； 程序内条件的测试覆盖率可指导附加测试的设计</p><ol start="3"><li><strong>循环测试</strong></li></ol><p>在结构化的程序中通常只有3种循环，即<strong>简单循环、串接循环和嵌套循环</strong></p><h4 id="黑盒测试方法："><a href="#黑盒测试方法：" class="headerlink" title="黑盒测试方法："></a>黑盒测试方法：</h4><p>这种方法是<strong>把测试对象看做一个黑盒子</strong>，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。黑盒测试又叫做<strong>功能测试或数据驱动测试</strong>。<br>黑盒测试技术：（等边错）</p><ol><li><strong>等价划分</strong></li></ol><p>等价划分把程序的输入域划分成若干个数据类，据此导出测试用例<br>使用等价划分法设计测试方案首先需要划分输入数据的等价类，为此需要研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类。<br>划分出等价类以后，根据等价类设计测试方案时主要使用下面两个步骤<br>(1)设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止<br>(2)设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止<br>注意，通常程序发现一类错误后就不再检查是否还有其他错误，因此，应使每个测试方案只覆盖一个无效的等价类</p><ol start="2"><li><strong>边界值分析</strong></li></ol><p>使用边界值分析方法设计测试方案首先应该确定边界情况，通常输入等价类和输出等价类的边界。选取的测试数据应该刚好<strong>等于、刚刚小于和刚刚大于</strong>边界值<br>通常设计测试方案时总是联合使用<strong>等价划分和边界值分析</strong>两种技术</p><ol start="3"><li><strong>错误推测</strong></li></ol><p>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h4 id="软件调试定义-x2F-步骤："><a href="#软件调试定义-x2F-步骤：" class="headerlink" title="软件调试定义&#x2F;步骤："></a>软件调试定义&#x2F;步骤：</h4><p>调试（也称为纠错）作为成功测试的后果出现，即<strong>调试是在测试发现错误之后排除错误的过程</strong>。<br>软件错误的外部表现和它的内在原因之间可能并没有明显的联系。调试就是把症状和原因联系起来的尚未被人深入认识的智力过程。<br>调试不是测试<br>调试过程从执行一个测试用例开始，评估测试结果，如果发现实际结果与预期结果不一致，则这种不一致就是一个症状，它表明在软件中存在着隐藏的问题。调试过程试图找出产生症状的原因，以便改正错误。<br><img src="https://s1.ax1x.com/2023/05/15/p9glxGn.png#height=318&id=c67qe&originHeight=636&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=396"><br><strong>调试途径：</strong></p><ol><li>蛮干法：最低效</li><li>回溯法：从发现症状的地方开始，人工沿程序的控制流往回追踪分析源程序代码，直到找出错误原因为止</li><li>原因排查法：对分查找法、归纳法和演绎法<ol><li>对分查找法：如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近“注入”这些变量的正确值，然后运行程序并检查所得到的输出。</li><li>归纳法：从个别现象推断出一般性结论的思维方法。使用这种方法调试程序时，首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设</li><li>演绎法：从一般原理或前提出发，经过排除和精化的过程推导出结论。采用这种方法调试程序时，首先设想出所有可能的出错原因，然后试图用测试来排除每一个假设的原因</li></ol></li></ol><h1 id="🍒08章-维护"><a href="#🍒08章-维护" class="headerlink" title="🍒08章 维护"></a>🍒08章 维护</h1><h4 id="软件维护定义-x2F-类型"><a href="#软件维护定义-x2F-类型" class="headerlink" title="软件维护定义&#x2F;类型"></a>软件维护定义&#x2F;类型</h4><p>所谓软件维护就是在软件<strong>已经交付使用</strong>之后，为了<strong>改正错误或满足新的需要</strong>而<strong>修改软件</strong>的过程。可以通过描述软件交付使用后可能进行的<strong>4</strong>项活动，具体地定义软件维护。<br>（改适完预）</p><ol><li><strong>改正性维护</strong>：在任何大型程序的使用期间，用户必然会发现程序错误，并且把他们遇到的问题报告给维护人员。把<strong>诊断和改正错误的过程</strong>称为改正性维护。</li><li><strong>适应性维护</strong>：<strong>第二项维护活动</strong>。适应性维护也就是为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动</li><li><strong>完善性维护</strong>：当一个软件系统顺利地运行时，常常出现第三项维护活动：在使用软件的过程中用户往往提出<strong>增加新功能或修改已有功能</strong>的建议，还可能提出一般性的改进意见。为了满足这类要求，需要进行<strong>完善性维护</strong>。这项维护活动通常占软件维护工作的<strong>大部分</strong></li><li><strong>预防性维护</strong>：当为了改进未来的<strong>可维护性</strong>或<strong>可靠性</strong>，或为了给<strong>未来的改进</strong>奠定更好的基础而修改软件时，出现了第四项维护活动。这项维护活动通常称为预防性维护，目前这项维护活动相对比较少</li></ol><p>上述4类维护活动都<strong>必须应用于整个软件配置</strong></p><h4 id="软件再工程定义-x2F-步骤"><a href="#软件再工程定义-x2F-步骤" class="headerlink" title="软件再工程定义&#x2F;步骤"></a>软件再工程定义&#x2F;步骤</h4><p>程序再工程是指<strong>通过对目标系统的检查和改造</strong>，其中包括设计恢复（库存目录分析）、再文档、逆向工程、程序和数据重构以及正向工程等一系列活动，旨在将逆向工程、重构和正向工程组合起来，<strong>将现存系统重新构造为新的形式，以开发出质量更高、维护性更好的软件</strong><br>典型的<strong>软件再工程过程模型</strong>如下图所示。在某些情况下这些活动以线性顺序发生，但也并非总是这样。例如，为了理解某个程序的内部工作原理，可能在文档重构开始之前必须先进行逆向工程<br><img src="https://s1.ax1x.com/2023/05/14/p9co54O.png#height=272&id=dCMkE&originHeight=542&originWidth=495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=248"></p><h1 id="🍒09章-面向对象方法学引论"><a href="#🍒09章-面向对象方法学引论" class="headerlink" title="🍒09章 面向对象方法学引论"></a>🍒09章 面向对象方法学引论</h1><h4 id="面向对象的统一软件开发过程的各阶段-里程碑"><a href="#面向对象的统一软件开发过程的各阶段-里程碑" class="headerlink" title="面向对象的统一软件开发过程的各阶段 里程碑"></a>面向对象的统一软件开发过程的各阶段 里程碑</h4><p>RUP中的软件生命周期在时间上被分解为四个顺序的阶段 </p><ol><li>初始阶段(Inception) （生命周期目标里程碑 ）</li><li>细化阶段(Elaboration)（生命周期结构里程碑） </li><li>构造阶段(Construction)（初始运行能力 ）</li><li>交付阶段(Transition)（产品发布里程碑）</li></ol><h4 id="关联，两种聚集关联定义"><a href="#关联，两种聚集关联定义" class="headerlink" title="关联，两种聚集关联定义"></a>关联，两种聚集关联定义</h4><ol><li><strong>关联</strong></li></ol><p>关联表示<strong>两个类的对象之间存在某种语义上的联系</strong></p><ol><li>普通关联</li><li>关联的角色</li><li>限定关联</li><li>关联类</li><li><strong>聚集</strong></li></ol><p>聚集也称为聚合，是关联的特例。聚集表示类与类之间的关系是<strong>整体与部分</strong>的关系。使用的“包含”、“组成”、“分为……部分”等字句，意味着存在聚集关系。有<strong>共享聚集</strong>和<strong>组合聚集</strong>两种特殊的聚集关系</p><ol><li>共享聚集</li></ol><p>如果在聚集关系中<strong>处于部分方的对象可同时参与多个处于整体方对象的构成</strong>，则该聚集称为共享聚集。一般聚集和共享聚集的关联关系用空心菱形表示。</p><ol start="2"><li>组合聚集</li></ol><p>如果<strong>部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失</strong>（或失去存在价值了），则该聚集称为组合聚集（简称为组成）。组合聚集的组成关系用实心菱形表示。</p><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>一幅用例图包含的模型元素有<strong>系统、行为者、用例及用例之间的关系</strong>。<br>图是自动售货机系统的用例图。图中的方框代表系统，椭圆代表用例（售货、供货和取货款是自动售货机系统的典型用例），线条人代表行为者，它们之间的连线表示关系<br><img src="https://s1.ax1x.com/2023/05/15/p9g87Kx.png#height=185&id=PncPi&originHeight=737&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=148"><br>一个用例是可以被行为者感受到的、系统的一个完整的功能。在UML中把用例定义成系统完成的一系列动作，动作的结果能被特定的行为者察觉到。这些动作除了完成系统内部的计算与工作外，还包括与一些行为者的通信。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是双向的。<br>用例具有下述特征：</p><ol><li>用例代表某些用户可见的功能，实现一个具体的用户目标。</li><li>用例总是被行为者启动的，并向行为者提供可识别的值。</li><li>用例必须是完整的。</li></ol><p>UML提供的用例图是进行需求分析和建立功能模型的强有力工具。</p><ul><li>使用UML的<strong>类图</strong>来建立<strong>对象模型</strong>，使用UML的<strong>状态图</strong>来建立<strong>动态模型</strong>，使用<strong>数据流图</strong>或UML的<strong>用例图</strong>来建立<strong>功能模型</strong>。在UML中把用用例图建立起来的系统模型称为<strong>用例模型</strong>。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图<strong>描述类及类与类之间的静态关系</strong>。类图是一种静态模型，它是创建其他UML图的基础。一个系统可以由多张类图来描述，一个类也可以出现在几张类图中</p><ul><li>UML描述属性的语法格式如下：</li></ul><p>可见性 属性名：类型名&#x3D;初值{性质串}</p><ul><li>服务也就是操作，UML描述操作的语法格式如下：</li></ul><p>可见性 操作名（参数表）： 返回值类型{性质串}</p><h1 id="🍒10章-面向对象分析"><a href="#🍒10章-面向对象分析" class="headerlink" title="🍒10章 面向对象分析"></a>🍒10章 面向对象分析</h1><h4 id="面向对象需要建立的三类模型"><a href="#面向对象需要建立的三类模型" class="headerlink" title="面向对象需要建立的三类模型"></a>面向对象需要建立的三类模型</h4><p>用面向对象方法开发软件，通常需要建立3种形式的模型，它们分别是：</p><ol><li><strong>描述系统数据结构的对象模型</strong></li></ol><p>对象模型是从系统的静态结构上描述系统的需求</p><ol start="2"><li><strong>描述系统控制结构的动态模型</strong></li></ol><p>动态模型是描述系统的交互行为的需求</p><ol start="3"><li><strong>描述系统功能的功能模型</strong></li></ol><p>功能模型表明的是系统中数据之间的依赖关系，以及有关的数据处理功能，一般采用数据流图描述<br>在任何情况下，<strong>对象模型</strong>始终都是最重要、最基本、最核心的。<br>面向对象建模得到的模型包含系统的3个要素，即<strong>静态结构</strong>（对象模型）、<strong>交互次序</strong>（动态模型）和<strong>数据变换</strong>（功能模型）。解决的问题不同，这3个子模型的重要程度也不同。</p><h4 id="对象模型的5个层次"><a href="#对象模型的5个层次" class="headerlink" title="对象模型的5个层次"></a>对象模型的5个层次</h4><p>复杂问题（大型系统）的对象模型通常由下述5个层次组成：<br>（主类结束符）<br><img src="https://s1.ax1x.com/2023/05/14/p9cTaxH.png#height=185&id=DZtVP&originHeight=369&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=404"></p><h4 id="软件重用定义"><a href="#软件重用定义" class="headerlink" title="软件重用定义"></a>软件重用定义</h4><p>两次或多次不同的软件开发过程中使用相同或相似软件元素的过程<br>重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使用。广义地说，软件重用可分为以下3个层次：</p><ol><li>知识重用</li><li>方法和标准的重用</li><li><strong>软件成分的重用</strong></li></ol><p>软件过程的增量模型<img src="https://s1.ax1x.com/2023/05/16/p92zhIe.png#height=374&id=i82C8&originHeight=748&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 课程总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——入门模拟</title>
      <link href="/2023/05/08/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/"/>
      <url>/2023/05/08/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊入门模拟"><a href="#🎊入门模拟" class="headerlink" title="🎊入门模拟"></a>🎊入门模拟</h1><h2 id="🎀日期处理"><a href="#🎀日期处理" class="headerlink" title="🎀日期处理"></a>🎀日期处理</h2><p>一个二维数组int month[13][2]，用于存放每个月的天数，其中第二维为0表示平年，为1表示闰年<br>具体处理：当加了一天后天数d等于当前月份m所拥有的天数加1，那么月份m+1，同时置天数d为1；若此时月份m为13，则令年份加1，同时置月份m为1</p><h4 id="🎈scanf的用法"><a href="#🎈scanf的用法" class="headerlink" title="🎈scanf的用法"></a>🎈scanf的用法</h4><p>——要读入以下的数据，得到年月日（2019-10-3）因为里面有-字符所以你没有办法直接的把数据读进来scanf(“%d-%d-%d”,&amp;a,&amp;b,&amp;c);，这样你就可以得到年月日，也就是a，b，c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n%<span class="number">400</span>==<span class="number">0</span>|| (n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yyyy,mm,dd,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;yyyy,&amp;mm,&amp;dd);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a=n;</span><br><span class="line">    <span class="keyword">while</span>(a--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        dd--;</span><br><span class="line">        <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">            mm--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((mm)==<span class="number">0</span>)&#123;</span><br><span class="line">            mm=<span class="number">12</span>;yyyy--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">            dd=month[mm][<span class="built_in">year</span>(yyyy)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d&quot;</span>,yyyy,mm,dd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该题中，日月年的减法顺序是很重要的，需要考虑dd为0，mm为1的情况，此时需要跳转到前一年的最后一天</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闰则为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">400</span>==<span class="number">0</span>||(n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2加一天</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;yyyy,<span class="type">int</span> &amp;mm,<span class="type">int</span> &amp;dd)</span></span>&#123;</span><br><span class="line">    dd++;</span><br><span class="line">    <span class="keyword">if</span>(dd==month[mm][<span class="built_in">year</span>(yyyy)]+<span class="number">1</span>)&#123;</span><br><span class="line">        dd=<span class="number">1</span>;mm++;</span><br><span class="line">        <span class="keyword">if</span>(mm==<span class="number">13</span>)&#123;</span><br><span class="line">            mm=<span class="number">1</span>;yyyy++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2减一天</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;yyyy,<span class="type">int</span> &amp;mm,<span class="type">int</span> &amp;dd)</span></span>&#123;</span><br><span class="line">    dd--;</span><br><span class="line">    <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">        mm--;</span><br><span class="line">        <span class="keyword">if</span>(mm==<span class="number">0</span>)&#123;</span><br><span class="line">            mm=<span class="number">12</span>;yyyy--;</span><br><span class="line">        &#125;</span><br><span class="line">        dd=month[mm][<span class="built_in">year</span>(yyyy)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1则1比2大 2要加   0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> yyyy1,<span class="type">int</span> yyyy2,<span class="type">int</span> mm1,<span class="type">int</span> mm2,<span class="type">int</span> dd1,<span class="type">int</span> dd2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(yyyy1&gt;yyyy2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(yyyy1&lt;yyyy2)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mm1&gt;mm2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mm1&lt;mm2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dd1&gt;dd2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dd1&lt;dd2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yyyy1=<span class="number">2020</span>,mm1=<span class="number">2</span>,dd1=<span class="number">28</span>,w=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> yyyy2,mm2,dd2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;yyyy2,&amp;mm2,&amp;dd2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">1</span>)&#123;<span class="comment">//1大 日期2要加1  星期要减1</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(yyyy2,mm2,dd2);</span><br><span class="line">            w=(w<span class="number">-1</span>+<span class="number">7</span>)%<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sub</span>(yyyy2,mm2,dd2);</span><br><span class="line">            w=(w+<span class="number">1</span>)%<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知一个日期是周几，求输入日期的星期数——根据两个日期间的差值求<br>所给日期与当前日期的关系一定要搞清楚！</p><h2 id="🎀进制转换"><a href="#🎀进制转换" class="headerlink" title="🎀进制转换"></a>🎀进制转换</h2><h4 id="🎈将P进制数x转换为十进制数y"><a href="#🎈将P进制数x转换为十进制数y" class="headerlink" title="🎈将P进制数x转换为十进制数y"></a>🎈将P进制数x转换为十进制数y</h4><p>P进制数x为a1a2…an，可以得到十进制数y<br><img src="https://cdn.nlark.com/yuque/__latex/4220159adf7f91c5edf9407589658aef.svg#card=math&code=y%3Da_%7B1%7D%20%2A%20P%5E%7Bn-1%7D%2Ba_%7B2%7D%20%2A%20P%5E%7Bn-2%7D%2B%5Ccdots%2Ba_%7Bn-1%7D%20%2A%20P%2Ba_%7Bn%7D&id=DjBLp"><br>可以利用循环代码实现上述公式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">0</span>, product = <span class="number">1</span>;<span class="comment">//product每次都乘p</span></span><br><span class="line"><span class="keyword">while</span>(x! = <span class="number">0</span>)&#123;</span><br><span class="line">    y = y + (x % <span class="number">10</span>) * product;<span class="comment">//x%10获取x的个位数</span></span><br><span class="line">    x = x/<span class="number">10</span>;</span><br><span class="line">    product = product * p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🎈将十进制数y转换为P进制数z"><a href="#🎈将十进制数y转换为P进制数z" class="headerlink" title="🎈将十进制数y转换为P进制数z"></a>🎈将十进制数y转换为P进制数z</h4><p>采用“除基取余法”，基为将要转化为的进制Q，得到的余数作为低位存储</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> z[<span class="number">40</span>],num = <span class="number">0</span>;<span class="comment">//num为位数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num++] = y % Q;<span class="comment">//除基取余</span></span><br><span class="line">    y = y/Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y != <span class="number">0</span>)<span class="comment">//当商不为0时进行循环</span></span><br></pre></td></tr></table></figure><p>z数组从高位z[num–]到低位z[0]即为Q进制z</p><h2 id="🎀字符串处理"><a href="#🎀字符串处理" class="headerlink" title="🎀字符串处理"></a>🎀字符串处理</h2><p><strong>难题1：</strong><br>给定n个字符串，求它们的公共前缀。<br>——如何获取输入的数值和如何比较公共前缀是本题的两大重点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">51</span>;</span><br><span class="line"><span class="type">char</span> str[MAXN][MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, minL = MAXL;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="comment">//千万不能漏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin.<span class="built_in">getline</span>(str[i], MAXL);<span class="comment">//不要忘记这种读取一行字符串的方式</span></span><br><span class="line">        minL = <span class="built_in">min</span>(minL, (<span class="type">int</span>)<span class="built_in">strlen</span>(str[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; minL; j++) &#123;</span><br><span class="line">        <span class="type">bool</span> isSame = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i][j] != str[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                isSame = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[<span class="number">0</span>][j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>难题2：</strong><br>按从左到右字符出现的顺序，输出每个字符连续出现的个数。<br>其中每个字符输出一行，每行以空格为分隔，输出该字符与出现的个数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(str,<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==str[i+<span class="number">1</span>]&amp;&amp;i+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">            i++;num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>——不要把简单问题想复杂了，所求是连续字符的个数，完全不需要使用二维数组</p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——基础知识</title>
      <link href="/2023/05/05/C-C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/05/C-C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊基础知识"><a href="#🎊基础知识" class="headerlink" title="🎊基础知识"></a>🎊基础知识</h1><h2 id="🎀if-else"><a href="#🎀if-else" class="headerlink" title="🎀if-else"></a>🎀if-else</h2><p>使用如下方式而不使用if-else，更为简便清晰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(a &gt;= b ? <span class="string">&quot;A &gt;= B&quot;</span> : <span class="string">&quot;A &lt; B&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="🎀getchar函数"><a href="#🎀getchar函数" class="headerlink" title="🎀getchar函数"></a>🎀getchar函数</h2><p>用来输入单个字符，因此需要注意换行符的存在，可以使用getchar()来读取换行符</p><h2 id="🎀数学函数的使用"><a href="#🎀数学函数的使用" class="headerlink" title="🎀数学函数的使用"></a>🎀数学函数的使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span> <span class="comment">//头文件 </span></span></span><br><span class="line"><span class="built_in">fabs</span>(a):a的绝对值</span><br><span class="line"><span class="built_in">floor</span>(a):a的向下取整</span><br><span class="line"><span class="built_in">ceil</span>(a):a的向上取整</span><br><span class="line"><span class="built_in">round</span>(a):a的四舍五入(四舍六入五成双)</span><br><span class="line"><span class="built_in">pow</span>(a,b):a的b次方,b可以为浮点型</span><br><span class="line"><span class="built_in">sqrt</span>(a):a的算术平方根(开根号)</span><br><span class="line"><span class="built_in">log</span>(a):a的以自然对数e为底的对数</span><br></pre></td></tr></table></figure><h2 id="🎀switch-case语句格式"><a href="#🎀switch-case语句格式" class="headerlink" title="🎀switch-case语句格式"></a>🎀switch-case语句格式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常数表达式<span class="number">1</span>：</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常数表达式<span class="number">2</span>：</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀continue语句"><a href="#🎀continue语句" class="headerlink" title="🎀continue语句"></a>🎀continue语句</h2><p>和break类似，continue也是用在循环当中，但区别是break语句执行后循环就被彻底退出，而continue则只是跳过当前这一轮，继续进行下一轮，并不是停止循环，所以很适合在满足某些条件需要不执行循环体内容时使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀比较两数大小"><a href="#🎀比较两数大小" class="headerlink" title="🎀比较两数大小"></a>🎀比较两数大小</h2><p>C语言快速比较两数大小——<strong>fmax，fmin函数</strong><br>头文件include&lt;math.h&gt;，作用是返回两个浮点参数中较大的一个</p><h2 id="🎀冒泡排序"><a href="#🎀冒泡排序" class="headerlink" title="🎀冒泡排序"></a>🎀冒泡排序</h2><p>——本质在于交换，每趟将最大或者最小值移到最后</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//比较趟数，n个数共比较n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//a[0]到a[n-i-1]都与他们的下一个数进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>交换两个数可以用#include<algorithm>中的swap（a,b）</p><h2 id="🎀memset函数"><a href="#🎀memset函数" class="headerlink" title="🎀memset函数"></a>🎀memset函数</h2><p>——头文件#include&lt;string.h&gt;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,值,<span class="built_in">sizeof</span>(数组名));</span><br></pre></td></tr></table></figure><p>一般只建议用memset函数赋值0和-1——memset按照字节赋值，赋值其他数字可以用fill</p><h2 id="🎀字符数组"><a href="#🎀字符数组" class="headerlink" title="🎀字符数组"></a>🎀字符数组</h2><p>char型字符数组的长度比事迹存储字符串的长度至少多1（结束符\0）<br>如果不是使用scanf函数或gets函数输入字符串（如getchar），一定要加入\0，否则会乱码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=<span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>输出和输出——%c用来输入单个字符，%s用来输入一个字符串并存在字符数组中。</li></ul><p>%c格式能够识别空格跟换行并将其输入，%s通过空格或换行来识别一个字符串的结束。<br><strong>scanf在使用%s不需要&amp;取地址</strong></p><ul><li>getchar()输入，putchar()输出单个字符</li></ul><p>str[i][j]&#x3D;getchar() putchar(str[i][j])   注意：<strong>每行末尾有换行符</strong>,有需要的需要通过gets()或getchar()来处理换行符</p><ul><li><strong>gets(str)输入</strong>和puts()输出一行字符串</li></ul><p>gets()识别\n作为输入结束，<strong>puts()输出自带\n换行</strong>，比printf(“%s\n”,str[i]);更便捷</p><ul><li>字符数组的整行输入</li></ul><p>在比较早的C&#x2F;C++版本中，经常可以看到推荐使用gets函数来进行整行字符串的输入，就像下面这样的简单写法即可输入一整行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gets</span>(str);</span><br></pre></td></tr></table></figure><p>但是当输入的字符串长度超过数组长度上限MAX_LEN时，gets函数会把超出的部分也一并读进来，并且会覆盖数组之外的内存空间，这就导致了一定的安全风险，因此C++11标准将gets函数废弃了，然后在C++14时将该函数移除，如果现在想要整行输入的话，推荐使用cin.getline函数；而在C语言标准中gets函数则是在C11时被移除，与此同时增加了gets_s函数，除此之外还有fgets函数可供选择。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namesapce std;</span><br><span class="line">cin.<span class="built_in">getline</span>(str, MAX_LEN);<span class="comment">//第一个参数为字符数组，第二个参数是最大允许读入的字符个数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gets_s(str, MAX_LEN);</span><br></pre></td></tr></table></figure><h3 id="🎈string-h头文件"><a href="#🎈string-h头文件" class="headerlink" title="🎈string.h头文件"></a>🎈string.h头文件</h3><p>strlen()函数——得到字符数组中第一个\0前的字符个数<br>strcmp()函数——返回字符串大小的比较结果，比较原则”字典序”<br>strcmp(str1,str2)——str1&lt;str2返回一个负整数；str1&#x3D;str2返回0；str1&gt;str2返回一个正整数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strcpy()函数——把一个字符串复制给另一个字符串<br>strcpy(str1,str2)——把字符数组2复制给字符数组1，包括\0<br>strcat()函数——把一个字符串接到另一个字符串后面<br>strcat(str1,str2)——把字符数组2接到字符数组1后面</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    cin &gt;&gt; s2;</span><br><span class="line">    cout &lt;&lt; s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈sscanf与springf"><a href="#🎈sscanf与springf" class="headerlink" title="🎈sscanf与springf"></a>🎈sscanf与springf</h3><p>假定一个char数组str[100]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="comment">//把字符数组str中的内容以%d的形式写到n中</span></span><br><span class="line"><span class="comment">//成功返回参数的数目，失败则返回0</span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="comment">//把n以%d的格式写到字符数组str中</span></span><br></pre></td></tr></table></figure><p>%04d可以输出四位数，不够则前面用0补全，与%.2f有异曲同工之处</p><h2 id="🎀Max值"><a href="#🎀Max值" class="headerlink" title="🎀Max值"></a>🎀Max值</h2><p>求三个数中的最大值，不仅可以自定义函数，也可如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(&#123;a, b, c&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀指针"><a href="#🎀指针" class="headerlink" title="🎀指针"></a>🎀指针</h2><p>获得变量的地址——取地址运算符&amp;</p><h3 id="🎈指针变量"><a href="#🎈指针变量" class="headerlink" title="🎈指针变量"></a>🎈指针变量</h3><p>指针变量用来存放指针（可以理解为地址）——int* p;<br>（一次有好几个同种类型的指针变量 要同时定义，星号只会结合第一个变量名）<br>给指针变量赋值的方式——把变量的地址取出来，然后赋给对应类型的指针变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="comment">//(int*)是指针变量的类型 p才是变量名</span></span><br><span class="line">*p = a的值</span><br><span class="line"><span class="comment">//*作为开启房间的钥匙，放在p的前面，这样*p就可以获取到房间里的东西，即存储的数据</span></span><br><span class="line"><span class="comment">//直接对*p进行赋值，也可以起到改变那个保存的元素的功能</span></span><br></pre></td></tr></table></figure><p>指针变量p+1——p所指的int型变量的下一个int型变量地址（也支持++,–操作）</p><h3 id="🎈指针与数组"><a href="#🎈指针与数组" class="headerlink" title="🎈指针与数组"></a>🎈指针与数组</h3><p>对于数组，可以在元素前面加取地址运算符&amp;来获取它的地址，例如a[0]的地址为&amp;a[0]，即数组a的首地址为&amp;a[0]<br>在C语言中，数组名称也作为数组的首地址使用，a&#x3D;&#x3D;&amp;a[0]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);<span class="comment">//a+i等同于&amp;a[i]——数组a的首地址偏移i个int型变量的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(a+i));<span class="comment">//a+i只是一个地址，要想访问其中的元素，还是需要*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针变量可以自增操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span>* p = a; p &lt; a+<span class="number">10</span>; p++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈使用指针变量作为函数参数"><a href="#🎈使用指针变量作为函数参数" class="headerlink" title="🎈使用指针变量作为函数参数"></a>🎈使用指针变量作为函数参数</h3><p>指针类型也可以作为函数参数的类型，这时视为把变量的地址传入函数。如果在函数中对这个地址中的元素进行改变，原先的数据就会确实地被改变。</p><ul><li>使用指针进行两个数的交换</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span>* temp;</span><br><span class="line">    <span class="comment">//在定义temp时，temp没有被初始化，此时temp中存放的地址是随机的，很有可能出错</span></span><br><span class="line">    <span class="comment">/*可以给temp赋个初值</span></span><br><span class="line"><span class="comment">int x;int* temp = &amp;x;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    *temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法二</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="comment">//直接交换两个数的地址，在swap函数中交换后，在main函数中实际并未交换</span></span><br><span class="line">    <span class="comment">//传入swap中的只是a和b的地址，无符号整型的数字而已，并不能实现main函数中的双向交换</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数参数的传送方式是单向一次性的</span></span><br></pre></td></tr></table></figure><h3 id="🎈引用"><a href="#🎈引用" class="headerlink" title="🎈引用"></a>🎈引用</h3><p>——在函数中想要修改传入的参数，但又不想使用指针<br>引用不产生副本，只是给变量起了个别名，对引用变量的操作就是对原变量的操作（取一个小名）</p><ul><li>在函数参数类型后面加一个&amp;即可</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;<span class="comment">//不需要return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(a);<span class="comment">//a=10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把引用的&amp;和取地址运算符&amp;区分开来，引用≠取地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对指针本身的修改无法作用到原指针变量上</span></span><br><span class="line"><span class="comment">//可以通过指针的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* &amp;a,<span class="type">int</span>* &amp;b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀结构体（struct）的使用"><a href="#🎀结构体（struct）的使用" class="headerlink" title="🎀结构体（struct）的使用"></a>🎀结构体（struct）的使用</h2><h3 id="🎈结构体的定义"><a href="#🎈结构体的定义" class="headerlink" title="🎈结构体的定义"></a>🎈结构体的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Name</span>&#123;</span><br><span class="line"><span class="comment">//一些基本的数据结构或者自定义的数据类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> gender;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;Alice,Bob,stu[<span class="number">1000</span>];<span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="comment">//也可以</span></span><br><span class="line">studentInfo Alice;</span><br><span class="line">studentInfo stu[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure><p>结构体里面不能定义自身，但可以定义自身类型的指针变量 studentInfo* next;——√</p><h3 id="🎈访问结构体内的元素"><a href="#🎈访问结构体内的元素" class="headerlink" title="🎈访问结构体内的元素"></a>🎈访问结构体内的元素</h3><p>访问结构体内的元素——“.”操作和“-&gt;”操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">studentInfo* next;</span><br><span class="line">&#125;stu,*p;<span class="comment">//普通变量stu和指针变量p</span></span><br><span class="line">——访问stu变量</span><br><span class="line">stu.id</span><br><span class="line">stu.name</span><br><span class="line">stu.next</span><br><span class="line">——访问指针变量p中的元素</span><br><span class="line">(*p).<span class="built_in">id</span></span><br><span class="line">(*p).<span class="built_in">name</span></span><br><span class="line">(*p).next</span><br><span class="line">——访问结构体指针变量内元素的更简洁的方法</span><br><span class="line">p-&gt;id</span><br><span class="line">p-&gt;name</span><br><span class="line">p-&gt;next</span><br></pre></td></tr></table></figure><h3 id="🎈结构体的初始化"><a href="#🎈结构体的初始化" class="headerlink" title="🎈结构体的初始化"></a>🎈结构体的初始化</h3><p>构造函数的方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//下面的参数用以对结构体内部变量进行赋值</span></span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id,<span class="type">char</span> _gender)&#123;</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        id = _id;</span><br><span class="line">        gender = _gender;</span><br><span class="line">    <span class="comment">//也可以</span></span><br><span class="line">    <span class="built_in">studentInfo</span>(<span class="type">int</span> _id,<span class="type">int</span> _gender):<span class="built_in">id</span>(_id),<span class="built_in">gender</span>(_gender)&#123;&#125;</span><br><span class="line">    <span class="built_in">studentInfo</span>()&#123;&#125;;</span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id):<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">studentInfo stu = <span class="built_in">studentInfo</span>(<span class="number">10086</span>,<span class="string">&#x27;M&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了既能不初始化就定义结构变量，又能享受初始化带来的便捷，可以手动加上默认的生成函数，也可以定义参数个数和类型不完全相同的构造函数</p><h2 id="🎀补充"><a href="#🎀补充" class="headerlink" title="🎀补充"></a>🎀补充</h2><h3 id="🎈cin和cout"><a href="#🎈cin和cout" class="headerlink" title="🎈cin和cout"></a>🎈cin和cout</h3><p>——#include<iostream> using namespace std;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;<span class="comment">//endl表示换行</span></span><br></pre></td></tr></table></figure><p>保留小数setprecision（n）的用法<br>——头文件#include<iomanip><br>cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;d;</p><h2 id="🎀黑盒测试"><a href="#🎀黑盒测试" class="headerlink" title="🎀黑盒测试"></a>🎀黑盒测试</h2><h3 id="🎈单点测试"><a href="#🎈单点测试" class="headerlink" title="🎈单点测试"></a>🎈单点测试</h3><h3 id="🎈多点测试"><a href="#🎈多点测试" class="headerlink" title="🎈多点测试"></a>🎈多点测试</h3><ol><li>三种输入方式</li></ol><ul><li><strong>while…EOF型</strong></li></ul><p>题目<strong>没有给定输入的结束条件</strong>，默认读取到文件末尾</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)!=EOF)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入字符串</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">gets</span>(str)!=<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;str)!=EOF)&#123;&#125;</span><br></pre></td></tr></table></figure><p>只要scanf的返回值不为EOF（文件中的数据没有读完）就反复读入a，执行while中的内容</p><ul><li><strong>while…break型</strong></li></ul><p>题目要求当<strong>输入的数据满足某个条件</strong>时，停止输入<br><strong>w</strong>hile…EOF型的衍生</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简略写法</span></span><br><span class="line"><span class="comment">//a和b中有一个不为0就进行循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b),a||b)&#123;<span class="comment">//a!=0||b!=0</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>while（T–）型</strong></li></ul><p>题目会给出测试数据的组数，接着才给出相应数量组数的输入数据</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>三种输出方法</li></ol><ul><li><strong>正常输出</strong></li><li><strong>每组数据输出后都要额外加一个空行</strong></li><li><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程设计——应用小大根交替堆实现双端优先队列</title>
      <link href="/2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="🔮课程设计选题"><a href="#🔮课程设计选题" class="headerlink" title="🔮课程设计选题"></a>🔮课程设计选题</h1><p><strong>应用小大根交替堆实现双端优先队列</strong></p><h1 id="🔮需求和规格说明"><a href="#🔮需求和规格说明" class="headerlink" title="🔮需求和规格说明"></a>🔮需求和规格说明</h1><h2 id="🎠问题描述"><a href="#🎠问题描述" class="headerlink" title="🎠问题描述"></a>🎠问题描述</h2><p>双端优先队列是一个支持如下操作的数据结构：</p><ul><li>Insert （S, x）——将元素x 插入集合S</li><li>Extract –Min （S）——删除S 中的最小关键字</li><li>Extract –Max （S）——删除S 中的最大关键字</li></ul><p>可用小大根交替堆来实现对上述三个操作的支持</p><h2 id="🎠实验要求"><a href="#🎠实验要求" class="headerlink" title="🎠实验要求"></a>🎠实验要求</h2><ol><li>给出双端优先队列的ADT 描述，包括优先队列的逻辑结构及其上基本操作。</li><li>给出小大根交替堆的ADT 描述，并实现该ADT。</li><li>以小大根交替堆结构为辅助结构实现双端优先队列的存储表示并实现其上的基本操作。</li><li>应用双端优先队列的ADT 实现依据学生成绩实现对学生信息的查询。</li><li>学生信息存放在文本文件中（格式自定，内容自行输入）。</li></ol><h1 id="🔮设计"><a href="#🔮设计" class="headerlink" title="🔮设计"></a>🔮设计</h1><h2 id="🎠整体思路"><a href="#🎠整体思路" class="headerlink" title="🎠整体思路"></a>🎠整体思路</h2><ol><li>双端优先队列以抽象类的方式建立ADT</li><li>使用小大根交替堆继承双端优先队列，并对其基本操作进行实现</li><li>建立学生信息类，将学生的相关信息（学生的学号，姓名，出生年月，出生日期，出生地，语文成绩，数学成绩，英语成绩等）</li><li>通过调用小大根交替堆中的基本函数对根据学生的各项成绩对学生的信息进行查询</li></ol><h2 id="🎠小大根交替堆和双端优先队列"><a href="#🎠小大根交替堆和双端优先队列" class="headerlink" title="🎠小大根交替堆和双端优先队列"></a>🎠小大根交替堆和双端优先队列</h2><h3 id="🎨基本介绍"><a href="#🎨基本介绍" class="headerlink" title="🎨基本介绍"></a>🎨基本介绍</h3><p>双端优先队列是指能够同时访问最大元素和最小元素的优先级队列。其主要的操作有：插入一个元素、访问最大元素、删除最大元素、访问最小元素、删除最小元素以及判断队列是否为空。通常双端优先队列的实现是通过最小最大堆来实现的。<br>小大根交替堆是一个满足如下小大根交替条件的完全二元树：如果该二元树不空，那么其上的每个元素都有一个称为关键字的域，且针对该关键字，二元树按层次形成了小大根交替的形式，即对于小大根交替堆中的任何一个结点x，如果x 位于小根层次，那么x 就是以x 为根节点的二元树中键值最小的结点，并称该结点为一个小根结点。同样的道理，如果x 位于大根层次，那么x 就是以x 为根节点的二元树中键值最大的结点，并称该结点为一个大根结点。在小大根交替堆中根结点位于小根层次。</p><h3 id="🎨实现结构"><a href="#🎨实现结构" class="headerlink" title="🎨实现结构"></a>🎨实现结构</h3><p>由于双端优先队列是基于小大根交替堆来实现的，所以在本次实验中，使用小大根交替堆继承双端优先队列来实现相关操作。</p><ol><li><strong>双端优先队列的属性和方法定义</strong></li></ol><img src="https://s1.ax1x.com/2023/05/11/p9sKP0I.png#id=oN1k1&originHeight=335&originWidth=1483&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 80%;" /><ol start="2"><li><strong>小大根交替堆的属性和方法定义</strong></li></ol><img src="https://s1.ax1x.com/2023/05/11/p9sKi7t.png#id=o1Mqt&originHeight=775&originWidth=1983&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 80%;" /><ol start="3"><li><strong>算法设计和分析</strong><ol><li><strong>找出下标为i的结点的儿子和孙子中的最小值</strong></li></ol></li></ol><p>int find_min_child_grandchild(min_max_heap<T>* h, int i)<br>分别表示下标为i的结点元素，通过逐个比较法最后输出其中的最小值</p><ol start="2"><li><strong>找出下标为i的结点的儿子和孙子中的最大值</strong></li></ol><p>int find_max_child_grandchild(min_max_heap<T>* h, int i)<br>分别表示下标为i的结点元素，通过逐个比较法最后输出其中的最大值</p><ol start="3"><li><strong>交换堆中下标为i和j的数据</strong></li></ol><p>void swap(min_max_heap<T>* h, int i, int j)<br>通过一个中间元素值T temp对当前堆中的元素进行交换</p><ol start="4"><li><strong>小层元素下滤操作，保证结构为以小层元素为根的小根堆</strong></li></ol><p>void TrickleDownMin(min_max_heap<T>* h, int i)<br>首先先找到下标为i的小层元素的儿子和孙子中的最小值：</p><ul><li>如果最小值是处于大层的儿子，那么根据小大交替堆的定义可以知道该元素没有孙子，此时比较该元素与儿子的大小关系，如果儿子小于自己，则交换元素来维护当前小根堆的结构。</li><li>如果最小值是孙子，比较孙子和该元素的大小关系：如果孙子大于该元素，证明以该元素为根节点的树的最小值就是它本身，不需要改变就符合小根堆的结构；如果孙子小于该元素，那么交换孙子和该元素，交换后需要判断该元素和父亲节点（也就是原来的儿子结点）的大小：如果父亲结点小于该元素，那么父亲结点不满足大根堆的结构，需要交换父亲节点和该元素，交换后对应孙子节点位置的元素不正确，那么就需要再对该元素进行下滤操作做递归调用。<ol start="5"><li><strong>大层元素下滤操作，保证结构为以大层元素为根的大根堆</strong></li></ol></li></ul><p>void TrickleDownMax(min_max_heap<T>* h, int i)<br>和小层元素的下滤操作有着异曲同工之意<br>首先先找到下标为i的大层元素的儿子和孙子中的最大值：</p><ul><li>如果最大值是处于小层的儿子，那么证明该元素没有孙子，比较该元素与儿子的大小关系，如果儿子大于自己，则交换维护大根堆结构。</li><li>如果有孙子，最大值是孙子，且如果孙子小于该元素，说明以该元素为根节点的树的最大值就是该元素自己，符合大根堆的结构，不需要进行调整；如果孙子大于该元素，则交换孙子与该元素，交换后判断该元素与父亲节点也就是原来的儿子节点的大小，如果父亲节点大于该元素，则父亲节点不满足小根堆结构，交换父亲节点与该元素，交换后就只有父亲节点元素也就是开始下滤操作时对应孙子节点位置的元素不正确，那么再对该元素进行下滤操作递归调用。<ol start="6"><li><strong>小层元素上滤操作，保证结构为以小层元素为根的小根堆</strong></li></ol></li></ul><p>void BubbleUpMin(min_max_heap<T>* h, int i)<br>小层元素的上滤操作，首先先找到下标为i的元素所对应的祖父结点（小根元素层对应的父亲结点所在的层为大根元素层）：</p><ul><li>如果祖父元素值比自己小，则满足小根堆的结构，不需要对此进行调整。</li><li>反之如果祖父元素的元素值比自己大，破坏了定义中的小根堆的结构，此时需要将自己与祖父结点进行交换，交换后需要对于当前结点所在的位置继续向上调整递归调用上滤函数。<ol start="7"><li><strong>大层元素上滤操作，保证结构为以大层元素为根的大根堆</strong></li></ol></li></ul><p>void BubbleUpMax(min_max_heap* h, int i)<br>    和小层元素的上滤操作有着异曲同工之意<br>    大层元素的上滤操作，首先先找到下标为i的元素所对应的祖父结点（大根元素层对应的父亲结点所在的层为小根元素层）：</p><ul><li>如果祖父元素值比自己大，则满足大根堆的结构，不需要对此进行调整。</li><li>反之如果祖父元素的元素值比自己小，破坏了定义中的大根堆的结构，此时需要将自己与祖父结点进行交换，交换后需要对于当前结点所在的位置继续向上调整递归调用上滤函数。<ol start="8"><li><strong>返回下标为i的数据属于大层还是小层</strong></li></ol></li></ul><p>int level(int i)<br>    根据小大根堆的定义即可直到通过对2取对数的方式，可以判断下标是属于大层还是小层，这里调用了floor向下取整。</p><ol start="9"><li><strong>下滤，用于删除后的调整工作</strong></li></ol><p>void TrickleDown(min_max_heap* h, int i)<br>    通过（4）（5）中对于大层和小层元素的下滤操作，主要应用在删除元素后的调整，首先对于下标为i的元素进行判断是属于小层元素还是大层元素，而后直接调用下滤函数，对当前堆进行调整，使之依然满足小大根堆的结构。</p><ol start="10"><li>上滤，用于插入后的调整工作</li></ol><p>void BubbleUp(min_max_heap* h, int i)<br>    对于下标为i的元素进行上滤操作，可用于插入元素后的调整工作，本处和（9）中的直接调用函数不相同，插入操作的时候，新增元素放置在最后的位置可能会破坏当前的结构，所以首先要进行预判断：<br>    首先先对下标为i的元素进行判断，是小层元素还是大层元素：</p><ul><li>如果是小层元素，则比较该元素与父亲结点：如果大层的父亲结点大，则对该元素进行小层上滤操作；如果父亲节点小，则该父亲节点不满足大根堆的结构，交换父亲结点与该元素，而后对于父亲结点进行大层上滤。</li><li>如果是大层元素，则比较该元素与父亲节点，如果父亲节点小，则直接对该元素进行大层上滤，如果父亲节点大，则父亲节点不满足小根堆结构，交换父亲节点与该元素后对父亲节点进行小层上滤。<ol start="11"><li><strong>返回最大值</strong></li></ol></li></ul><p>T&amp; min_max_heap::getmax()<br>    小大根交替堆中的最大值：</p><ul><li>如果对堆中只有一个元素，那么最大值为该元素</li><li>如果堆中有两个元素，由于第一层为小根堆，则最大值必然为第二个元素即儿子节点</li><li>如果有三个及以上的元素，第二层的大根堆结构保证了最大值必然出现在根节点所对应的两个孩子中，由此，比较第二个和第三个元素即两个儿子结点的元素值就可以得到最大值。<ol start="12"><li><strong>返回最小值</strong></li></ol></li></ul><p>T&amp; min_max_heap::getmin()<br>    返回最小值在小大交替堆中非常简单，只要堆不空，则根据性质，最小值一定为根节点元素。</p><ol start="13"><li><strong>删除最小值</strong></li></ol><p>T&amp; min_max_heap::popmin()</p><ul><li>堆中只有一个元素，则直接删除即可</li><li>堆中含有多个元素，删除第一个元素后，将最后一个元素放置在根节点的位置并开始调整当前根堆的结构，即从根节点开始对当前元素进行下滤操作。<ol start="14"><li><strong>删除最大值</strong></li></ol></li></ul><p>T&amp; min_max_heap::popmax()</p><ul><li>堆中只有一个元素，则直接删除即可</li><li>堆中有两个元素，返回二号元素并且将二号元素直接删除</li><li>堆中含有3个以及以上的元素，首先需要判断两个儿子节点中哪一个是最大元素，找到最大元素后，与删除最小元素同理，将最后一个元素填充到相应的位置后开始进行下滤操作来调整堆的结构。<ol start="15"><li><strong>插入元素</strong></li></ol></li></ul><p>void min_max_heap::insert(T&amp; Element)<br>    首先判断堆满则增加堆数组的长度，将插入元素放在堆的最后一个位置后进行元素上滤操作。</p><ol start="16"><li><strong>输出堆元素</strong></li></ol><p>void min_max_heap::output(ostream&amp; out)<br>    首先从第一层即0层开始计算树高和最底层的节点数(bottle_node_count_max);动态创建数组heapTreeMatrix[(high+1)_2][bottle_node_count_max_2];根据堆元素给数组进行赋值（空格和&#x2F;，\也相应的赋值给数组）最后输出。</p><h2 id="🎠学生成绩管理系统的实现"><a href="#🎠学生成绩管理系统的实现" class="headerlink" title="🎠学生成绩管理系统的实现"></a>🎠学生成绩管理系统的实现</h2><h3 id="🎨学生信息类的设计"><a href="#🎨学生信息类的设计" class="headerlink" title="🎨学生信息类的设计"></a>🎨学生信息类的设计</h3><img src="https://s1.ax1x.com/2023/05/11/p9sMFKJ.png#id=oMuqP&originHeight=1036&originWidth=1478&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><h3 id="🎨算法设计和思想"><a href="#🎨算法设计和思想" class="headerlink" title="🎨算法设计和思想"></a>🎨算法设计和思想</h3><p>学生成绩管理系统的实现主要包含学生信息的获取、修改以及类中运算符的重载<br><strong>信息获取：</strong>在学生成绩管理系统中对应输出学生的信息<br><strong>信息设置和修改：</strong>用于新增学生信息是的设置<br><strong>操作符重载：</strong> 由于student类是自己定义的，计算机不知道如何判断两个student类对象是否完全相同。这时候要使用操作符重载，让&#x3D;&#x3D;能够识别两个student类对象。</p><h2 id="🎠主函数"><a href="#🎠主函数" class="headerlink" title="🎠主函数"></a>🎠主函数</h2><img src="https://s1.ax1x.com/2023/05/11/p9sMZUx.png#id=htmZ1&originHeight=187&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:67%;" /><ol><li>读入学生信息：<br>将文件中的学生信息读入到学生类型的数组中，并按数学成绩，语文成绩，英语成绩，和总成绩放入不同的小大根交替堆中。</li><li>小大根交替堆实现的学生成绩管理系统：<br>学生管理系统的简单实现中，此处主要是实现了查询功能，对于最高最低成绩学生的查询，直接到对应查询方式的堆中调用getmax()和getmin()函数即可得到，对于具体成绩查询方式的查询，首先检查数据是否合法，之后遍历学生类数组，找到对应成绩的学生并输出。对于插入学生信息，直接调用insert将学生成绩对应写入不同的堆中，并将该学生信息写入文件。</li><li>输入，并根据输入选项进行相应的输出：<br>本函数主要验证小大根交替堆的功能，包含学生成绩管理系统的选项，实现两部分的连接。</li></ol><h1 id="🔮用户手册"><a href="#🔮用户手册" class="headerlink" title="🔮用户手册"></a>🔮用户手册</h1><p>程序运行时，首先出现“小大根交替堆实现双端优先队列”字样<br>进入主菜单界面<br>通过在下方输入相应指令的字母可以实现相关操作：<br>a.  建立小大根交替堆——请输入小大根交替堆的堆元素：<br>b.  插入元素——请输入插入的元素：<br>c.  删除最大值<br>d.  删除最小值<br>e.  输出最小值<br>f.  输出最大值<br>g.  依据学生成绩对学生信息的查询<br>程序会将学生的数学，语文，英语，总分成绩建立小大根交替堆不断调整的过程输出在当前屏幕上，并打印出“小大根交替堆实现的学生成绩管理系统”主菜单<br>根据菜单界面，用于可以通过输入相应的数字完成相应的操作：</p><ul><li>1-  输出所有学生的信息</li><li>2-  查询成绩最高的学生信息</li><li>3-  查询成绩最低的学生信息</li><li>4-  通过具体的成绩进行查询</li><li>5-  输出学生成绩的平均值</li><li>6-  添加学生信息</li><li>7-  退出</li></ul><p>h.  退出</p><h1 id="🔮调试及测试"><a href="#🔮调试及测试" class="headerlink" title="🔮调试及测试"></a>🔮调试及测试</h1><h2 id="🎠小大根交替堆实现下的双端优先队列"><a href="#🎠小大根交替堆实现下的双端优先队列" class="headerlink" title="🎠小大根交替堆实现下的双端优先队列"></a>🎠小大根交替堆实现下的双端优先队列</h2><p>菜单界面如下：<br><img src="https://s1.ax1x.com/2023/05/11/p9sQJOJ.png#id=a6oIC&originHeight=340&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 50%;" /><br>a-建立小大根交替堆<br><img src="https://s1.ax1x.com/2023/05/11/p9sQlWT.png#id=HTBeF&originHeight=574&originWidth=443&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>b-插入元素<br><img src="https://s1.ax1x.com/2023/05/11/p9sQ3SU.png#id=D2lmg&originHeight=574&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>c-删除最大值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQQYV.png#id=ygQ8T&originHeight=103&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>d-删除最小值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQMF0.png#id=JdJmU&originHeight=107&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>e-输出最小值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQGy4.png#id=uP4KQ&originHeight=103&originWidth=270&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>f-输出最大值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQ8lF.png#id=It7aS&originHeight=101&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>g-依据学生成绩对学生信息的查询<br><img src="https://s1.ax1x.com/2023/05/11/p9sQtm9.png#id=AMGJB&originHeight=744&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>小大根交替堆实现的学生成绩管理系统菜单如下：<br><img src="https://s1.ax1x.com/2023/05/11/p9sQNwR.png#id=MPvyx&originHeight=353&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>1-输出所有学生的信息</p><p>2-查询成绩最高的学生信息<br><img src="https://s1.ax1x.com/2023/05/11/p9sQUT1.png#id=OLQCM&originHeight=356&originWidth=886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>3-查询成绩最低的学生信息<br><img src="https://s1.ax1x.com/2023/05/11/p9sQdFx.png#id=J7fAM&originHeight=195&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>4-通过具体的成绩进行查询<br><img src="https://s2.loli.net/2023/05/11/4eZnTHDKtkbyLpY.png#id=O44vI&originHeight=402&originWidth=879&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>5-输出学生成绩的平均值<br><img src="https://s2.loli.net/2023/05/11/GLwIeixBdfv1sT3.png#id=C4aMl&originHeight=97&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>6-添加学生信息<br><img src="https://s2.loli.net/2023/05/11/kMVu1FQZ2PdUWR3.png#id=EXP0D&originHeight=248&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s2.loli.net/2023/05/11/35V6OJqkjXyWTUo.png#id=IDQsb&originHeight=717&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s2.loli.net/2023/05/11/xqEonrkKIMTyj7A.png#id=x9Cdy&originHeight=775&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>添加学生信息后的txt文件如下<br><img src="https://s2.loli.net/2023/05/11/Z6woNhO5US2PBXt.png#id=u7X1E&originHeight=281&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><h1 id="🔮进一步改进"><a href="#🔮进一步改进" class="headerlink" title="🔮进一步改进"></a>🔮进一步改进</h1><ol><li>由于本次实验进行的时间较短，仅仅实现了文本界面——后续改进可以设计一个GUI界面，能够同时实现显示当前文档中的学生信息，小大根交替堆的调整过程等信息。</li><li>该程序对于学生信息的管理系统所包含的内容较少——可以增加包括对学生的不同的成绩进行排序、将学生通过学号、出生地等的进行归类等操作。</li><li>该程序对于学生信息的添加后存入文件后，不能及时的读取进入该程序，需要等退出此次程序，下一次进行操作的时候才能读取今年加入的学生信息，此问题需要后续进行提升改进。</li><li>目前堆设定的长度最大值为50，后续若需要大批量的数据进行读入可以增加。</li></ol><h1 id="🔮心得体会"><a href="#🔮心得体会" class="headerlink" title="🔮心得体会"></a>🔮心得体会</h1><h2 id="🎠程序分析"><a href="#🎠程序分析" class="headerlink" title="🎠程序分析"></a>🎠程序分析</h2><p>本次实验主要进行的内容是数据结构中的小大根交替堆min-max-heap和该数据结构实现的双端优先队列在学生成绩管理系统上的应用，其难点在于对于堆结构的维护和调整。在对于堆的调整的过程中，上滤和下滤的操作是该数据结构中的核心点，小根堆和大根堆的区别在于：在上滤和上滤的过程中需要我们判断该元素是处于小层还是大层，由此来进行相应层的上滤和下滤，在上滤和下滤的过程中，由于大小根堆的的特性值，也会比普通大根堆或是小根堆的上滤和下滤要复杂一点。</p><h2 id="🎠程序性能分析"><a href="#🎠程序性能分析" class="headerlink" title="🎠程序性能分析"></a>🎠程序性能分析</h2><p>对于本实验，程序设计中包含了对异常的处理，对操作符的重载以及对类函数的封装等，在主函数中直接调用类函数对应头文件，由于本实验中小大根交替堆是以堆的形式展现在屏幕上，对于学生成绩的查询系统也没有可提供的大数据验证。程序主要是递归调用上滤下滤函数时的复杂度，复杂度为O(nlog2n)。</p><h2 id="🎠程序编写心得"><a href="#🎠程序编写心得" class="headerlink" title="🎠程序编写心得"></a>🎠程序编写心得</h2><h3 id="🎨语言的选择"><a href="#🎨语言的选择" class="headerlink" title="🎨语言的选择"></a>🎨语言的选择</h3><p>由于大一这一个学期的所有程序的编写基本都选择了使用C语言进行编写，在大一上半年对于C++的学习也几乎没有进行实践，导致对C++十分生疏甚至是不会的；在日常学习的过程中也发现了C++的重要性，因此本次实验采用C++进行编写。<br>在编写的过程中，对于C++中包括类，文件读取和写入等操作都非常生疏，也对于C++进行了一定的学习。其中印象比较深刻的是类中需要对于操作符进行重载，这样做的目的是为了防止用户修改用于基本类型数据的运算符性质。因此通过本次实验，不仅仅让我对于小大根交替堆这个数据结构有了一定的了解，同时也让我对C++的认识更近一步，对于自己来说也算是一举两得了。</p><h3 id="🎨小大根交替堆"><a href="#🎨小大根交替堆" class="headerlink" title="🎨小大根交替堆"></a>🎨<strong>小大根交替堆</strong></h3><p>堆有一个性质，在一个给定优先次序的情况下。堆顶元素的优先级最高。而且这个性质递归的适用于每一个子堆。所以，每次都可以用O(1)的时间得到优先级最高的一个元素。如果要删除，那么只需要O(log2(N))的时间去维护整个堆，使其仍然满足堆的性质。<br>但在课堂上所学习得小根堆和大根堆只能较为方便的查找到所有数字中的最小值或者最大值。而要同时得到最小值和最小值，除了堆，还可以通过平衡二叉树来实现，此时最左孩子和最右孩子就是所求最值。<br>通过本次实验对于小大根交替堆的理解，来实现查找最大值和最小值的功能，而不需要直到其他结果，只需要引入一个最大最小堆即可。<br>在一个系统或者在一个生活场景中，我们需要实时的知道当前的最大值最小值，这个时候，如果我们每次都得通过遍历得到最值，那么效率无疑是低下的。那么这个时候，小大根交替堆就能为此应用场景提供适配。</p><h1 id="🔮程序代码"><a href="#🔮程序代码" class="headerlink" title="🔮程序代码"></a>🔮程序代码</h1><p>代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%BA%94%E7%94%A8%E5%B0%8F%E5%A4%A7%E6%A0%B9%E4%BA%A4%E6%9B%BF%E5%A0%86%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">Cassie&#x2F;数据结构课程设计-应用小大根交替堆实现双端优先队列 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
          <category> 课程设计 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 课程设计 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计课程设计——推箱子</title>
      <link href="/2021/01/05/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%8E%A8%E7%AE%B1%E5%AD%90/"/>
      <url>/2021/01/05/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="⛳需求和规格说明"><a href="#⛳需求和规格说明" class="headerlink" title="⛳需求和规格说明"></a>⛳需求和规格说明</h1><p>“推箱子小游戏”要求编写一个推箱子游戏游戏，使用图形界面。<br>推箱子游戏的目：用最少的步数把所有的箱子推到目标位置。</p><h2 id="🎳游戏规则"><a href="#🎳游戏规则" class="headerlink" title="🎳游戏规则"></a>🎳游戏规则</h2><ol><li>游戏开始时，在游戏区域内随机的出现箱子、障碍物、小人以及箱子的目标位置。</li><li>箱子只可以被推动，不可以被拉动。</li><li>用户通过键盘的来控制小人上下左右的移动来推动箱子。记录用户移动小人的次数。</li><li>如果箱子被推到死角，则游戏结束。</li><li>所有箱子被推到目标位置，游戏胜利。</li></ol><h1 id="⛳设计"><a href="#⛳设计" class="headerlink" title="⛳设计"></a>⛳设计</h1><h2 id="🎳需求概要"><a href="#🎳需求概要" class="headerlink" title="🎳需求概要"></a>🎳需求概要</h2><ul><li><p>推箱子游戏的设计目标完成一个比较简单的游戏，使之能够实现推箱子游戏的基本功能，成为一个较为完整的游戏框架。游戏内容为，在一个较为狭小的仓库中，要求把木箱子推到游戏界面中的目标位置，稍不小心就会出现箱子无法移动或者通道被堵住的情况，所以需要玩家巧妙地利用有限的空间和通道，合理安排自己移动的次序和位置，使得顺利完成游戏的任务。</p></li><li><p>用户进入游戏界面后，会出现一个小人，若干个箱子和箱子的目标位置。玩家可以根据自己的想法自由地移动箱子，游戏提供跳关以及退步的功能模块，拼接这些模块，玩家可以实现对游戏的快速通关！</p></li><li><p>由于该程序需要使用图形界面，最终选择使用VS2019软件进行编程。</p></li></ul><h2 id="🎳设计思路"><a href="#🎳设计思路" class="headerlink" title="🎳设计思路"></a>🎳设计思路</h2><p>系统流程图如下所示：<br><img src="https://s1.ax1x.com/2023/05/09/p9BGUkq.jpg#height=363&id=OyCqa&originHeight=726&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=517" style="zoom:50%;" /></p><h2 id="🎳设计表示"><a href="#🎳设计表示" class="headerlink" title="🎳设计表示"></a>🎳设计表示</h2><p>头文件总览：</p><table><thead><tr><th align="center"><strong>include</strong></th><th align="center">#include&lt;stdio.h&gt;</th><th align="center">标准输入输出头文件</th></tr></thead><tbody><tr><td align="center"></td><td align="center">#include&lt;stdlib.h&gt;</td><td align="center">system函数的头文件</td></tr><tr><td align="center"></td><td align="center">#include&lt;windows.h&gt;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">#include&lt;conio.h&gt;</td><td align="center">图形库头文件</td></tr><tr><td align="center"></td><td align="center">#include&lt;graphics.h&gt;</td><td align="center">图形库头文件</td></tr><tr><td align="center">函数总览：</td><td align="center"></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center"><strong>函数</strong></th><th align="center">void DrawMap()</th><th align="center">绘制地图，加载图片</th></tr></thead><tbody><tr><td align="center"></td><td align="center">void PlayGame()</td><td align="center">推箱子游戏的主体</td></tr><tr><td align="center"></td><td align="center">int Win()</td><td align="center">判断该关卡是否通关</td></tr><tr><td align="center"></td><td align="center">void TargetCount()</td><td align="center">遍历地图，查看总共的目的地的个数</td></tr><tr><td align="center"></td><td align="center">void InitGame();</td><td align="center">游戏开始前需要做的准备工作</td></tr><tr><td align="center"></td><td align="center">void SaveStep()</td><td align="center">将玩家的每一步都保存起来</td></tr><tr><td align="center"></td><td align="center">void PreviousStep()</td><td align="center">记录上一步</td></tr></tbody></table><p>宏定义：</p><table><thead><tr><th align="center"><strong>宏定义</strong></th><th align="center">#define SIZE 45</th><th align="center">每张贴图的大小</th></tr></thead><tbody><tr><td align="center"></td><td align="center">#define WINDOWSWIDTH (COL*SIZE)</td><td align="center">窗口的宽</td></tr><tr><td align="center"></td><td align="center">#define WINDOWSHEIGHT (ROW*SIZE)</td><td align="center">窗口的高</td></tr><tr><td align="center"></td><td align="center">#define MAXLEVEL 10</td><td align="center">最大关卡数</td></tr></tbody></table><p>定义的变量：</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>成员名</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">int</td><td align="center">map[20][20]&#x3D;{};</td><td align="center">地图数组</td></tr><tr><td align="center"></td><td align="center">temp[5000][20][20] &#x3D; {}</td><td align="center">临时地图数组</td></tr><tr><td align="center"></td><td align="center">step &#x3D; -1</td><td align="center">计步</td></tr><tr><td align="center"></td><td align="center">ROW &#x3D; 0</td><td align="center">地图的行</td></tr><tr><td align="center"></td><td align="center">COL &#x3D; 0</td><td align="center">地图的列</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">玩家的横坐标</td></tr><tr><td align="center"></td><td align="center">C</td><td align="center">玩家的纵坐标</td></tr><tr><td align="center"></td><td align="center">targetCount &#x3D; 0</td><td align="center">地图中目的地的个数</td></tr><tr><td align="center"></td><td align="center">gameLevel &#x3D; 1</td><td align="center">游戏关卡</td></tr><tr><td align="center">char</td><td align="center">dir &#x3D; ‘s’</td><td align="center">人物当前的方向</td></tr><tr><td align="center"></td><td align="center">fileName[100]</td><td align="center">存放图片路径的字符串</td></tr><tr><td align="center">IMAGE</td><td align="center">bkImg</td><td align="center">没有墙，人物，箱子的空白图片</td></tr><tr><td align="center"></td><td align="center">boxImg</td><td align="center">箱子的图片</td></tr><tr><td align="center"></td><td align="center">dkboxImg</td><td align="center">箱子推到目的地时的图片</td></tr><tr><td align="center"></td><td align="center">targetImg</td><td align="center">目的地的图片</td></tr><tr><td align="center"></td><td align="center">blankImg</td><td align="center">没有墙，人物，箱子的空白图片</td></tr><tr><td align="center"></td><td align="center">wallImg</td><td align="center">墙面的图片</td></tr><tr><td align="center"></td><td align="center">playerImg[4]</td><td align="center">人物的四各方向的图片</td></tr></tbody></table><h1 id="⛳推箱子的功能框架"><a href="#⛳推箱子的功能框架" class="headerlink" title="⛳推箱子的功能框架"></a>⛳推箱子的功能框架</h1><p><img src="https://s1.ax1x.com/2023/05/09/p9BGt7n.jpg#id=tRh9z&originHeight=483&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎳初始化模块"><a href="#🎳初始化模块" class="headerlink" title="🎳初始化模块"></a>🎳初始化模块</h2><p>该模块包括屏幕初始化和游戏第一关到最后一关的初始化。屏幕的初始化用于输出操作信息，游戏每一关的初始化时构建每一关的关卡。</p><h2 id="🎳画图模块"><a href="#🎳画图模块" class="headerlink" title="🎳画图模块"></a>🎳画图模块</h2><p>用于画墙，画箱子，画人物，画目的地。</p><h2 id="🎳移动人物模块"><a href="#🎳移动人物模块" class="headerlink" title="🎳移动人物模块"></a>🎳移动人物模块</h2><p>该模块用于移动人物，包括人物与目的地之间，空地与人物之间，空地与箱子之间，箱子与目的地之间的移动变化。</p><h2 id="🎳功能控制模块"><a href="#🎳功能控制模块" class="headerlink" title="🎳功能控制模块"></a>🎳功能控制模块</h2><p>包括判断是否通关，悔步，关卡跳关，关卡重置操作。</p><h1 id="⛳推箱子具有的功能"><a href="#⛳推箱子具有的功能" class="headerlink" title="⛳推箱子具有的功能"></a>⛳推箱子具有的功能</h1><h2 id="🎳能够显示主菜单和游戏界面"><a href="#🎳能够显示主菜单和游戏界面" class="headerlink" title="🎳能够显示主菜单和游戏界面"></a>🎳能够显示主菜单和游戏界面</h2><img src="https://s1.ax1x.com/2023/05/09/p9BGJmj.png#height=325&id=sutgX&originHeight=650&originWidth=440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=220" style="zoom:50%;" />游戏界面上有一个菜单，可以让玩家进行必要的游戏设置。同时可以将地图中的数字信息转化成对应的图像信息显示在游戏界面上。代码展示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setfillcolor</span>(<span class="built_in">RGB</span>(<span class="number">235</span>, <span class="number">227</span>, <span class="number">206</span>));   <span class="comment">//填充当前颜色</span></span><br><span class="line"><span class="built_in">fillrectangle</span>(WINDOWSWIDTH, <span class="number">0</span>, WINDOWSWIDTH + <span class="number">220</span>, WINDOWSHEIGHT);   <span class="comment">//窗口大小</span></span><br><span class="line"><span class="built_in">settextcolor</span>(BLACK);</span><br><span class="line"><span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">0</span>, <span class="string">&quot;宋体&quot;</span>);</span><br><span class="line"><span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH + <span class="number">45</span>, <span class="number">45</span>, <span class="string">&quot;推箱子小游戏&quot;</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">70</span>, <span class="string">&quot;操作说明:&quot;</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">95</span>, <span class="string">&quot;WASD 或者↑↓←→&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;关卡           ：%d/%d&quot;</span>, gameLevel, MAXLEVEL);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">120</span>, str);</span><br><span class="line"><span class="type">char</span> stepStr[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现键盘操作的功能"><a href="#🎳能够实现键盘操作的功能" class="headerlink" title="🎳能够实现键盘操作的功能"></a>🎳能够实现键盘操作的功能</h2><p>可以从用户的键盘上获取信息，根据不同的方向键盘所对应的ASCII码数值，实现人物上下左右的移动。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dir = _getch();         <span class="comment">//从键盘上获取数据</span></span><br><span class="line"><span class="keyword">switch</span> (dir)</span><br></pre></td></tr></table></figure><p>通过#include&lt;conio.h&gt;调用getch函数，用来获取键值，再通过switch-case实现人物的移动</p><h3 id="🥌计算说明书部分"><a href="#🥌计算说明书部分" class="headerlink" title="🥌计算说明书部分"></a>🥌计算说明书部分</h3><p>假设空地为0，墙面为1，目的地为3，箱子为4，人物为5。这样子的目的是使得地图看起来更加规则，后面移动时的操作更加简洁明了。<br><img src="https://s1.ax1x.com/2023/05/09/p9BG8XQ.png#height=244&id=OKQgF&originHeight=486&originWidth=301&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=151"><br>上图为第一关的地图</p><ul><li>人物移动到空地上的数值变化就是0-&gt;5</li><li>箱子移动到空地上的数值变化就是0-&gt;4</li><li>人移动到目的地上时的数据变化就是3-&gt;8(3+5)</li><li>箱子移动到目的地上时的数据变化就是3-&gt;7(3+4)</li><li>根据每一次的移动，来改变原来位置和现在移动的位置所对应的数据变化，还原出地图所对应的数字模型。在编写程序的时候，分为四个方向——上下左右，依次分类讨论。由于四个方向的思路几乎相同，则可以重点编写一个方向所对应的数字改变，剩余的四个方向以此类推少做略微改变即可。</li><li>(下面以玩家进行向上移动时的数字改变为例子的代码显示)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">72</span>:               <span class="comment">//方向键上</span></span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">0</span>)  <span class="comment">// 1 人上面是空地（0）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)<span class="comment">// 1.1所站的地方以前是空地（5+0）</span></span><br><span class="line">&#123;<span class="comment">// 1.2所站的地方以前是目的地（3+5）</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">5</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">4</span>)  <span class="comment">// 2 人上面是箱子（4）</span></span><br><span class="line">&#123;<span class="comment">//2.1所站的地方以前是空地（5+0)</span></span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>) <span class="comment">//2.1.1箱子的上面是空地(0)</span></span><br><span class="line">&#123;        <span class="comment">//2.1.2箱子的上面是目的地(3)</span></span><br><span class="line">        <span class="comment">//2.2所站的地方以前是目的地(5+3)</span></span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">2</span>][C] == <span class="number">0</span> || map[R - <span class="number">2</span>][C] == <span class="number">3</span>)<span class="comment">//2.2.1箱子的上面是空地(0)</span></span><br><span class="line">&#123;        <span class="comment">//2.2.2箱子的上面是目的地(3)</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">2</span>][C] += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">3</span>)          <span class="comment">//3人上面是目的地(3)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)                 <span class="comment">//3.1人所站的地方是空地(5+0)</span></span><br><span class="line">&#123;                     <span class="comment">//3.2人所站的地方是目的地(5+3)</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">7</span>)            <span class="comment">//4人上面是在目的地的箱子也就是(3+4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)<span class="comment">//4.1人所站的地方以前是空地（0+5） </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">2</span>][C] == <span class="number">0</span> || map[R - <span class="number">2</span>][C] == <span class="number">3</span>)          <span class="comment">//4.1.1箱子的上面是空地（0)</span></span><br><span class="line">&#123;               <span class="comment">//4.1.2箱子的上面是目的地（3）</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;                                    <span class="comment">//4.2人所站的地方以前是目的地（3+5）       </span></span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">8</span>;                                 <span class="comment">//4.2.1箱子的上面是空地（0）</span></span><br><span class="line">map[R - <span class="number">2</span>][C] += <span class="number">4</span>;                                <span class="comment">//4.2.2箱子的上面是目的地（3）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SaveStep</span>();<span class="comment">//将每一步走之后的地图信息都保存起来</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现箱子到达目的地的时候的变色显示"><a href="#🎳能够实现箱子到达目的地的时候的变色显示" class="headerlink" title="🎳能够实现箱子到达目的地的时候的变色显示"></a>🎳能够实现箱子到达目的地的时候的变色显示</h2><p>当玩家把箱子推到指定的位置的时候，需要实现箱子的变色，这样可以明确的告诉玩家，您的箱子已经到达指定的目的地。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:     <span class="comment">//箱子被推到了目的地 4+3</span></span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;dkboxImg);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/05/09/p9BG36g.png#height=359&id=ys0YL&originHeight=717&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=362" style="zoom:50%;" /><h2 id="🎳能够实现人物的方向运动"><a href="#🎳能够实现人物的方向运动" class="headerlink" title="🎳能够实现人物的方向运动"></a>🎳能够实现人物的方向运动</h2><p>当玩家通过上下左右的按键操控游戏中的人物进行运动的时候，人物也会随着方向键的改变，改变其旋转的方向。可以使得游戏更加生动，增加可玩性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (dir)      <span class="comment">//从键盘中获取键值，以改变人物图片的方向</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>W<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">72</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>S<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">1</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">75</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">2</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">77</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">3</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>通过玩家的上下左右的操作中获取键值，再次通过switch-case函数通过不同的键值显示不同的人物方向。<br><img src="https://s1.ax1x.com/2023/05/09/p9BGY0s.png#id=B1r8V&originHeight=129&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://s1.ax1x.com/2023/05/09/p9BGrX4.png#id=h1YYX&originHeight=232&originWidth=1386&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎳能够实现人物的方向运动-1"><a href="#🎳能够实现人物的方向运动-1" class="headerlink" title="🎳能够实现人物的方向运动"></a>🎳能够实现人物的方向运动</h2><p>在游戏中，当玩家把所有的箱子都推到指定的目的地的时候，系统会进行判断。会跳出一个窗口，提示是否进入下一关游戏还是选择退出该游戏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TargetCount</span><span class="params">()</span>             <span class="comment">//遍历地图，查看总共的目的地的个数，用于判断是否将所有箱子移动到了目的地</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">targetCount = <span class="number">0</span>;<span class="comment">//每次调用函数都需要将targetCount初始化为零，不然就是在上一次的基础上++了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">3</span> || map[i][j] == <span class="number">7</span>)        </span><br><span class="line">targetCount++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Win</span><span class="params">()</span>          <span class="comment">//判断是否通关 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> boxToTargetCount = <span class="number">0</span>;       <span class="comment">//在目的地的箱子个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)           <span class="comment">//遍历整张地图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)       </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">7</span>)         <span class="comment">//所有的箱子到达目的地（3+4=7）</span></span><br><span class="line">&#123;</span><br><span class="line">boxToTargetCount++; </span><br><span class="line"><span class="keyword">if</span> (boxToTargetCount == targetCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (gameLevel == MAXLEVEL)        <span class="comment">//是否通过了全部的关卡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;恭喜你全部通关，太棒了！&quot;</span>, <span class="string">&quot;通关&quot;</span>, MB_OKCANCEL | MB_SYSTEMMODAL);       <span class="comment">//弹框函数</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过关，返回选择函数值 1 确定 2取消</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;你真棒，继续下一关吧！&quot;</span>, <span class="string">&quot;获胜&quot;</span>, MB_OKCANCEL | MB_SYSTEMMODAL));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个函数的共同作用，以判断该关卡是否成功。</p><ul><li>void TargetCount()遍历地图，查看总共的目的地的个数</li><li>int Win()判断该关卡是否通关</li></ul><p>再通过Win函数中弹框函数获取用户点击的选项所对应的数值判断是进去下一关还是退出游戏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> select = <span class="built_in">Win</span>();      <span class="comment">//是否继续下一关，1 确定 2  取消</span></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        gameLevel++;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/05/09/p9BGat0.png#height=156&id=m0YFt&originHeight=312&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=237" style="zoom:50%;" />点击确定则进去下一个关卡，点击取消则直接退出游戏。<h2 id="🎳能够实现跳过关卡的功能"><a href="#🎳能够实现跳过关卡的功能" class="headerlink" title="🎳能够实现跳过关卡的功能"></a>🎳能够实现跳过关卡的功能</h2><p>玩家可以通过对应的按键进行选择上一关或者下一关的选择，进行跳关选项。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:<span class="comment">//上一关</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gameLevel &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gameLevel--;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:<span class="comment">//下一关</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gameLevel &lt; MAXLEVEL)</span><br><span class="line">&#123;</span><br><span class="line">gameLevel++;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现悔步的操作"><a href="#🎳能够实现悔步的操作" class="headerlink" title="🎳能够实现悔步的操作"></a>🎳能够实现悔步的操作</h2><p>系统会记录每一步的运动，玩家可以通过按键的操控，实现悔步。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveStep</span><span class="params">()</span>                  <span class="comment">//将玩家的每一步都保存起来，以便于回退操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">step += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp[step][i][j] = map[i][j];        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">PreviousStep</span><span class="params">()</span><span class="comment">//上一步，以实现回退操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">step--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j] = temp[step][i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个函数的共同协助完成悔步的操作。</p><ul><li>void SaveStep()——将玩家的每一步都保存起来</li><li>void  PreviousStep()——记录上一步</li></ul><p>在人物移动的每一步时，都会通过SaveStep()函数，保存玩家的每一步。（通过ESC实现回退操作的代码显示）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">27</span>:<span class="comment">//ESC按键ASCII值   回退</span></span><br><span class="line"><span class="built_in">PreviousStep</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>(下图为通过按ESC实现悔步操作)<br><img src="https://s1.ax1x.com/2023/05/09/p9BG0pT.png#height=437&id=VR5TM&originHeight=874&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/09/p9BGDcF.png#height=437&id=kvJXb&originHeight=874&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627" style="zoom:50%;" /></p><h2 id="🎳能够实现记录步数的操作"><a href="#🎳能够实现记录步数的操作" class="headerlink" title="🎳能够实现记录步数的操作"></a>🎳能够实现记录步数的操作</h2><p>在功能菜单界面，会显示当前步数，随时记录玩家都在游戏过程中的总步数。每启用一次SaveStep()函数就会实现Step+1</p><ul><li>这里需要注意的是：</li></ul><p>判断是不是重新开始，因为运行程序开始和按了R开始两种情况是不一样的；如果是第一次开始，在主函数中执行DrawMap函数之后就会等待玩家按了按键之后，才再次执行DrawMap函数，这种情况step是从-1开始计步的，这时显示时就需要+1。而如果按了R重新开始，这时执行了InitGame函数，然后PlayGame函数执行完毕，就会继续执行DrawMap函数，这时step是为0的就不需要+1了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (step == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(stepStr, <span class="string">&quot;步数           ：%d&quot;</span>, step + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">145</span>, stepStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(stepStr, <span class="string">&quot;步数           ：%d&quot;</span>, step);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">145</span>, stepStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="⛳用户手册"><a href="#⛳用户手册" class="headerlink" title="⛳用户手册"></a>⛳用户手册</h1><p>本游戏一共有10关，从易到难，每一关都可以进行重新开始，回退，记录步数，返回上一关，进入下一关等操作。</p><h2 id="🎳操作说明"><a href="#🎳操作说明" class="headerlink" title="🎳操作说明"></a>🎳操作说明</h2><ul><li>可以通过按动键盘“WASD”或者“↑↓←→”对游戏中的小人物进行操控；</li><li>可以通过按动键盘“Esc”键来进行回退上一步，及允许用户悔步；</li><li>可以通过按动键盘“R”对该局游戏重新开始；</li><li>可以通过按动键盘“X”直接进入上一关；</li><li>可以通过按动键盘“N”直接进入下一关；</li><li>通过界面上的步数，可以直接看出本局用户行走的步数。</li></ul><h1 id="⛳调试及测试"><a href="#⛳调试及测试" class="headerlink" title="⛳调试及测试"></a>⛳调试及测试</h1><h2 id="🎳地图部分"><a href="#🎳地图部分" class="headerlink" title="🎳地图部分"></a>🎳地图部分</h2><p>刚开始只编辑了一张地图并且直接在程序中体现<br><img src="https://s1.ax1x.com/2023/05/09/p9BGdhV.png#id=H8qux&originHeight=411&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>后续为了实现选关和增加关卡的数量，选择使用TXT文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载地图</span></span><br><span class="line"><span class="type">char</span>  fileName[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;      <span class="comment">//定义</span></span><br><span class="line"><span class="built_in">sprintf</span>(fileName, <span class="string">&quot;./第%d关.txt&quot;</span>, gameLevel);      <span class="comment">//为了简化代码以及便于增加游戏关卡数，采用读取TXT文件的方法</span></span><br><span class="line"></span><br><span class="line">FILE* file;         </span><br><span class="line"><span class="keyword">if</span> ((file = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;ROW);       <span class="comment">//地图的行</span></span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;COL);       <span class="comment">//地图的列    （读取行列数以便控制窗口的大小和遍历）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">rewind</span>(file);     <span class="comment">//文件指针回绕到文件起始处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎳步数计算部分"><a href="#🎳步数计算部分" class="headerlink" title="🎳步数计算部分"></a>🎳步数计算部分</h2><p>关卡重置后会发现当前步数多1<br>需要判断是不是重新开始，因为运行程序开始和按了R开始两种情况是不一样的。如果是第一次开始，在主函数中执行DrawMap函数之后就会等待玩家按了按键之后，才再次执行DrawMap函数，这种情况step是从-1开始计步的，这时显示时就需要+1。而如果按了R重新开始，这时执行了InitGame函数，然后PlayGame函数执行完毕。就会继续执行DrawMap函数，这时step是为0的就不需要+1了。</p><h1 id="⛳运行示例"><a href="#⛳运行示例" class="headerlink" title="⛳运行示例"></a>⛳运行示例</h1><img src="https://s1.ax1x.com/2023/05/09/p9BGB1U.png#height=392&id=cHGpX&originHeight=784&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=492" style="zoom:50%;" /><img src="https://s1.ax1x.com/2023/05/09/p9BGynJ.png#height=392&id=nXW0X&originHeight=784&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=582" style="zoom:50%;" /><h1 id="⛳进一步改进"><a href="#⛳进一步改进" class="headerlink" title="⛳进一步改进"></a>⛳进一步改进</h1><ol><li>可以增加一个菜单界面，使用户更加清楚自己接下来的操作（如增加游戏规则说明，选择关卡等）；</li><li>可以增加背景音乐，使得该小游戏更加可玩，有趣；</li><li>可以改变背景颜色，增加人物颜色的可选择性等；</li><li>代码可以更加简单明了一些。</li></ol><h1 id="💡程序代码"><a href="#💡程序代码" class="headerlink" title="💡程序代码"></a>💡程序代码</h1><p>代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F">Cassie&#x2F;程序设计课程设计-推箱子小游戏 at main · xiayi0409&#x2F;Cassie · GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
          <category> 课程设计 </category>
          
          <category> 程序设计技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 课程设计 </tag>
            
            <tag> 程序设计技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
