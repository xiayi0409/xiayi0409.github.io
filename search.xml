<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理——CPU的结构与功能</title>
      <link href="/2023/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CPU%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CPU%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="🌎CPU的结构"><a href="#🌎CPU的结构" class="headerlink" title="🌎CPU的结构"></a>🌎CPU的结构</h1><h2 id="🌌CPU的功能"><a href="#🌌CPU的功能" class="headerlink" title="🌌CPU的功能"></a>🌌CPU的功能</h2><h3 id="🪐控制器的功能"><a href="#🪐控制器的功能" class="headerlink" title="🪐控制器的功能"></a>🪐控制器的功能</h3><p>取指令、分析指令、执行指令、控制程序输入及结果的输出、总线管理、处理异常情况和特殊情况</p><h3 id="🪐运算器的功能"><a href="#🪐运算器的功能" class="headerlink" title="🪐运算器的功能"></a>🪐运算器的功能</h3><p>实现算术运算和逻辑运算</p><h2 id="🌌CPU结构框图"><a href="#🌌CPU结构框图" class="headerlink" title="🌌CPU结构框图"></a>🌌CPU结构框图</h2><table><thead><tr><th><img src="https://i.imgtg.com/2023/07/21/OhqIzI.md.png#id=GXWaa&originHeight=500&originWidth=496&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th><th><img src="https://i.imgtg.com/2023/07/21/OhqC9F.png#id=ysksD&originHeight=473&originWidth=580&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th></tr></thead><tbody><tr><td>CPU与系统总线</td><td>CPU的内部结构</td></tr></tbody></table><h2 id="🌌CPU的寄存器"><a href="#🌌CPU的寄存器" class="headerlink" title="🌌CPU的寄存器"></a>🌌CPU的寄存器</h2><ol><li>用户可见寄存器<ol><li>通用寄存器——存放操作数</li><li>数据寄存器——存放操作数</li><li>地址寄存器——存放地址</li><li>条件码寄存器——存放条件码</li></ol></li><li>控制寄存器<ol><li>MAR：存储器地址寄存器——存放将访问的存储单元的地址</li><li>MDR：存储器数据寄存器——存放于存入存储器中的数据及最近从存储器中读出的数据</li><li>PC：程序计数器——存放先行指令的地址</li><li>IR：指令寄存器——存放当前预执行的指令</li></ol></li><li>状态寄存器<ol><li>PSW：程序状态字寄存器——存放条件码和其他状态信息</li><li>状态寄存器——存放条件码</li></ol></li></ol><h1 id="🌎指令周期"><a href="#🌎指令周期" class="headerlink" title="🌎指令周期"></a>🌎指令周期</h1><h2 id="🌌指令周期的基本概念"><a href="#🌌指令周期的基本概念" class="headerlink" title="🌌指令周期的基本概念"></a>🌌指令周期的基本概念</h2><h3 id="🪐指令周期"><a href="#🪐指令周期" class="headerlink" title="🪐指令周期"></a>🪐指令周期</h3><p>指令周期——取出并执行一条指令所需要的全部时间（取值周期+执行周期）<br><img src="https://i.imgtg.com/2023/07/21/Oh5OvP.png#height=127&id=zyKVG&originHeight=253&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=305"></p><ul><li>每条指令的指令周期不同</li><li>间接寻址的指令周期包括取值周期、间指周期和执行周期</li><li>带有中断周期的指令周期包括取值周期、间指周期、执行周期和中断周期</li></ul><p><img src="https://i.imgtg.com/2023/07/21/Oh55Ng.md.png#height=250&id=t3kg9&originHeight=500&originWidth=482&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=241"></p><ul><li>不同指令的执行周期数据流不同</li><li>中断周期完成的三个操作——保存程序断点、寻找到中断服务程序入口地址、关中断</li></ul><h1 id="🌎指令流水"><a href="#🌎指令流水" class="headerlink" title="🌎指令流水"></a>🌎指令流水</h1><h2 id="🌌提高机器速度"><a href="#🌌提高机器速度" class="headerlink" title="🌌提高机器速度"></a>🌌提高机器速度</h2><ol><li>提高访存速度<ol><li>高速芯片</li><li>Cache</li><li>多体并行</li></ol></li><li>提高I&#x2F;O和主机之间的传送速度<ol><li>中断</li><li>DMA</li><li>通道</li><li>I&#x2F;O处理机</li><li>多总线</li></ol></li><li>提高运算器速度<ol><li>高速芯片</li><li>改进算法</li><li>快速进位链</li></ol></li></ol><h2 id="🌌系统的并行性"><a href="#🌌系统的并行性" class="headerlink" title="🌌系统的并行性"></a>🌌系统的并行性</h2><h3 id="🪐并行的概念"><a href="#🪐并行的概念" class="headerlink" title="🪐并行的概念"></a>🪐并行的概念</h3><p>并行</p><ul><li>并发——两个或两个以上事件在同一时间段发生</li><li>同时——两个或两个以上事件在同一时刻发生</li></ul><h2 id="🌌指令流水原理"><a href="#🌌指令流水原理" class="headerlink" title="🌌指令流水原理"></a>🌌指令流水原理</h2><h3 id="🪐指令的串行执行"><a href="#🪐指令的串行执行" class="headerlink" title="🪐指令的串行执行"></a>🪐指令的串行执行</h3><p><img src="https://i.imgtg.com/2023/07/21/Oh5zUN.png#id=P6kkD&originHeight=108&originWidth=1215&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>取指令——取指令部件；执行指令——执行指令部件（总有一个部件空闲）</p><h3 id="🪐指令的二级流水"><a href="#🪐指令的二级流水" class="headerlink" title="🪐指令的二级流水"></a>🪐指令的二级流水</h3><p><img src="https://i.imgtg.com/2023/07/21/Oh5nai.png#height=115&id=KDAqe&originHeight=230&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=410"><br>指令预取<br>若取值和执行阶段时间上完全重合——指令周期减半，速度提高1倍</p><h2 id="🌌相关知识点"><a href="#🌌相关知识点" class="headerlink" title="🌌相关知识点"></a>🌌相关知识点</h2><h3 id="🪐流水线基本原理"><a href="#🪐流水线基本原理" class="headerlink" title="🪐流水线基本原理"></a>🪐流水线基本原理</h3><p>流水线技术是一种显著提高指令执行速度与效率的技术。<br>指令取值完成后，不等该指令执行完毕即可去下一条指令。如果把一条指令的结束过程进一步细分，例如分成<strong>取值、译码、访存、执行、写回</strong>五个过程，并用五个子部件分别处理这五个子过程，这样只需在上一条指令的第一子过程处理完毕进入第二子过程处理时，在第一子部件中就开始对第二子指令的第一子过程进行处理。随着时间推移，这种重叠操作最后可达到五个子部件同时对五条指令的子过程进行操作。<br><img src="https://i.imgtg.com/2023/07/21/Oh5gsq.md.png#id=nEQ93&originHeight=500&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🪐流水线的特点"><a href="#🪐流水线的特点" class="headerlink" title="🪐流水线的特点"></a>🪐流水线的特点</h3><ol><li>把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间</li><li>流水线每个功能部件后都有一个缓冲寄存器，称为<strong>锁存器</strong>，作用是保存本流水段的执行结果，以供下一流水段使用</li><li>流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流</li><li>只有连续不断地提供同一种任务时，才能发挥流水线的效率，所以流水线中处理的必须是连续任务。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的服务。</li><li>流水线需要由装入时间和排空时间。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。</li></ol><h3 id="🪐影响流水线性能的因素"><a href="#🪐影响流水线性能的因素" class="headerlink" title="🪐影响流水线性能的因素"></a>🪐影响流水线性能的因素</h3><ol><li><strong>结构相关</strong>——当多条指令同一时刻争用统一资源形成冲突<ol><li>暂停一个时钟周期</li><li>单独设置数据存储器和指令存储器</li></ol></li><li><strong>数据相关</strong>——指令在流水线中重叠执行时，当后继指令需要用到前面指令的执行结果<ol><li>暂停一个时钟周期</li><li>数据旁路：把前面一条指令的ALU计算结果直接输入到下一条指令</li></ol></li><li><strong>控制相关</strong>——当流水线遇到分支指令和其他改变PC值的指令时引起<ol><li>延迟转移技术：将转移指令与其前面的与转移指令无关的一条或几条指令对换位置，让成功转移总是在紧跟的指令被执行后发生，从而使预指的指令不作废</li><li>转移预测技术</li></ol></li></ol><h3 id="🪐流水线越多，并行性就越高。流水线越多，指令执行越快？"><a href="#🪐流水线越多，并行性就越高。流水线越多，指令执行越快？" class="headerlink" title="🪐流水线越多，并行性就越高。流水线越多，指令执行越快？"></a>🪐流水线越多，并行性就越高。流水线越多，指令执行越快？</h3><p>不是</p><ol><li>流水线缓冲之间的额外开销增大。每个流水段有一段额外开销用于缓冲间传送数据、进行各种准备和发送等功能。这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。</li><li>流水线间控制逻辑变多、变复杂。用于流水线优化和存储器冲突处理的控制逻辑随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。</li></ol><h3 id="🪐指令相关、数据相关"><a href="#🪐指令相关、数据相关" class="headerlink" title="🪐指令相关、数据相关"></a>🪐指令相关、数据相关</h3><ol><li>两条连续的指令读相同的寄存器时，会产生读后读相关（RAR），不影响流水线</li><li>某条指令要读取上一条指令所写入的寄存器时，会产生写后读（RAW）相关，即数据相关或真相关，影响流水线——按序流动的流水线只可能出现RAW相关</li><li>某条指令的上条指令要读&#x2F;写该指令的输出寄存器时，会产生读后写（WAR）和写后写（WAW）相关。在非按序流动的流水线中，既可能发生RAW也可能发生WAR和WAW。</li></ol><p>——对流水线影响最重的是<strong>数据相关</strong></p><h1 id="🌎中断系统"><a href="#🌎中断系统" class="headerlink" title="🌎中断系统"></a><strong>🌎中断系统</strong></h1><h2 id="🌌概述"><a href="#🌌概述" class="headerlink" title="🌌概述"></a><strong>🌌概述</strong></h2><h3 id="🪐引起中断的各种因素"><a href="#🪐引起中断的各种因素" class="headerlink" title="🪐引起中断的各种因素"></a><strong>🪐引起中断的各种因素</strong></h3><ol><li>人为设置的中断</li><li>程序性事故——溢出、操作码不能识别、除法非法</li><li>硬件故障</li><li>I&#x2F;O设备</li><li>外部事件——用键盘中断现行程序</li></ol><h3 id="🪐中断的分类"><a href="#🪐中断的分类" class="headerlink" title="🪐中断的分类"></a><strong>🪐中断的分类</strong></h3><ol><li>按中断源分<ol><li>内中断：发生在主机内部的中断</li><li>由主机外部事件引起的中断</li></ol></li><li>按中断服务程序入口地址的获取方式<ol><li>向量中断：外部设备在提出中断请求的同时，通过硬件自动形成中断服务程序入口地址。CPU响应中断后，将根据向量地址直接转入相应中断服务程序</li><li>非向量中断：非向量中断在产生中断的同时不能直接提供中断服务程序入口地址，而只产生一个中断查询程序的入口地址。需要通过中断查询程序确定中断源和中断服务程序的入口地址</li></ol></li><li>按中断源位置分<ol><li>硬件中断</li><li>软件中断</li></ol></li><li>按是否可屏蔽分<ol><li>可屏蔽中断</li><li>不可屏蔽中断</li></ol></li></ol><h2 id="🌌中断请求标记和中断判优逻辑"><a href="#🌌中断请求标记和中断判优逻辑" class="headerlink" title="🌌中断请求标记和中断判优逻辑"></a><strong>🌌中断请求标记和中断判优逻辑</strong></h2><h3 id="🪐中断请求标记INTR"><a href="#🪐中断请求标记INTR" class="headerlink" title="🪐中断请求标记INTR"></a><strong>🪐中断请求标记INTR</strong></h3><p>当INTR的状态为1时，表示中断源有请求</p><ul><li>INTR分散在各个中断源的接口电路中</li><li>INTR集中在CPU的中断系统内</li></ul><h3 id="🪐中断判优"><a href="#🪐中断判优" class="headerlink" title="🪐中断判优"></a><strong>🪐中断判优</strong></h3><ol><li>硬件实现（排队器）<ol><li>链式排队器——分散在各个中断源的接口电路中</li><li>集中在CPU内</li></ol></li><li>软件实现（程序查询）</li></ol><p><img src="https://i.imgtg.com/2023/07/21/Oh52gN.md.png#height=250&id=psrlN&originHeight=500&originWidth=764&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=382"></p><h3 id="🪐中断服务程序入口地址的查找"><a href="#🪐中断服务程序入口地址的查找" class="headerlink" title="🪐中断服务程序入口地址的查找"></a><strong>🪐中断服务程序入口地址的查找</strong></h3><ol><li>硬件向量法<ol><li>利用硬件产生向量地址，再由向量地址找到中断服务程序的入口地址——向量地址由中断向量地址形成部件产生</li></ol></li><li>软件查询法</li></ol><h3 id="🪐中断响应"><a href="#🪐中断响应" class="headerlink" title="🪐中断响应"></a><strong>🪐中断响应</strong></h3><ol><li>响应中断的条件——允许中断触发器EINT&#x3D;1</li><li>响应中断的时间——指令执行周期结束时刻由CPU发查询信号</li><li>中断隐指令<ol><li>保护程序断点——断点存于特定地址内</li><li>查找中断服务程序入口地址</li><li>硬件关中断</li></ol></li></ol><h3 id="🪐保护现场和恢复现场"><a href="#🪐保护现场和恢复现场" class="headerlink" title="🪐保护现场和恢复现场"></a><strong>🪐保护现场和恢复现场</strong></h3><ol><li>保护现场<ol><li>断点——中断隐指令完成</li><li>寄存器内容——中断服务程序完成</li></ol></li><li>恢复现场——中断服务程序完成</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——计算机网络体系结构</title>
      <link href="/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/17/Oz3BBx.png#id=IjrM8&originHeight=762&originWidth=1099&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="👒应用层概述"><a href="#👒应用层概述" class="headerlink" title="👒应用层概述"></a>👒应用层概述</h1><h2 id="🎎基本概念"><a href="#🎎基本概念" class="headerlink" title="🎎基本概念"></a>🎎基本概念</h2><h3 id="🎆应用层和应用层协议"><a href="#🎆应用层和应用层协议" class="headerlink" title="🎆应用层和应用层协议"></a>🎆应用层和应用层协议</h3><p>在TCP&#x2F;IP中，应用层对应OSI&#x2F;RM中的会话层、表示层和应用层，是应用程序与网络传输的接口，是面向应用需求的通信协议中的最高端。<br>应用层协议不是应用程序，也不解决用户的具体应用需求，而是为应用程序进程的网络通信提供服务的第一层协议，是为用户的应用需求提供通信服务。<br>应用层协议为具体应用程序的需求提供通用的、标准化的通信平台，以沟通传输层及其以下网络层次的网络通信协议。<br>应用层协议定义了运行在不同端系统上的应用程序进程相互传递报文的规范，这些规范包括：</p><ol><li>交换的报文类型，如请求报文和响应报文</li><li>语法，如报文中的各个字段及这些字段的描述规范</li><li>语义，即报文各字段的可能取值及其含义</li><li>进程何时、如何发送报文及对报文进行响应</li></ol><h3 id="🎆应用层协议的体系架构"><a href="#🎆应用层协议的体系架构" class="headerlink" title="🎆应用层协议的体系架构"></a>🎆应用层协议的体系架构</h3><ol><li>客户-服务器模式<ol><li>服务器：需要具备7*24小时提供服务的能力，拥有可永久访问地址&#x2F;域名，以及拥有良好的可扩展性</li><li>客户端：可以间歇性进入网络，客户端之间通常不直接连接</li></ol></li><li>P to P模式<ol><li>对等性：通信的各方地位平等，互为客户端也互为服务器</li><li>独立性：对中心服务器依赖最小。应用程序在间歇性连接的主机之间直接通信，互相提供对方需要的服务。</li></ol></li><li>混合模式<ol><li>服务器：负责全局性的服务，如搜索等</li><li>客户端：负责提供具体的服务</li></ol></li></ol><h3 id="🎆对传输层的要求"><a href="#🎆对传输层的要求" class="headerlink" title="🎆对传输层的要求"></a>🎆对传输层的要求</h3><ol><li>可靠数据传输<ol><li>能够确保数据交付</li></ol></li><li>吞吐量<ol><li>可用吞吐量是指发送进程能够向接收进程交付比特的速率</li></ol></li><li>定时<ol><li>能够确保发送方注入进套接字中的每个比特到达接收方的套接字不迟于某个预期的时间——交互式实时应用程序</li></ol></li><li>安全性<ol><li>可以提供一种或多种安全性服务</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/17/OzIzmB.md.png#height=250&id=ts5Ae&originHeight=500&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=398"></p><h3 id="🎆TCP-x2F-IP中的应用层协议"><a href="#🎆TCP-x2F-IP中的应用层协议" class="headerlink" title="🎆TCP&#x2F;IP中的应用层协议"></a>🎆TCP&#x2F;IP中的应用层协议</h3><ol><li>域名解析协议</li><li>超文本传输协议</li><li>电子邮件协议</li><li>会话发起协议</li><li>文件传输协议</li><li>远程访问协议</li></ol><h1 id="👒域名解析协议DNS"><a href="#👒域名解析协议DNS" class="headerlink" title="👒域名解析协议DNS"></a>👒域名解析协议DNS</h1><p>DNS用来解决主机名与IP地址的映射关系，使互联网用户无需记忆相对难于记忆的IP地址，只要记住更加接近于人类理解特性的域名即可。</p><h2 id="🎎域名系统概述"><a href="#🎎域名系统概述" class="headerlink" title="🎎域名系统概述"></a>🎎域名系统概述</h2><h3 id="🎆域名及域名结构"><a href="#🎆域名及域名结构" class="headerlink" title="🎆域名及域名结构"></a>🎆域名及域名结构</h3><p>通过采用层次结构的命名方法确保域名的唯一性，从而可以唯一的指明某个域名对对应的主机的IP地址。</p><ul><li><strong>绝对域名</strong><ul><li>以点“.”结尾的域名称为绝对域名或完全合格的域名，不以点结尾则是不完全域名<ul><li>如果不完全的域名是由两个或两个以上的标号组成，则认为是完全域名</li><li>如果在不完全的域名右部连接一个局部后缀，也认为是完全域名</li></ul></li></ul></li></ul><p>域名只是逻辑概念，不代表计算机所在的物理地点</p><ul><li><strong>顶级域名TLD</strong><ul><li>通用域名</li><li>国家域名</li><li>arpa域——用于反向域名解析，因此又称为反向域名</li><li>新增通用顶级域名</li></ul></li><li>域名服务器<ul><li>域名需要由遍及全世界的域名服务器去解析，域名服务器实际上就是装有域名系统的主机</li><li>可靠性——DNS域名服务器都把数据复制到几个域名服务器来保存，其中一个是主域名服务器，其他的事辅助域名服务器<ul><li>当主域名服务器出故障时，辅助域名服务器可以保证DNS的查询工作不会中断</li><li>主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性</li></ul></li></ul></li></ul><h2 id="🎎域名解析过程"><a href="#🎎域名解析过程" class="headerlink" title="🎎域名解析过程"></a>🎎域名解析过程</h2><h3 id="🎆解析步骤"><a href="#🎆解析步骤" class="headerlink" title="🎆解析步骤"></a>🎆解析步骤</h3><ol><li><strong>递归查询</strong><ol><li><strong>主机向本地域名服务器</strong>的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文。</li></ol></li><li><strong>迭代查询</strong><ol><li><strong>本地域名服务器向根域名服务器</strong>的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文，要么给出所要查询的IP的地址，要么告诉本地域名服务器下一步要向那个域名服务器查询，然后让本地域名服务器进行后续查询。</li></ol></li></ol><h3 id="🎆解析过程"><a href="#🎆解析过程" class="headerlink" title="🎆解析过程"></a>🎆解析过程</h3><ol><li>首先从主机本地Hosts文件查找，没找到就向本地DNS发出请求</li><li>若本地DNS也找不到，则将请求发给负责该域的根域名字服务器，根服务器会返回一个相应的顶级域名服务器地址</li><li>本地域名服务器会向顶级域名服务器提出请求。顶级域名服务器会返回一个权限域名服务器地址</li><li>本地域名服务器向权限域名服务器提出请求，权限域名服务器将返回目标域名的IP地址</li><li>本地域名服务器向查询主机返回目标域名的IP地址</li></ol><h2 id="🎎DNS的报文格式"><a href="#🎎DNS的报文格式" class="headerlink" title="🎎DNS的报文格式"></a>🎎DNS的报文格式</h2><p>DNS定义了用于查询和响应的报文格式<br><img src="https://i.imgtg.com/2023/07/17/OzI7CN.png#height=237&id=noi8g&originHeight=473&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=480"></p><h2 id="🎎UDP还是TCP"><a href="#🎎UDP还是TCP" class="headerlink" title="🎎UDP还是TCP"></a>🎎UDP还是TCP</h2><p>DNS使用的传输层承载协议既可以是UDP也可以是TCP，端口号均为53<br>大多数情况是UDP协议，除</p><ol><li>DNS响应报文过长</li><li>区域传送</li></ol><h1 id="👒电子邮件协议"><a href="#👒电子邮件协议" class="headerlink" title="👒电子邮件协议"></a>👒电子邮件协议</h1><h2 id="🎎概述"><a href="#🎎概述" class="headerlink" title="🎎概述"></a>🎎概述</h2><ul><li>发送邮件的协议：SMTP</li><li>读取邮件的协议：POP3和IMAP</li><li>MIME 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据</li></ul><h3 id="🎆电子邮件系统的主要组成"><a href="#🎆电子邮件系统的主要组成" class="headerlink" title="🎆电子邮件系统的主要组成"></a>🎆电子邮件系统的主要组成</h3><p><img src="https://i.imgtg.com/2023/07/17/OzIeiC.md.png#height=250&id=ZZIYa&originHeight=500&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=470"></p><ol><li><strong>用户代理UA</strong><ol><li>用户与电子邮件系统的接口，是电子邮件客户端软件</li><li>功能——撰写、显示、处理和通信</li></ol></li><li><strong>邮件服务器</strong><ol><li>发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）</li><li>邮件服务器按照客户服务器方式工作。使用发送和读取两个不同的协议</li></ol></li><li><strong>发送和接收电子邮件的步骤</strong><ol><li>发件人调用主机中的用户代理撰写和编辑要发送的邮件。</li><li>用户代理通过SMTP协议把邮件发给发送方邮件服务器，并暂存在发送邮件服务器的缓存队列中，等待发送。</li><li>发送方邮件服务器的SMTP客户与接收方邮件服务器的 SMTP服务器建立TCP连接，并发送暂存的邮件。  </li><li>接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 </li><li>收件人调用主机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。</li></ol></li><li><strong>电子邮件的组成</strong><ol><li>信封和内容两部分组成</li><li>电子邮件的传输程序根据邮件信封上的信息来传送邮件。用户在从自己的邮箱中读取邮件时才能见到邮件的内容</li></ol></li><li>电子邮件地址的格式<ol><li>收件人邮箱名@邮箱所在主机的域名 </li><li>域名在全世界必须唯一、用户名在该域名的范围内唯一</li></ol></li></ol><h2 id="🎎简答邮件传输协议SMTP"><a href="#🎎简答邮件传输协议SMTP" class="headerlink" title="🎎简答邮件传输协议SMTP"></a>🎎简答邮件传输协议SMTP</h2><p>STMP提供一种可靠且有效的电子邮件传输协议，STMP所规定的就是在两个相互通信的STMP进程之间应如何交换信息。<br>由于 SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。<br><img src="https://i.imgtg.com/2023/07/17/OzI4Dq.md.png#height=250&id=KJ1rZ&originHeight=500&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=417"><br>SMTP通信有以下三个阶段：</p><ol><li>连接建立</li><li>邮件传送</li><li>连接释放</li></ol><h2 id="🎎邮件读取协议"><a href="#🎎邮件读取协议" class="headerlink" title="🎎邮件读取协议"></a>🎎邮件读取协议</h2><h3 id="🎆POP3协议—邮局协议"><a href="#🎆POP3协议—邮局协议" class="headerlink" title="🎆POP3协议—邮局协议"></a>🎆POP3协议—邮局协议</h3><p>POP3协议主要用于支持使用客户端远程管理在服务器上的电子邮件。POP3规定怎样将主机连接到Internet的邮件服务器和下载电子邮件的电子协议。</p><ul><li>使用客户服务模式的工作方式</li></ul><p>POP3协议三种状态：</p><ol><li>认证状态</li><li>处理状态</li><li>更新状态</li></ol><p>当客户机与服务器建立连接时，客户机向服务器证明自己身份并由服务器成功确认，即客户端由认证状态转入处理状态，在完成列出未读邮件等相应的操作后客户端发出quit命令，退出处理状态进入更新状态，开始下载未阅读过的邮件到计算机本地之后最后重返认证状态。<br>若在更新状态再次发出quit命令，则断开连接。</p><h3 id="🎆IMAP协议"><a href="#🎆IMAP协议" class="headerlink" title="🎆IMAP协议"></a>🎆IMAP协议</h3><p>Internet邮件访问协议——用于接收邮件的协议</p><ul><li>用户既可以通过客户端在线或离线访问邮件服务器上的邮件，也能交互式的操作邮件服务器上的邮件，从而可以<strong>不需要将邮件下载到本地</strong>。</li><li>IMAP协议运行在TCP&#x2F;IP协议之上，使用TCP协议，端口号为143。通过SSL协议加密之后的默认端口是993。</li></ul><p>IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。<br>IMAP还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视频附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。<br>IMAP 的缺点是如果用户没有将邮件复制到自己的主机上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。<br><strong>特点：</strong></p><ol><li>IMAP4支持离线和在线两种模式来传输数据。</li><li>IMAP4采用分布式存储邮件方式</li><li>IMAP4是一种状态协议。IMAP4共有四种状态，分别是：<strong>未认证状态、认证状态、选中状态和离线状态</strong>。大部分的IMAP4命令都只会在状态下才有效。</li></ol><p><strong>功能：</strong></p><ol><li>支持在线和离线两种操作模式。只要客户端处于活跃状态，并且有需要下载的新邮件，则客户端就会一直与服务器保持连接，因此使用IMAP4模式可以获得更快的响应时间。   </li><li>支持多个客户端同时连接到一个邮箱。IMAP4协议允许多个用户同时访问邮箱，同时提供一种机制让客户能够感知其他当前连接到这个邮箱的用户所做的操作。</li><li>支持访问邮件中的MIME部分和部分获取。IMAP4 协议允许客户端获取任何独立的MIME部分和获取信息的一部分或者全部。使得用户无需下载附件就可以浏览消息内容或者在获取内容的同时浏览。</li><li>支持在服务器保留邮件状态信息。通过使用在IMAP4协议中定义的标志，客户端可以跟踪消息状态，例如是否被读取，回复，或者删除。</li><li>支持在服务器上访问多个邮箱。IMAP4客户端可以在服务器上创建，重命名，或删除邮箱（通常以文件夹形式显现给用户）。支持多个邮箱还允许服务器提供对于共享和公共文件夹的访问。</li><li>支持服务器端搜索。IMAP4提供了一种使客户可以要求服务器搜索符合多个标准的邮件的机制。</li></ol><h3 id="🎆注意点"><a href="#🎆注意点" class="headerlink" title="🎆注意点"></a>🎆注意点</h3><p>不要将邮件读取协议POP或IMAP与邮件传送协议SMTP弄混。<br>发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用** SMTP 协议**。<br>而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。 </p><h1 id="👒万维网www"><a href="#👒万维网www" class="headerlink" title="👒万维网www"></a>👒万维网www</h1><p>万维网是一个大规模的、联机式的信息储藏所。<br>万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</p><ul><li>万维网提供分布式服务</li></ul><p><img src="https://i.imgtg.com/2023/07/17/OzIVn6.md.png#id=gDrr1&originHeight=500&originWidth=901&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎎超媒体与超文本"><a href="#🎎超媒体与超文本" class="headerlink" title="🎎超媒体与超文本"></a>🎎超媒体与超文本</h2><p>万维网是分布式超媒体系统，是<strong>超文本系统</strong>的扩充。<br>一个超文本由多个信息源链接成，利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在因特网上的超文本系统中。超文本是万维网的基础。<br>超媒体与超文本的区别是文档内容不同。<strong>超文本文档仅包含文本信息</strong>，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</p><h2 id="🎎万维网工作方式"><a href="#🎎万维网工作方式" class="headerlink" title="🎎万维网工作方式"></a>🎎万维网工作方式</h2><ul><li>万维网以<strong>客户服务器方式</strong>工作。</li></ul><p>浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。<br>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。<br>在一个客户程序主窗口上显示出的万维网文档称为页面(page)。</p><h2 id="🎎万维网相关问题"><a href="#🎎万维网相关问题" class="headerlink" title="🎎万维网相关问题"></a>🎎万维网相关问题</h2><h3 id="🎆怎样标志分布在整个因特网上的万维网文档"><a href="#🎆怎样标志分布在整个因特网上的万维网文档" class="headerlink" title="🎆怎样标志分布在整个因特网上的万维网文档"></a>🎆怎样标志分布在整个因特网上的万维网文档</h3><p>使用<strong>统一资源定位符URL</strong>来标志万维网上的各种文档<br>使每个文档在整个因特网的范围内具有唯一的标识符URL</p><h3 id="🎆如何实现各种超链的链接"><a href="#🎆如何实现各种超链的链接" class="headerlink" title="🎆如何实现各种超链的链接"></a>🎆如何实现各种超链的链接</h3><p>使用<strong>超文本传送协议HTTP</strong>在客户程序与服务器程序之间进行交互</p><ul><li>可靠传送，使用TCP</li></ul><h3 id="🎆怎样使各种万维网文档能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链"><a href="#🎆怎样使各种万维网文档能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链" class="headerlink" title="🎆怎样使各种万维网文档能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链"></a>🎆怎样使各种万维网文档能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链</h3><p>超文本标记语言HTML使得万维网页的设计者可以很方便地用一个超链冲本页面的某处连接到因特网的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。</p><h2 id="🎎统一资源定位符URL"><a href="#🎎统一资源定位符URL" class="headerlink" title="🎎统一资源定位符URL"></a>🎎统一资源定位符URL</h2><p>URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。<br>URL是与因特网相连的机器上的任何可访问对象的一个指针。<br><img src="https://i.imgtg.com/2023/07/17/OzIYDP.png#height=230&id=CPTez&originHeight=460&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=583"></p><h2 id="🎎超文本传送协议HTTP"><a href="#🎎超文本传送协议HTTP" class="headerlink" title="🎎超文本传送协议HTTP"></a>🎎超文本传送协议HTTP</h2><p>从层次的角度看，HTTP 是<strong>面向事务的(transaction-oriented)应用层协议</strong>，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。 </p><h3 id="🎆工作过程"><a href="#🎆工作过程" class="headerlink" title="🎆工作过程"></a>🎆工作过程</h3><p><img src="https://i.imgtg.com/2023/07/17/OzIf8b.md.png#height=375&id=d82nW&originHeight=500&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=448"><br><strong>用户单击鼠标后发生的事件按顺序如下：</strong></p><ol><li>浏览器分析链接指向页面的URL</li><li>浏览器向DNS请求解析<a href="http://www.tsinghua.edu.cn的ip地址/">www.tsinghua.edu.cn的IP地址</a></li><li>域名系统DNS解析出清华大学服务器的IP地址</li><li>浏览器与服务器建立TCP链接</li><li>浏览器发出取文件命令：GET &#x2F;chn&#x2F;yxsz&#x2F;index.htm</li><li>服务器给出响应，把文件index.htm 发给浏览器</li><li>TCP连接释放</li><li>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本</li></ol><h3 id="🎆主要特点"><a href="#🎆主要特点" class="headerlink" title="🎆主要特点"></a>🎆主要特点</h3><ol><li>面向事务的客户服务器协议</li><li>HTTP本身是无连接的，但是使用了面向连接的TCP向上提供的服务</li></ol><h3 id="🎆持续连接"><a href="#🎆持续连接" class="headerlink" title="🎆持续连接"></a>🎆持续连接</h3><p>HTTP&#x2F;1.1 协议使用持续连接。<br>万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p><ol><li>非流水线方式</li><li>流水线方式</li></ol><h3 id="🎆代理服务器Proxy-Server"><a href="#🎆代理服务器Proxy-Server" class="headerlink" title="🎆代理服务器Proxy Server"></a>🎆代理服务器Proxy Server</h3><p>代理服务器(proxy server)又称为万维网高速缓存(Web cache)，它代表浏览器发出 HTTP 请求。<br>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。<br>当与暂时存放的<strong>请求相同的新请求</strong>到达时，万维网高速缓存就<strong>把暂存的响应发送出去</strong>，而不需要按 URL 的地址再去因特网访问该资源。  </p><ul><li>使用高速缓存可**减少访问因特网服务器的时延 **</li></ul><h3 id="🎆HTTP报文结构"><a href="#🎆HTTP报文结构" class="headerlink" title="🎆HTTP报文结构"></a><strong>🎆HTTP报文结构</strong></h3><ol><li>请求报文——从客户向服务器发送请求报文</li><li>响应报文——从服务器到客户的回答</li></ol><h3 id="🎆Cookie"><a href="#🎆Cookie" class="headerlink" title="🎆Cookie"></a><strong>🎆Cookie</strong></h3><p>万维网站点使用Cookie来跟踪用户。<br>Cookie 表示在<strong>HTTP服务器和客户之间传递的状态信息</strong>。<br>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。  </p><h2 id="🎎万维网的文档"><a href="#🎎万维网的文档" class="headerlink" title="🎎万维网的文档"></a>🎎万维网的文档</h2><h3 id="🎆超文本标记语言HTML"><a href="#🎆超文本标记语言HTML" class="headerlink" title="🎆超文本标记语言HTML"></a>🎆超文本标记语言HTML</h3><p>HTML定义了许多用于排版的命令（即标签）<br>HTML把各种标签嵌入到万维网的页面中，这样就构成了HTML文档中，HTML文档是一种可以用任何文本编辑器创建的ASCII码文件。</p><h3 id="🎆两种不同的链接"><a href="#🎆两种不同的链接" class="headerlink" title="🎆两种不同的链接"></a>🎆两种不同的链接</h3><ol><li>远程链接——超链的终点是其他网点上的页面</li><li>本地链接——超链指向本计算机中的某个文件</li></ol><h3 id="🎆动态万维网文档"><a href="#🎆动态万维网文档" class="headerlink" title="🎆动态万维网文档"></a>🎆动态万维网文档</h3><ol><li><strong>静态文档</strong>是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 </li><li><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。</li></ol><p>动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。  </p><h3 id="🎆万维网服务器功能的扩充"><a href="#🎆万维网服务器功能的扩充" class="headerlink" title="🎆万维网服务器功能的扩充"></a>🎆万维网服务器功能的扩充</h3><ol><li>应增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。</li><li>应增加一个机制，用来使万维网服务器把浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——操作系统接口</title>
      <link href="/2023/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%946%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%946%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<ul><li>操作系统——人-计算机接口</li><li>操作系统接口——用户与操作系统之间进行交互的接口</li></ul><p>操作系统接口分类</p><ol><li>命令接口<ol><li>联机用户接口——面向联机用户的操作接口</li><li>脱机用户接口——面向脱机（批处理）用户的接口</li></ol></li><li>图形用户接口</li><li>程序接口</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——指令系统</title>
      <link href="/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/18/OFzGAF.png#id=KczN2&originHeight=797&originWidth=1330&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🛕机器指令"><a href="#🛕机器指令" class="headerlink" title="🛕机器指令"></a>🛕机器指令</h1><h2 id="🕍指令格式"><a href="#🕍指令格式" class="headerlink" title="🕍指令格式"></a>🕍指令格式</h2><ul><li>指令——让计算机识别并执行某种操作的命令</li><li>指令系统——一台计算机中所有机器指令的集合</li><li>系列计算机——基本指令系统相同且基本体系，结构相同的一系列计算机</li></ul><h3 id="🕌指令格式"><a href="#🕌指令格式" class="headerlink" title="🕌指令格式"></a>🕌指令格式</h3><p>指令的一般格式：<br><strong>操作码字段 地址码字段</strong></p><ol><li><strong>操作码</strong><ol><li>指令应该执行什么性质的操作，具有何种功能，反应机器做什么操作</li><li>长度固定&#x2F;长度可变</li><li>操作码的位数随地址数的减少而增加</li></ol></li></ol><h2 id="🕍指令字长"><a href="#🕍指令字长" class="headerlink" title="🕍指令字长"></a>🕍指令字长</h2><p>指令字长取决于</p><ol><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数地址的个数</li></ol><ul><li>指令字长固定——指令字长&#x3D;存储字长&#x3D;机器字长</li><li>指令字长可变——按字节的倍数变化</li></ul><h1 id="🛕寻址方式"><a href="#🛕寻址方式" class="headerlink" title="🛕寻址方式"></a>🛕寻址方式</h1><ul><li>确定本条指令的操作数地址</li><li>下一条欲执行指令的指令地址</li></ul><h2 id="🕍指令寻址"><a href="#🕍指令寻址" class="headerlink" title="🕍指令寻址"></a>🕍指令寻址</h2><h3 id="🕌顺序寻址"><a href="#🕌顺序寻址" class="headerlink" title="🕌顺序寻址"></a>🕌顺序寻址</h3><p>通过程序计数器PC+1，自动形成下一条指令的地址</p><h3 id="🕌跳转寻址"><a href="#🕌跳转寻址" class="headerlink" title="🕌跳转寻址"></a>🕌跳转寻址</h3><p>通过转移类指令实现，如JMP</p><h2 id="🕍数据寻址"><a href="#🕍数据寻址" class="headerlink" title="🕍数据寻址"></a>🕍数据寻址</h2><p><img src="https://i.imgtg.com/2023/07/18/OFxRya.png#height=154&id=Wa7PS&originHeight=307&originWidth=700&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=350"></p><h3 id="🕌立即寻址"><a href="#🕌立即寻址" class="headerlink" title="🕌立即寻址"></a>🕌立即寻址</h3><p>形式地址A就是操作数<br><img src="https://i.imgtg.com/2023/07/18/OFxtdS.png#height=93&id=LC5vb&originHeight=186&originWidth=399&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=200"></p><ul><li>立即数可正可负</li><li>指令执行阶段不访存，A的位数限制了立即数的范围</li></ul><h3 id="🕌直接寻址"><a href="#🕌直接寻址" class="headerlink" title="🕌直接寻址"></a>🕌直接寻址</h3><p>EA&#x3D;A 有效地址由形式地址直接给出<br><img src="https://i.imgtg.com/2023/07/18/OFxDaN.png#height=132&id=GdJks&originHeight=264&originWidth=858&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=429"></p><ul><li>执行阶段访问一次存储器</li><li>A的位数决定了该指令操作数的寻址范围</li><li>操作数的地址不易修改</li></ul><h3 id="🕌隐含寻址"><a href="#🕌隐含寻址" class="headerlink" title="🕌隐含寻址"></a>🕌隐含寻址</h3><p>操作数地址隐含在操作码中<br><img src="https://i.imgtg.com/2023/07/18/OFxLEL.png#id=zlEcY&originHeight=395&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🕌间接寻址"><a href="#🕌间接寻址" class="headerlink" title="🕌间接寻址"></a>🕌间接寻址</h3><p>有效地址由形式地址间接提供 EA&#x3D;（A）<br><img src="https://i.imgtg.com/2023/07/18/OFxEIi.png#height=250&id=ko4X4&originHeight=499&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=587"></p><ul><li>执行指令阶段2次访存</li><li>可扩大寻址范围</li><li>便于编制程序</li></ul><h3 id="🕌寄存器（直接）寻址"><a href="#🕌寄存器（直接）寻址" class="headerlink" title="🕌寄存器（直接）寻址"></a>🕌寄存器（直接）寻址</h3><p>EA&#x3D;Ri 有效地址即为寄存器编号<br><img src="https://i.imgtg.com/2023/07/18/OFxQFX.md.png#height=250&id=Pn8tU&originHeight=500&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=300"></p><ul><li>执行阶段不访存，只访问寄存器，执行速度快</li><li>寄存器个数有限，可缩短指令字长</li></ul><h3 id="🕌寄存器间接寻址"><a href="#🕌寄存器间接寻址" class="headerlink" title="🕌寄存器间接寻址"></a>🕌寄存器间接寻址</h3><p>EA&#x3D;（Ri） 有效地址在寄存器中<br><img src="https://i.imgtg.com/2023/07/18/OFxSRt.md.png#height=250&id=HNTVY&originHeight=500&originWidth=708&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=354"></p><ul><li>有效地址在寄存器中，操作数在存储器中，执行阶段访存</li><li>比一般间接寻址速度快</li></ul><h3 id="🕌基址寻址"><a href="#🕌基址寻址" class="headerlink" title="🕌基址寻址"></a>🕌基址寻址</h3><ol><li><strong>采用专用寄存器作基址寄存器</strong></li></ol><p>EA&#x3D;（BR）+A BR为基址寄存器<br><img src="https://i.imgtg.com/2023/07/18/OFxsyp.png#height=202&id=U8X8A&originHeight=404&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=332"></p><ul><li>可扩大寻址范围</li><li>有利于多道&#x2F;浮动程序，但偏移量偏小 </li><li>BR内容由操作系统或管理程序确定</li><li>在程序的执行过程中BR内容不变，形式地址A可变</li></ul><ol start="2"><li><strong>采用通用寄存器作基址寻址</strong></li></ol><p><img src="https://i.imgtg.com/2023/07/18/OFxVsU.png#height=232&id=jfmOR&originHeight=463&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=478"></p><ul><li>由用户指定哪个通用寄存器作为基址寄存器</li><li>基址寄存器的内容由操作系统确定</li><li>在程序的执行过程中R0内容不变，形式地址A可变</li></ul><h3 id="🕌变址寻址"><a href="#🕌变址寻址" class="headerlink" title="🕌变址寻址"></a>🕌变址寻址</h3><p>EA &#x3D; （IX）+A IX为变址寄存器（专用） 通用寄存器也可以作为变址寄存器<br><img src="https://i.imgtg.com/2023/07/18/OFxfaY.png#height=198&id=ip45L&originHeight=395&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=340"></p><ul><li>可扩大寻址范围</li><li>便于处理循环&#x2F;数组问题 </li><li>IX的内容由用户给定</li><li>在程序的执行过程中IX内容可变，形式地址A不变</li></ul><h3 id="🕌相对寻址"><a href="#🕌相对寻址" class="headerlink" title="🕌相对寻址"></a>🕌相对寻址</h3><p>EA&#x3D;（PC）+A   A是相对于当前指令的位移量（可正可负，补码）<br><img src="https://i.imgtg.com/2023/07/18/OFxlev.png#height=233&id=b6o0w&originHeight=465&originWidth=1071&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=536"></p><ul><li>A的位数决定操作数的寻址范围</li><li>广泛用于转移指令</li></ul><h3 id="🕌堆栈寻址"><a href="#🕌堆栈寻址" class="headerlink" title="🕌堆栈寻址"></a>🕌堆栈寻址</h3><p>先进后出 栈顶地址由SP指出<br><img src="https://i.imgtg.com/2023/07/18/OFx6hr.png#height=183&id=gyw7i&originHeight=365&originWidth=998&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=499"></p><h1 id="🛕RISC和CISC技术"><a href="#🛕RISC和CISC技术" class="headerlink" title="🛕RISC和CISC技术"></a>🛕RISC和CISC技术</h1><p>RISC——精简指令系统计算机<br>CISC——复杂指令系统计算机</p><h2 id="🕍RISC主要特征"><a href="#🕍RISC主要特征" class="headerlink" title="🕍RISC主要特征"></a>🕍RISC主要特征</h2><p>选用使用频率较高的一些简单指令，复杂指令的功能由简单指令来组合</p><ul><li>指令长度固定、指令格式种类少、寻址方式少</li><li>只有LOAD&#x2F;STORE指令访存，其余指令的操作都在寄存器之间进行</li><li>CPU中有多个通用寄存器</li><li>采用流水技术，大部分指令在一个时钟周期内完成</li><li>采用组合逻辑实现控制器</li><li>采用优化的编译程序</li></ul><h2 id="🕍CISC主要特征"><a href="#🕍CISC主要特征" class="headerlink" title="🕍CISC主要特征"></a>🕍CISC主要特征</h2><ul><li>系统指令复杂庞大，各种指令使用频度相差大</li><li>指令长度不固定、指令格式种类多、寻址方式多</li><li>访存指令不受限制</li><li>CPU中设有专用寄存器</li><li>大多数指令需要多个时钟周期执行完毕</li><li>采用微程序控制器</li><li>难以用优化编译生成高效的目的代码</li></ul><h2 id="🕍CISC和RISC比较"><a href="#🕍CISC和RISC比较" class="headerlink" title="🕍CISC和RISC比较"></a>🕍CISC和RISC比较</h2><p><img src="https://i.imgtg.com/2023/07/18/OFzEqD.md.png#id=lQjHP&originHeight=500&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🕌顺序寻址-1"><a href="#🕌顺序寻址-1" class="headerlink" title="🕌顺序寻址"></a>🕌顺序寻址</h3>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——计算机的运算方法</title>
      <link href="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/18/OFxbOv.png#id=kKCmQ&originHeight=846&originWidth=1545&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🌳数制"><a href="#🌳数制" class="headerlink" title="🌳数制"></a>🌳数制</h1><ul><li>编码——按指定的方法，将信息从一种形式（格式），转换成另一种形式（格式）<ul><li>编码是计算机交流的语言</li></ul></li><li>BCD码——用4位二进制代码的不同组合来表示一个二进制数码的编码方法</li></ul><h2 id="🌷数据的基本宽度"><a href="#🌷数据的基本宽度" class="headerlink" title="🌷数据的基本宽度"></a>🌷数据的基本宽度</h2><ul><li>比特bit——计算机中处理、存储、传输信息的最小单位</li><li>字节Byte——二进制信息的计量单位——字节是最小可寻址单位</li></ul><h3 id="🌿字VS字长"><a href="#🌿字VS字长" class="headerlink" title="🌿字VS字长"></a>🌿字VS字长</h3><ul><li>字长指数据通路的宽度——CPU内部总线的宽度、运算器的位数、通用寄存器的宽度等等</li><li>字表示被处理信息的单位，用来度量数据类型的宽度</li></ul><h1 id="🌳有符号数和无符号数"><a href="#🌳有符号数和无符号数" class="headerlink" title="🌳有符号数和无符号数"></a>🌳有符号数和无符号数</h1><h2 id="🌷无符号数"><a href="#🌷无符号数" class="headerlink" title="🌷无符号数"></a>🌷无符号数</h2><p>计算机中的数均放在寄存器中，通常称为寄存器的位数为机器字长<br>无符号数——没有符号的数，在寄存器中的每一位均可用来存放数值</p><h2 id="🌷有符号数"><a href="#🌷有符号数" class="headerlink" title="🌷有符号数"></a>🌷有符号数</h2><p>对于有符号数来说，符号的正负机器无法识别，因此将真值（带符号的数）进行数字化——&gt;机器数</p><h3 id="🌿原码、补码、反码"><a href="#🌿原码、补码、反码" class="headerlink" title="🌿原码、补码、反码"></a>🌿原码、补码、反码</h3><p>最高位为符号位</p><ul><li>对于正数——原码&#x3D;补码&#x3D;反码</li><li>对于负数——符号位为1，其数值部分<ul><li>原码除符号位外，每位取反加1——补码</li><li>原码除符号位外，每位取反——反码</li></ul></li></ul><h1 id="🌳数的定点表示和浮点表示"><a href="#🌳数的定点表示和浮点表示" class="headerlink" title="🌳数的定点表示和浮点表示"></a>🌳数的定点表示和浮点表示</h1><h2 id="🌷定点表示"><a href="#🌷定点表示" class="headerlink" title="🌷定点表示"></a>🌷定点表示</h2><p><img src="https://i.imgtg.com/2023/07/18/OFkucN.png#height=119&id=vHaHu&originHeight=238&originWidth=982&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=491"></p><h2 id="🌷浮点表示"><a href="#🌷浮点表示" class="headerlink" title="🌷浮点表示"></a>🌷浮点表示</h2><p><img src="https://i.imgtg.com/2023/07/18/OFk3MC.png#height=65&id=ToOME&originHeight=258&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=209"><br>S尾数——小数，可正可负<br>j整数——整数，可正可负</p><h3 id="🌿浮点数表示形式"><a href="#🌿浮点数表示形式" class="headerlink" title="🌿浮点数表示形式"></a>🌿浮点数表示形式</h3><p><img src="https://i.imgtg.com/2023/07/18/OFkC7L.md.png#height=250&id=Y5DCm&originHeight=500&originWidth=689&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=345"></p><h1 id="🌳一些问题"><a href="#🌳一些问题" class="headerlink" title="🌳一些问题"></a>🌳一些问题</h1><h2 id="🌷C语言中的浮点数类型及类型转换"><a href="#🌷C语言中的浮点数类型及类型转换" class="headerlink" title="🌷C语言中的浮点数类型及类型转换"></a>🌷C语言中的浮点数类型及类型转换</h2><p>C语言中的float 和double 类型分别对应于IEEE 754 单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数，但long double 的长度和格式随编译器和处理器类型的不同而有所不同。在C程序中等式的赋值和判断中会出现强制类型转换，以char-&gt;int-&gt;long-&gt;double 和float-&gt;double最为常见，从前到后范围和精度都从小到大，转换过程没有损失。</p><ol><li>从int转换为float时，虽然不会发生溢出，但int可以保留32 位， float保留24 位，可能有数据舍入，若从int转换为double 则不会出现。</li><li>从int或float转换为double时，因为double的有效位数更多，因此能保留精确值。</li><li>从double转换为float时，因为float表示范围更小，因此可能发生溢出。此外，由于有效位数变少，因此可能被舍入。</li><li>从float或double转换为int时，因为int没有小数部分，所以数据可能会向0方向被截断（仅保留整数部分），影响精度。另外，由于int 的表示范围更小，因此可能发生溢出。</li></ol><h2 id="🌷计算机中为什么采用二进制表示数据"><a href="#🌷计算机中为什么采用二进制表示数据" class="headerlink" title="🌷计算机中为什么采用二进制表示数据"></a>🌷计算机中为什么采用二进制表示数据</h2><ul><li>从<strong>可行性</strong>来说，采用二进制，只有0和1两个状态，能够表示0、1两种状态的电子器件很多，如开关的接通和断开、晶体管的导通和截止、磁元件的正负剩磁、电位电平的高与低等，都可表示0、1两个数码。使用二进制，电子器件具有实现的可行性。</li><li>从<strong>运算的简易性</strong>来说，二进制数的运算法则少，运算简单，使计算机运算器的硬件结构大大简化。</li><li>从<strong>逻辑</strong>上来说，由于二进制0和1正好和逻辑代数的假(false) 和真(true) 相对应，有逻辑代数的理论基础，用二进制表示二值逻辑很自然。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——输入输出系统</title>
      <link href="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/18/OFbWWp.png#id=SqSOU&originHeight=1134&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="⚽概述"><a href="#⚽概述" class="headerlink" title="⚽概述"></a>⚽概述</h1><h2 id="🏈输入输出系统的组成"><a href="#🏈输入输出系统的组成" class="headerlink" title="🏈输入输出系统的组成"></a>🏈输入输出系统的组成</h2><h3 id="🎳I-x2F-O软件"><a href="#🎳I-x2F-O软件" class="headerlink" title="🎳I&#x2F;O软件"></a>🎳I&#x2F;O软件</h3><p>主要任务：</p><ol><li>将用户编制的程序（或数据）输入主机内</li><li>将运算结果输送给用户</li><li>实现输入输出系统与主机工作的协调等</li></ol><ul><li>I&#x2F;O指令——CPU指令的一部分<ul><li>操作码 命令码 设备码</li></ul></li><li>通道指令——通道自身的指令<ul><li>指出数据组的首地址、传送字数或末地址、操作命令</li></ul></li></ul><h3 id="🎳I-x2F-O硬件"><a href="#🎳I-x2F-O硬件" class="headerlink" title="🎳I&#x2F;O硬件"></a>🎳I&#x2F;O硬件</h3><h2 id="🏈I-x2F-O与主机的联系方式"><a href="#🏈I-x2F-O与主机的联系方式" class="headerlink" title="🏈I&#x2F;O与主机的联系方式"></a>🏈I&#x2F;O与主机的联系方式</h2><h3 id="🎳I-x2F-O编制方式"><a href="#🎳I-x2F-O编制方式" class="headerlink" title="🎳I&#x2F;O编制方式"></a>🎳I&#x2F;O编制方式</h3><ol><li>统一编址：指把I&#x2F;O地址（I&#x2F;O端口地址）当作存储器的单元进行分配<ol><li>在这种方式下CPU不需设置专门的I&#x2F;O指令，用统一的访问存储器的取数、存数指令就可以访问I&#x2F;O端口</li><li>优点：使CPU访问I&#x2F;O操作更灵活、更方便，此外还可使端口有更大的编制空间</li><li>缺点：端口占用了存储器地址，内存容量变小；利用存储器编制的I&#x2F;O设备进行数据输入输出操作执行速度变慢</li></ol></li><li>不统一编址（单独编址方式）：指I&#x2F;O端口地址与存储器地址无关，另行单独编址<ol><li>在这种方式下，CPU需要设置专门的I&#x2F;O指令访问端口</li><li>优点：输入输出指令与存储器指令有明显区别，程序编址清晰、便于理解</li><li>缺点：输入输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器的读&#x2F;写、I&#x2F;O设备的读&#x2F;写两组控制信号，增加控制的复杂性</li></ol></li></ol><h3 id="🎳设备寻址"><a href="#🎳设备寻址" class="headerlink" title="🎳设备寻址"></a>🎳设备寻址</h3><p>每台设备有一个设备号，I&#x2F;O指令设备码字段指出设备号，用设备选择电路识别设备是否被选中</p><h3 id="🎳传送方式"><a href="#🎳传送方式" class="headerlink" title="🎳传送方式"></a>🎳传送方式</h3><ol><li>串行</li><li>并行</li></ol><h3 id="🎳联络方式"><a href="#🎳联络方式" class="headerlink" title="🎳联络方式"></a>🎳联络方式</h3><ol><li>立即响应（速度缓慢的I&#x2F;O）</li><li>异步工作采用应答信号（I&#x2F;O设备与主机工作速度不匹配）</li><li>同步工作采用同步时标联络</li></ol><h2 id="🏈I-x2F-O与主机传送的控制方式"><a href="#🏈I-x2F-O与主机传送的控制方式" class="headerlink" title="🏈I&#x2F;O与主机传送的控制方式"></a>🏈I&#x2F;O与主机传送的控制方式</h2><p><img src="https://i.imgtg.com/2023/07/18/OFTs2I.md.png#id=QbHsw&originHeight=500&originWidth=705&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🎳程序查询方式"><a href="#🎳程序查询方式" class="headerlink" title="🎳程序查询方式"></a>🎳程序查询方式</h3><p>由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息</p><ul><li>CPU与I&#x2F;O设备处于串行工作方式，CPU必须等待I&#x2F;O设备完成操作后才能继续执行其它程序——传输速度很慢，CPU的利用率较低</li></ul><p><img src="https://i.imgtg.com/2023/07/18/OFTJix.md.png#height=250&id=Ja6WD&originHeight=500&originWidth=801&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=401"><br>特点：</p><ol><li>CPU能控制何时对何设备进行输入输出操作</li><li>外设和CPU处于异步工作状态</li><li>数据输入输出要经过CPU</li><li>用于连接低速外设</li><li>灵活性好</li></ol><h3 id="🎳程序中断方式"><a href="#🎳程序中断方式" class="headerlink" title="🎳程序中断方式"></a>🎳程序中断方式</h3><ul><li><strong>中断</strong>：CPU在执行程序的过程中，当出现异常情况或特殊请求处理时，CPU暂停当前正在执行的程序，转而去执行更为紧急的中断服务程序，并能在中断服务程序处理结束后，自动返回被暂停的程序继续执行。</li><li><strong>中断系统</strong>：用于实现中断的软件和硬件组成的系统</li></ul><p><img src="https://i.imgtg.com/2023/07/18/OFTSCM.md.png#height=250&id=DUIaH&originHeight=500&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=371"><br>特点：</p><ol><li>CPU与外围设备可以并行工作</li><li>能够处理异常事务</li><li>数据的输入输出要经过CPU</li><li>一般用来连接低速设备</li></ol><h3 id="🎳DMA方式（直接存储器存取）"><a href="#🎳DMA方式（直接存储器存取）" class="headerlink" title="🎳DMA方式（直接存储器存取）"></a>🎳DMA方式（直接存储器存取）</h3><p>直接依靠硬件在主存与设备之间进行数据传送，在数据传送期间不需要CPU程序干预的与I&#x2F;O设备交换数据的工作方式<br>DMA控制器从CPU手中暂时接管对总线的控制，数据交换不必经过CPU，直接通过数据总线在内存和I&#x2F;O设备之间直接进行</p><ul><li>若出现DMA和CPU同时访问主存，CPU总是将总线占有权让给DMA，通常把DMA的这种占有称为窃取或挪用——周期挪用、周期窃取</li></ul><p><strong>CPU和I&#x2F;O并行工作</strong><br><img src="https://i.imgtg.com/2023/07/18/OFTd41.png#height=169&id=P1YBG&originHeight=338&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=517"></p><h1 id="⚽I-x2F-O接口"><a href="#⚽I-x2F-O接口" class="headerlink" title="⚽I&#x2F;O接口"></a>⚽I&#x2F;O接口</h1><h2 id="🏈概述"><a href="#🏈概述" class="headerlink" title="🏈概述"></a>🏈概述</h2><ul><li><strong>为什么要设置接口</strong></li></ul><ol><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反应设备的状态（忙、就绪、中断请求）</li></ol><ul><li><strong>接口和端口</strong></li></ul><ol><li>接口——指一种为在主机和外设之间传送信息而设置的硬件线路，也可以指两个软件之间的共同逻辑边界</li><li>端口——接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息</li><li>若干个端口加上相应的控制逻辑才能组成接口。CPU通过输入指令，从端口读入信息，通过输出指令，将信息写入到端口</li></ol><h2 id="🏈接口的功能和组成"><a href="#🏈接口的功能和组成" class="headerlink" title="🏈接口的功能和组成"></a>🏈接口的功能和组成</h2><h3 id="🎳总线连接方式的I-x2F-O接口电路"><a href="#🎳总线连接方式的I-x2F-O接口电路" class="headerlink" title="🎳总线连接方式的I&#x2F;O接口电路"></a>🎳总线连接方式的I&#x2F;O接口电路</h3><p><img src="https://i.imgtg.com/2023/07/18/OFTYbD.md.png#height=250&id=cGuPo&originHeight=500&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=459"></p><h3 id="🎳功能"><a href="#🎳功能" class="headerlink" title="🎳功能"></a>🎳功能</h3><ol><li>选址功能<ol><li>选择设备并传送地址。当设备选择线上的设备码与本设备码相符，发出设备选中信号SEL，通过接口内的设备选择电路实现</li></ol></li><li>传送主机命令<ol><li>CPU向I&#x2F;O发出的命令</li></ol></li><li>数据的缓冲功能<ol><li>CPU与外设的速度往往不匹配，为消除速度差异，接口必须提供数据缓冲功能。通过数据缓冲寄存器DBR实现</li></ol></li><li>反应设备的工作状态</li><li>输入输出功能</li><li>数据转换功能</li></ol><h2 id="🏈接口类型"><a href="#🏈接口类型" class="headerlink" title="🏈接口类型"></a>🏈接口类型</h2><ol><li>按数据传送方式分类<ol><li>并行接口</li><li>串行接口</li></ol></li><li>按功能选择的灵活性分类<ol><li>可编程接口</li><li>不可编程接口</li></ol></li><li>按通用性分类<ol><li>专用接口</li><li>通用接口</li></ol></li><li>按数据传送的控制方式分类<ol><li>中断接口</li><li>DMA接口</li></ol></li></ol><h1 id="⚽程序查询方式"><a href="#⚽程序查询方式" class="headerlink" title="⚽程序查询方式"></a>⚽程序查询方式</h1><p><img src="https://i.imgtg.com/2023/07/18/OFT36K.md.png#height=375&id=U3x2Y&originHeight=500&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=625"></p><h1 id="⚽程序中断方式"><a href="#⚽程序中断方式" class="headerlink" title="⚽程序中断方式"></a>⚽程序中断方式</h1><h2 id="🏈中断的概念"><a href="#🏈中断的概念" class="headerlink" title="🏈中断的概念"></a>🏈中断的概念</h2><ul><li><strong>中断</strong>：CPU在执行程序的过程中，当出现异常情况或特殊请求处理时，CPU暂停当前正在执行的程序，转而去执行更为紧急的中断服务程序，并能在中断服务程序处理结束后，自动返回被暂停的程序继续执行。</li><li><strong>中断系统</strong>：用于实现中断的软件和硬件组成的系统</li></ul><p>一般适用于随机出现的服务，且一旦提出要求应立即实现。这种方式节省了CPU的时间，但硬件结构对复杂一些。<br><img src="https://i.imgtg.com/2023/07/18/OFTwka.md.png#height=250&id=seWw6&originHeight=500&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=328"></p><h2 id="🏈中断的作用"><a href="#🏈中断的作用" class="headerlink" title="🏈中断的作用"></a>🏈中断的作用</h2><ul><li>实现CPU与I&#x2F;O设备并行工作</li><li>硬件故障<ul><li>计算机运行时，如果硬件出现某些故障机器中断系统发出中断请求，CPU响应中断后进行处理</li></ul></li><li>实现人机联系：<ul><li>在计算机工作过程中，如果用户要干预机器，如抽查计算中间结果、了解机器工作状态、给机器下达临时命令，一般通过中断系统完成</li></ul></li><li>实现多道程序和分时操作<ul><li>在一道程序运行中，由I&#x2F;O中断系统切换到另一道程序运行。也可以通过给每道程序分配一个固定时间片，利用时钟定时发起中断请求进行程序切换</li></ul></li><li>实现实时处理<ul><li>某个事件或现象出现时及时的进行处理，而不是集中起来再进行批处理</li></ul></li><li>实现应用程序和操作系统的联系<ul><li>可以在用户程序中安排一条Trap指令进入操作系统，软中断</li></ul></li><li>多处理机系统各处理机之间的信息交流和任务切换</li></ul><h2 id="🏈中断的分配"><a href="#🏈中断的分配" class="headerlink" title="🏈中断的分配"></a>🏈中断的分配</h2><h3 id="🎳按中断来源分"><a href="#🎳按中断来源分" class="headerlink" title="🎳按中断来源分"></a>🎳按中断来源分</h3><ol><li>内中断——发生在主机内部的中断</li><li>外中断——由主机外部事件引起的中断</li></ol><h3 id="🎳按中断服务程序入口地址的获取分"><a href="#🎳按中断服务程序入口地址的获取分" class="headerlink" title="🎳按中断服务程序入口地址的获取分"></a>🎳按中断服务程序入口地址的获取分</h3><ol><li>向量中断<ol><li>外部设备在提出中断请求的同时，通过硬件自动形成<strong>中断服务程序</strong>入口地址。CPU响应中断后，将根据向量地址直接转入响应中断服务程序。</li></ol></li><li>非向量中断<ol><li>产生中断的同时不能直接提供中断服务程序的入口地址，而只产生一个<strong>中断查询程序</strong>的入口地址。需要通过中断查询程序确定中断源和中断服务程序的入口地址。</li></ol></li></ol><h2 id="🏈I-x2F-O中断处理过程"><a href="#🏈I-x2F-O中断处理过程" class="headerlink" title="🏈I&#x2F;O中断处理过程"></a>🏈I&#x2F;O中断处理过程</h2><h3 id="🎳CPU响应中断具备条件"><a href="#🎳CPU响应中断具备条件" class="headerlink" title="🎳CPU响应中断具备条件"></a>🎳CPU响应中断具备条件</h3><ol><li>在CPU内部设置的中断屏蔽器必须是开放的</li><li>外设有中断请求时，中断请求触发器必须处于1状态，保持中断请求信号</li><li>外设（接口）中断允许触发器必须是1，这样才能把外设中断请求送至CPU</li></ol><p>具备三个条件后，CPU在现行指令结束后的最后一个状态周期响应中断</p><h2 id="🏈中断服务程序流程"><a href="#🏈中断服务程序流程" class="headerlink" title="🏈中断服务程序流程"></a>🏈中断服务程序流程</h2><h3 id="🎳中断服务程序的流程"><a href="#🎳中断服务程序的流程" class="headerlink" title="🎳中断服务程序的流程"></a>🎳中断服务程序的流程</h3><ol><li>保护现场<ol><li>程序断点的保护</li><li>寄存器内容的保护</li></ol></li><li>中断服务<ol><li>对不同的I&#x2F;O设备具有不同内容的设备服务</li></ol></li><li>恢复现场</li><li>中断返回</li></ol><h3 id="🎳单重中断和多重中断"><a href="#🎳单重中断和多重中断" class="headerlink" title="🎳单重中断和多重中断"></a>🎳单重中断和多重中断</h3><ol><li>单重中断——不允许中断现行的中断服务程序</li><li>多重中断（中断嵌套）——允许级别更高的中断源，中断现行的中断服务程序</li></ol><h1 id="⚽DMA方式"><a href="#⚽DMA方式" class="headerlink" title="⚽DMA方式"></a>⚽DMA方式</h1><h2 id="🏈DMA方式的特点"><a href="#🏈DMA方式的特点" class="headerlink" title="🏈DMA方式的特点"></a>🏈DMA方式的特点</h2><p>主机与I&#x2F;O并行工作，主存和I&#x2F;O之间有一条直接数据通路，CPU启动I&#x2F;O后，不必查询I&#x2F;O是否准备好，当I&#x2F;O准备就绪后，发出DMA请求，此时CPU不直接参与I&#x2F;O和主存间的信息交换，只是把外部总线的使用权暂时交付DMA，仍然可以完成自身内部的操作，所以<strong>不必中断现行程序</strong>，只需暂停一个或几个存取周期访存，<strong>CPU效率更高</strong>。</p><h3 id="🎳DMA和程序中断方式"><a href="#🎳DMA和程序中断方式" class="headerlink" title="🎳DMA和程序中断方式"></a>🎳DMA和程序中断方式</h3><p><img src="https://i.imgtg.com/2023/07/18/OFWAOL.png#height=243&id=r04e1&originHeight=486&originWidth=954&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=477"></p><h3 id="🎳DMA与主存交换数据的三种方式"><a href="#🎳DMA与主存交换数据的三种方式" class="headerlink" title="🎳DMA与主存交换数据的三种方式"></a>🎳DMA与主存交换数据的三种方式</h3><ol><li>停止CPU访问主存<ol><li>外设要求传送一批数据，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线及有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，把总线控制权交给CPU。</li><li>优点：控制简单</li><li>缺点：CPU处于不工作状态或保持状态&#x2F;未充分发挥CPU对主存的利用率</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/18/OFWp9p.png#height=156&id=ivr4i&originHeight=312&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=538"></p><ol start="2"><li>周期挪用（周期窃取）<ol><li>每当I&#x2F;O设备发出DMA请求时，I&#x2F;O设备便挪用或窃取总线占用权一个或几个存取（主存）周期，DMA不请求时，CPU继续访问主存。</li><li>DMA访问主存有三种可能<ol><li>CPU此时不访存</li><li>CPU正在访存，等存取周期结束CPU才能让出总线</li><li>DMA与CPU同时请求访存——CPU将总线控制权让给DMA</li></ol></li><li>适用于I&#x2F;O设备读&#x2F;写周期大于存取（主存）周期的情况</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/18/OFWLEr.png#id=zfzwr&originHeight=329&originWidth=1087&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol start="3"><li>DMA与CPU交替访问<ol><li>适用于CPU工作周期大于存取（主存）周期的情况</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/18/OFWEIM.md.png#height=250&id=TFDhb&originHeight=500&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=529"></p><h2 id="🏈DMA的工作过程"><a href="#🏈DMA的工作过程" class="headerlink" title="🏈DMA的工作过程"></a>🏈DMA的工作过程</h2><h3 id="🎳DMA传送过程"><a href="#🎳DMA传送过程" class="headerlink" title="🎳DMA传送过程"></a>🎳DMA传送过程</h3><p>预处理、数据传送、后处理</p><ol><li>预处理<ol><li>通过几条输入输出指令预置信息—通知DMA控制逻辑传送方向、设备地址、主存地址、传送字数</li></ol></li><li>数据传输<ol><li>占用总线传输数据，数据传送完全由DMA控制</li></ol></li><li>后处理<ol><li>校验送入主存的数是否正确</li><li>是否继续使用DMA</li><li>测试传送过程是否正确，错则转诊断程序</li><li>由中断服务程序完成</li></ol></li></ol><h1 id="⚽一些问题"><a href="#⚽一些问题" class="headerlink" title="⚽一些问题"></a>⚽一些问题</h1><h2 id="🏈DMA的工作过程中断响应优先级和中断处理优先级"><a href="#🏈DMA的工作过程中断响应优先级和中断处理优先级" class="headerlink" title="🏈DMA的工作过程中断响应优先级和中断处理优先级"></a>🏈DMA的工作过程中断响应优先级和中断处理优先级</h2><ol><li><strong>中断响应优先级</strong>是由硬件排队路线或中断查询程序的查询顺序决定的</li><li><strong>中断处理优先级</strong>可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低，若是，终止正在处理的中断</li></ol><h2 id="🏈向量中断、中断向量和向量地址"><a href="#🏈向量中断、中断向量和向量地址" class="headerlink" title="🏈向量中断、中断向量和向量地址"></a>🏈向量中断、中断向量和向量地址</h2><ol><li><strong>中断向量</strong>：每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表</li><li><strong>向量地址</strong>：中断向量表中的每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号</li><li><strong>向量中断</strong>：一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，获得向量地址</li></ol><h2 id="🏈调用中断服务程序和调用子程序"><a href="#🏈调用中断服务程序和调用子程序" class="headerlink" title="🏈调用中断服务程序和调用子程序"></a>🏈调用中断服务程序和调用子程序</h2><p>调用中断服务程序和调用子程序的区别是:</p><ol><li>中断服务程序与中断时CPU正在运行的程序是相互独立的，它们之间没有确定的关系。子程序调用时转入的子程序与CPU正在执行的程序段是同一程序的两部分。</li><li>除了软中断，通常中断产生都是随机的，而子程序调用是由CALL指令(子程序调用指令)引起的。</li><li>中断服务程序的人口地址可以通过硬件向量法产生向量地址，再由向量地址找到入口地址。子程序调用的子程序入口地址是由CAL 指令中的地址码给出的。</li><li>调用中断服务程序和子程序都需保护程序断点，前者由中断隐指令完成，后者由CALL指令本身完成。</li><li>处理中断服务程序时，对多个同时发生的中断需进行裁决，而调用子程序时一般没有这种操作。</li><li>在中断服务程序和所调用的子程序中都有保护寄存器内容的操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——文件管理</title>
      <link href="/2023/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/17/Ozu83v.md.png#id=Bis91&originHeight=500&originWidth=584&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍓文件和文件系统"><a href="#🍓文件和文件系统" class="headerlink" title="🍓文件和文件系统"></a>🍓文件和文件系统</h1><h2 id="🍑文件的数据组成"><a href="#🍑文件的数据组成" class="headerlink" title="🍑文件的数据组成"></a>🍑文件的数据组成</h2><h3 id="🍐文件"><a href="#🍐文件" class="headerlink" title="🍐文件"></a>🍐文件</h3><ul><li>定义</li></ul><p>文件是指由创建者所定义的、具有文件名的若干相关有元素的集合。</p><ul><li>分类</li></ul><p>有结构文件：由若干记录构成的文件<br>无结构（流式）文件：由字节&#x2F;字符组成的文件</p><ul><li>文件属性</li></ul><p>文件类型、长度、物理位置、建立时间…</p><h3 id="🍐记录"><a href="#🍐记录" class="headerlink" title="🍐记录"></a>🍐记录</h3><ul><li>定义</li></ul><p>记录是一组相关数据项的集合，用于描述一个对象在某方面的属性。</p><ul><li>关键字</li></ul><p>记录的唯一标志，由单个或组合数据项形成。</p><ul><li>分类</li></ul><p>定长记录：记录长度固定<br>变长记录：记录长度不定</p><h3 id="🍐数据项"><a href="#🍐数据项" class="headerlink" title="🍐数据项"></a>🍐数据项</h3><ul><li>定义</li></ul><p>数据项是有结构文件的基本单位，是数据组织中可以命名的最小逻辑单位，也称字段。<br>每个数据项包括：名称、数据类型、数据宽度</p><ul><li>分类</li></ul><p>基本数据项：单个数据项<br>组合数据项：若干各数据项集</p><h2 id="🍑文件类型"><a href="#🍑文件类型" class="headerlink" title="🍑文件类型"></a>🍑文件类型</h2><table><thead><tr><th>分类方法</th><th>分类结果</th></tr></thead><tbody><tr><td>按用途分类</td><td>系统文件、用户文件、库文件</td></tr><tr><td>按文件中数据形式分类</td><td>源文件、目标文件、可执行文件</td></tr><tr><td>按存取控制属性</td><td>只执行文件、只读文件、读写文件</td></tr></tbody></table><h2 id="🍑文件系统"><a href="#🍑文件系统" class="headerlink" title="🍑文件系统"></a>🍑文件系统</h2><p>定义——文件系统是操作系统中负责管理和存取文件信息的软件结构，它是由管理文件所需的数据结构和相应的管理软件以及访问文件的一组操作组成。</p><h3 id="🍐文件系统模型（三层结构）"><a href="#🍐文件系统模型（三层结构）" class="headerlink" title="🍐文件系统模型（三层结构）"></a>🍐文件系统模型（三层结构）</h3><table><thead><tr><th>文件系统接口</th></tr></thead><tbody><tr><td>对对象操纵和管理的软件集合</td></tr><tr><td>对象及其属性</td></tr></tbody></table><h2 id="🍑文件系统操作"><a href="#🍑文件系统操作" class="headerlink" title="🍑文件系统操作"></a>🍑文件系统操作</h2><h3 id="🍐文件操作三部曲"><a href="#🍐文件操作三部曲" class="headerlink" title="🍐文件操作三部曲"></a>🍐文件操作三部曲</h3><ol><li><strong>打开文件</strong><ol><li>核心工作是，在内存设置对文件操作的相关数据结构，并将文件基本信息复制到内存</li></ol></li><li><strong>读写等文件操作</strong></li><li><strong>关闭文件</strong><ol><li>核心工作是，删除在内存设置的文件数据结构，并将必要的文件修改信息刷新到磁盘</li></ol></li></ol><h1 id="🍓文件的逻辑结构"><a href="#🍓文件的逻辑结构" class="headerlink" title="🍓文件的逻辑结构"></a>🍓文件的逻辑结构</h1><h2 id="🍑基本概念"><a href="#🍑基本概念" class="headerlink" title="🍑基本概念"></a>🍑基本概念</h2><h3 id="🍐逻辑文件"><a href="#🍐逻辑文件" class="headerlink" title="🍐逻辑文件"></a>🍐逻辑文件</h3><p>从用户观点出发看到的文件。其结构为文件的逻辑结构，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称文件组织。</p><h3 id="🍐物理文件"><a href="#🍐物理文件" class="headerlink" title="🍐物理文件"></a>🍐物理文件</h3><p>从系统角度出发看到的文件。其结构为文件的存储结构&#x2F;物理结构，是指文件在外存上的存储组织形式，与存储介质的存储性能、外存分配形式密切相关。</p><h3 id="🍐文件目录"><a href="#🍐文件目录" class="headerlink" title="🍐文件目录"></a>🍐文件目录</h3><p>——逻辑文件到物理文件的映射</p><h2 id="🍑顺序文件"><a href="#🍑顺序文件" class="headerlink" title="🍑顺序文件"></a>🍑顺序文件</h2><p>顺序文件中的记录，按照一定的顺序存储和组织，如时间顺序、关键字顺序等。通常按顺序方式进行文件的读写。——基于读写指针<br>设置读、写指针：指向下一条要读、写记录的起始字节位置。读、写指针在读、写文件的过程中自动变化（由系统负责更新，对程序员透明）。</p><h3 id="🍐特点"><a href="#🍐特点" class="headerlink" title="🍐特点"></a>🍐特点</h3><ol><li>批量顺序存取，效率非常高</li><li>查找或修改单条记录困难（记录变长）</li><li>插入删除记录困难（记录变长，或需保序）</li></ol><h2 id="🍑索引文件"><a href="#🍑索引文件" class="headerlink" title="🍑索引文件"></a>🍑索引文件</h2><p>在顺序文件基础上，增加索引表，其存放每条记录的关键字（或记录号）与其文件位置的对应关系。</p><ul><li>索引表本身为定长记录结构，支持折半查找。</li></ul><h3 id="🍐文件读写"><a href="#🍐文件读写" class="headerlink" title="🍐文件读写"></a>🍐文件读写</h3><p>首先根据索引表，由关键字（记录号）找到记录在文件位置，然后调整读写指针，再进行记录读写。可折半查找</p><h3 id="🍐特点-1"><a href="#🍐特点-1" class="headerlink" title="🍐特点"></a><strong>🍐特点</strong></h3><ol><li>支持记录直接存取</li><li>索引表需占用额外存储空间，尤其当记录数量很大时</li></ol><h2 id="🍑索引顺序文件"><a href="#🍑索引顺序文件" class="headerlink" title="🍑索引顺序文件"></a>🍑索引顺序文件</h2><p>为降低索引表的记录开销，为一组记录在索引表中建立一个索引项，而非每条记录一条索引项。</p><ul><li>分组方式：按关键字分组或直接按记录号分组</li></ul><h3 id="🍐文件读写-1"><a href="#🍐文件读写-1" class="headerlink" title="🍐文件读写"></a><strong>🍐文件读写</strong></h3><p>首先根据索引表，由关键字（记录号）找到记录所在组的文件起始位置，然后调整读写指针，再顺序读写记录，直到找到所要读写的记录。</p><h3 id="🍐特点-2"><a href="#🍐特点-2" class="headerlink" title="🍐特点"></a><strong>🍐特点</strong></h3><ol><li>支持记录直接存取</li><li>大大降低索引表的存储空间和I&#x2F;O、计算开销</li></ol><h2 id="🍑直接文件（HASH文件）"><a href="#🍑直接文件（HASH文件）" class="headerlink" title="🍑直接文件（HASH文件）"></a>🍑直接文件（HASH文件）</h2><p>直接根据记录的关键字（记录号），经简单计算，得到记录在文件的位置</p><ul><li>计算记录位置的方式</li></ul><p>Ai &#x3D; HASH( i ) ; &#x2F;&#x2F; 针对记录号<br>Ai &#x3D; HASH( key ) ; &#x2F;&#x2F; 针对关键字</p><h3 id="🍐文件读写-2"><a href="#🍐文件读写-2" class="headerlink" title="🍐文件读写"></a><strong>🍐文件读写</strong></h3><p>首先根据HASH函数，由关键字（记录号）计算记录在文件起始位置，然后调整读写指针，再读写。</p><h3 id="🍐特点-3"><a href="#🍐特点-3" class="headerlink" title="🍐特点"></a><strong>🍐特点</strong></h3><ol><li>支持记录直接存取</li><li>摆脱索引表，存储空间和I&#x2F;O、计算开销大幅降低</li></ol><h1 id="🍓文件的物理结构：外存分配方式"><a href="#🍓文件的物理结构：外存分配方式" class="headerlink" title="🍓文件的物理结构：外存分配方式"></a>🍓文件的物理结构：外存分配方式</h1><h2 id="🍑连续分配"><a href="#🍑连续分配" class="headerlink" title="🍑连续分配"></a>🍑连续分配</h2><p>要求为每个文件分配一组相邻接的磁盘块，且文件的逻辑记录的顺序与所存储磁盘块的块号顺序一致。<br>所形成的文件结构称<strong>顺序文件结构</strong>，物理文件称为顺序文件。</p><h3 id="🍐特点-4"><a href="#🍐特点-4" class="headerlink" title="🍐特点"></a>🍐特点</h3><ol><li>顺序访问容易，顺序访问速度快</li><li>支持逻辑记录直接存取</li><li>要求连续的存储空间</li><li>必须事先知道文件长度</li></ol><h2 id="🍑链接分配"><a href="#🍑链接分配" class="headerlink" title="🍑链接分配"></a>🍑链接分配</h2><p>采用离散分配思想，为每个文件分配一组不相邻接的磁盘块，且文件的逻辑记录的顺序与所存储磁盘块的块号顺序可不一致。</p><h3 id="🍐隐式链接——链接文件"><a href="#🍐隐式链接——链接文件" class="headerlink" title="🍐隐式链接——链接文件"></a>🍐隐式链接——链接文件</h3><p>采用单链表结构，各磁盘块存储指向下个磁盘块的块号。<br>所形成的文件结构称<strong>链接文件结构</strong>，物理文件称为链接文件。<br><img src="https://i.imgtg.com/2023/07/17/OzuFNY.png#height=244&id=xsME6&originHeight=488&originWidth=1115&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=558"><br>特点：</p><ol><li>不存在外存碎片问题</li><li>有利于文件的插入和删除</li><li>有利于文件动态增长和减小</li><li>读写文件时更多的寻道次数和寻道时间，存取速度慢</li><li>不适于随机存取</li><li>可靠性容错性差，如指针出错</li></ol><h3 id="🍐显式链接"><a href="#🍐显式链接" class="headerlink" title="🍐显式链接"></a>🍐显式链接</h3><p>设置<strong>文件分配表FAT</strong>，集中存储所有的磁盘块号信息<br>FAT表：磁盘块号（簇号）数组<br>——核心：单链表的集中存储。<br><img src="https://i.imgtg.com/2023/07/17/OzuhEv.png#id=C5kNG&originHeight=431&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>特点：</p><ol><li>不存在外存碎片问题</li><li>支持记录的插入和删除</li><li>有利于文件动态增长和减小</li><li>读写文件时更多的寻道次数和寻道时间，存取速度慢</li><li>支持随机存取</li><li>安全性和容错性比隐式链接哈</li></ol><h2 id="🍑索引分配"><a href="#🍑索引分配" class="headerlink" title="🍑索引分配"></a>🍑索引分配</h2><p>为每个文件设置索引表，存储其分配到的磁盘块号。<br>所形成的文件结构称索引文件结构，物理文件称为索引文件。<br><img src="https://i.imgtg.com/2023/07/17/Ozu7Rr.png#height=248&id=YlPnw&originHeight=496&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=313"></p><h3 id="🍐单级索引"><a href="#🍐单级索引" class="headerlink" title="🍐单级索引"></a>🍐单级索引</h3><h3 id="🍐二级和多级索引"><a href="#🍐二级和多级索引" class="headerlink" title="🍐二级和多级索引"></a>🍐二级和多级索引</h3><p>对于索引表的存储，也采用索引表来记录其所占用的磁盘块号，从而形成二级索引。</p><h3 id="🍐混合索引分配方式（UNIX-System-V）"><a href="#🍐混合索引分配方式（UNIX-System-V）" class="headerlink" title="🍐混合索引分配方式（UNIX System V）"></a>🍐混合索引分配方式（UNIX System V）</h3><p>混合使用直接磁盘块号、各级索引表，从而可以既支持小文件的存储，也可以支持大文件的存储，达到降低索引表存储空间和同时支持大中小文件的目的。<br>特点：</p><ol><li>不存在外部碎片问题</li><li>读写文件时较多的寻道次数和寻道时间，访问速度慢</li><li>支持记录的插入和删除</li><li>有利于文件动态增长和减小</li><li>既能顺序存取又能随机存取</li><li>索引表本身带来了系统开销（时间和空间）</li></ol><h1 id="🍓目录管理"><a href="#🍓目录管理" class="headerlink" title="🍓目录管理"></a>🍓目录管理</h1><p>对文件目录管理的基本要求：</p><ol><li>“按名存取”， 逻辑文件名称</li><li>提高文件目录检索速度</li><li>文件共享</li><li>允许文件重名</li></ol><h2 id="🍑文件控制块PCB"><a href="#🍑文件控制块PCB" class="headerlink" title="🍑文件控制块PCB"></a>🍑文件控制块PCB</h2><h3 id="🍐定义"><a href="#🍐定义" class="headerlink" title="🍐定义"></a>🍐定义</h3><p>描述文件信息（文件属性）的数据结构，操作系统据此管理和读写文件。</p><h3 id="🍐PCB包含的信息"><a href="#🍐PCB包含的信息" class="headerlink" title="🍐PCB包含的信息"></a>🍐PCB包含的信息</h3><ol><li>基本信息类<ol><li>文件名、文件物理位置、文件逻辑结构、文件物理结构</li></ol></li><li>存取控制信息类<ol><li>各类用户存取权限</li></ol></li><li>使用信息类<ol><li>文件的建立、修改、访问的日期时间，文件当前使用信息</li></ol></li></ol><h3 id="🍐文件目录-1"><a href="#🍐文件目录-1" class="headerlink" title="🍐文件目录"></a>🍐文件目录</h3><p>——可看作是文件控制块数组<br>检索效率问题：FCB中大量信息在检索中无用，但是占用I&#x2F;O带宽和存储空间。</p><h3 id="🍐索引结点"><a href="#🍐索引结点" class="headerlink" title="🍐索引结点"></a>🍐索引结点</h3><p>UNIX系统，将FCB中的文件名和文件的其余属性信息分开，前者用于组成文件目录，后者形成索引结点。两者之间通过索引结点编号相连。<br><img src="https://i.imgtg.com/2023/07/17/OzurUG.png#height=208&id=onDwG&originHeight=416&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=488"></p><h3 id="🍐内存索引结点和磁盘索引结点"><a href="#🍐内存索引结点和磁盘索引结点" class="headerlink" title="🍐内存索引结点和磁盘索引结点"></a>🍐内存索引结点和磁盘索引结点</h3><ol><li>磁盘索引结点<ol><li>存放在磁盘，存储除文件名外的文件属性信息</li></ol></li><li>内存索引结点<ol><li>存放在内存，除包含复制的磁盘索引结点信息外，还有<ol><li>索引结点编号、状态、访问计数</li><li>文件所属文件系统的逻辑设备号，链接指针</li></ol></li></ol></li></ol><h2 id="🍑文件目录"><a href="#🍑文件目录" class="headerlink" title="🍑文件目录"></a>🍑文件目录</h2><h3 id="🍐单级目录结构"><a href="#🍐单级目录结构" class="headerlink" title="🍐单级目录结构"></a>🍐单级目录结构</h3><p>整个文件系统中只建立一张目录表（组成一线性表），每文件占用一个目录项。<br>特点：</p><ol><li>访问速度慢</li><li>不允许重名</li><li>不便于文件共享</li></ol><h3 id="🍐二级目录结构"><a href="#🍐二级目录结构" class="headerlink" title="🍐二级目录结构"></a>🍐二级目录结构</h3><p>在主文件目录基础上，允许每个用户建立一个目录，文件存放在各用户子目录下。<br><img src="https://i.imgtg.com/2023/07/17/OzuyeF.md.png#height=250&id=A9Hyp&originHeight=500&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=433"><br>特点：</p><ol><li>改善目录检索速度</li><li>便于用户之间文件重名</li><li>便于用户间文件共享</li></ol><h3 id="🍐多级目录结构（树型目录结构）"><a href="#🍐多级目录结构（树型目录结构）" class="headerlink" title="🍐多级目录结构（树型目录结构）"></a>🍐多级目录结构（树型目录结构）</h3><p>允许目录下都可以建立子目录，文件可存放在任意子目录下。<br>特点：</p><ol><li>层次结构清晰，便于管理和保护</li><li>有利于文件分类</li><li>解决重名问题</li><li>提高文件检索速度</li><li>能进行存取权限的控制</li><li>查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度</li></ol><h4 id="🍈目录查询技术（逻辑文件—物理文件映射）"><a href="#🍈目录查询技术（逻辑文件—物理文件映射）" class="headerlink" title="🍈目录查询技术（逻辑文件—物理文件映射）"></a>🍈目录查询技术（逻辑文件—物理文件映射）</h4><ol><li>线性检索法<ol><li>分解路径名成各组组成部分，然后依次查找各目录名、文件名</li><li>基于索引结点的文件目录检索</li></ol></li></ol><h1 id="🍓文件存储空间管理"><a href="#🍓文件存储空间管理" class="headerlink" title="🍓文件存储空间管理"></a>🍓文件存储空间管理</h1><h2 id="🍑空闲表法"><a href="#🍑空闲表法" class="headerlink" title="🍑空闲表法"></a>🍑空闲表法</h2><p>系统为外存所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项。<br><img src="https://i.imgtg.com/2023/07/17/Ozudti.png#height=188&id=DqIXe&originHeight=375&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=458"></p><h2 id="🍑空闲链表法"><a href="#🍑空闲链表法" class="headerlink" title="🍑空闲链表法"></a>🍑空闲链表法</h2><p>系统为外存所有空闲区拉成一张空闲盘区（块）表。<br>空闲盘块链——结点代表一个空闲盘块<br>空闲盘区链——结点代表一个空闲盘区</p><h2 id="🍑位示图法"><a href="#🍑位示图法" class="headerlink" title="🍑位示图法"></a>🍑位示图法</h2><p>位示图利用二进制的一位来表示磁盘中的一个盘块的使用情况<br><img src="https://i.imgtg.com/2023/07/17/Ozufgx.md.png#height=250&id=ZFDZn&originHeight=500&originWidth=891&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=446"></p><h2 id="🍑成组链接法UNIX"><a href="#🍑成组链接法UNIX" class="headerlink" title="🍑成组链接法UNIX"></a>🍑成组链接法UNIX</h2><p>利用链栈存储所有的空闲磁盘块号。<br>链栈的每个结点存储一组磁盘块号，其中最后一个磁盘块号指向下一组所在的磁盘块号。<br><img src="https://i.imgtg.com/2023/07/17/Ozujop.png#height=238&id=d5MfW&originHeight=476&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=385"></p><h1 id="🍓文件共享"><a href="#🍓文件共享" class="headerlink" title="🍓文件共享"></a>🍓文件共享</h1><h2 id="🍑基于索引结点的共享"><a href="#🍑基于索引结点的共享" class="headerlink" title="🍑基于索引结点的共享"></a>🍑基于索引结点的共享</h2><p>利用不同文件名或相同文件名（同一目录）指向相同索引结点。</p><h2 id="🍑基于符号链的共享"><a href="#🍑基于符号链的共享" class="headerlink" title="🍑基于符号链的共享"></a>🍑基于符号链的共享</h2><p>利用符号链文件，其中存储被共享的文件路径名称。</p><h1 id="🍓数据一致性控制"><a href="#🍓数据一致性控制" class="headerlink" title="🍓数据一致性控制"></a>🍓数据一致性控制</h1><h2 id="🍑事务机制"><a href="#🍑事务机制" class="headerlink" title="🍑事务机制"></a>🍑事务机制</h2><p>事务是一系列相关数据项的读写操作。<br>利用事务机制实现数据一致性控制的方式。</p><ol><li>设置事务日志LOG，按时间顺序存放事务记录，LOG存放在稳定存储器中</li><li>读写数据之前，必须先写事务日志</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——传输层协议</title>
      <link href="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/16/Oz6EaY.png#height=639&id=XtPDj&originHeight=852&originWidth=1393&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1045"><br>传输层要解决的主要问题：</p><ol><li>传输连接的建立</li><li>流量控制</li><li>拥塞控制</li></ol><h1 id="🍗传输层概述"><a href="#🍗传输层概述" class="headerlink" title="🍗传输层概述"></a>🍗传输层概述</h1><p>传输层实现了一种将面向应用（进程）的通信需求转变为面向网络设备的通信服务。</p><h2 id="🥡端到端的通信"><a href="#🥡端到端的通信" class="headerlink" title="🥡端到端的通信"></a>🥡端到端的通信</h2><p>计算机网络由<strong>网络边缘</strong>和<strong>网络核心</strong>两大部分组成。</p><h3 id="🦪网络边缘"><a href="#🦪网络边缘" class="headerlink" title="🦪网络边缘"></a>🦪网络边缘</h3><p>网络边缘通常是指主机、存储、服务器、数据库等各种软硬件设备组成，是网络信息资源的集散地。</p><h3 id="🦪网络核心"><a href="#🦪网络核心" class="headerlink" title="🦪网络核心"></a>🦪网络核心</h3><p>网络核心由提供数据转发服务的网络路由器，以及连接各路由器的链路（如光纤、通信卫星等）组成。</p><h3 id="🦪传输层的作用和功能"><a href="#🦪传输层的作用和功能" class="headerlink" title="🦪传输层的作用和功能"></a>🦪传输层的作用和功能</h3><ul><li>传输层的主要作用是为运行在网络边缘的不同主机上的各应用程序之间提供通信服务。传输层是<strong>端到端</strong>的通信服务。</li><li>传输层通信为不同进程之间提供了逻辑通信服务。</li><li>传输层的另外一个主要作用是在应用层和网络层之间充当复用器作用。各种各样的网络应用，通过传输层的端口被提交统一的网络层，并由IP协议用统一的方式将它们发送到网络中。</li></ul><p><img src="https://i.imgtg.com/2023/07/16/Ozl3Z6.md.png#height=250&id=IeZ8T&originHeight=500&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=419"><br>传输层位于资源子网和通信子网之间，主要功能如下：</p><ol><li>对高层应用屏蔽了通信的细节，无需过多考虑各种通信因素对网络通信过程本身的影响。</li><li>提供端到端之间的无差错保证，弥补网络层提供服务的差异和不足。</li></ol><p><img src="https://i.imgtg.com/2023/07/16/OzlCcP.png#height=213&id=s0CNQ&originHeight=426&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=433"></p><h3 id="🦪传输层协议和应用层协议的区别"><a href="#🦪传输层协议和应用层协议的区别" class="headerlink" title="🦪传输层协议和应用层协议的区别"></a>🦪传输层协议和应用层协议的区别</h3><p><img src="https://i.imgtg.com/2023/07/16/Oz9MOb.md.png#height=250&id=JW19i&originHeight=500&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=434"><br>从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。传输层位于网络层之上，它为运行在不同主机上的<strong>进程</strong>之间提供逻辑通信。<br>网络层提供<strong>主机</strong>之间的逻辑通信。<br>网络层协议不可靠。<br>传输层能为应用程序提供可靠服务。</p><h2 id="🥡传输层提供的服务"><a href="#🥡传输层提供的服务" class="headerlink" title="🥡传输层提供的服务"></a>🥡传输层提供的服务</h2><p>面向连接&#x2F;面向无连接的服务</p><ol><li>面向连接的服务——TCP服务<ol><li>通信可靠、对数据有校验和重发机制</li><li>实现复杂，代价较大，通信速率相对较低</li></ol></li><li>面向无连接的服务——UDP服务<ol><li>对数据无校验和重发</li><li>实现简单，通信速率高</li></ol></li></ol><h3 id="🦪TCP服务"><a href="#🦪TCP服务" class="headerlink" title="🦪TCP服务"></a><strong>🦪TCP服务</strong></h3><p>TCP提供面向连接的服务。<br><strong>TCP报文段</strong>是在传输层抽象的端到端逻辑信道中传送，可靠的全双工信道。</p><h3 id="🦪UDP服务"><a href="#🦪UDP服务" class="headerlink" title="🦪UDP服务"></a><strong>🦪UDP服务</strong></h3><p>UDP在传送数据之前不需要先建立连接。对方的运输层收到UDP报文后，也不需要给出任何确认。</p><h2 id="🥡传输层的端口与地址"><a href="#🥡传输层的端口与地址" class="headerlink" title="🥡传输层的端口与地址"></a>🥡传输层的端口与地址</h2><p>在传输层中使用协议端口号，简称为端口——可以把端口想象是通信的终点</p><ol><li>硬件端口——路由器或交换机上的端口<ol><li>硬件端口是不同硬件设备进行交互的接口</li></ol></li><li>软件端口——在协议栈层间的抽象的协议端口<ol><li>软件端口是应用层的各种协议进程与传输层协议进行层间交互的一种接口</li></ol></li></ol><p>传输层地址（TSAP）&#x3D; 主机IP地址 + 端口号</p><h2 id="🥡套接字"><a href="#🥡套接字" class="headerlink" title="🥡套接字"></a>🥡套接字</h2><p>套接字（Socket）是为了使应用程序能够方便的使用协议栈软件进行通信的一种方式<br>半相关：<strong>Socket&#x3D;{协议，本地地址，本地端口}</strong><br>完整的Socket：**{协议，本地地址，本地端口，远程地址，远程端口}**</p><ul><li>套接字上连应用进程，下连网络协议栈，是应用程序通过网络协议栈进行通信的接口，是应用程序与网络协议栈进行交互的接口</li></ul><p><img src="https://i.imgtg.com/2023/07/16/Oz9BPK.jpg#height=210&id=yFlGv&originHeight=420&originWidth=1325&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=663"></p><h1 id="🍗用户数据报协议UDP"><a href="#🍗用户数据报协议UDP" class="headerlink" title="🍗用户数据报协议UDP"></a>🍗用户数据报协议UDP</h1><p>基本目的：提供面向事务的简单、不可靠的信息传送服务</p><h2 id="🥡UDP的主要特点"><a href="#🥡UDP的主要特点" class="headerlink" title="🥡UDP的主要特点"></a>🥡UDP的主要特点</h2><ol><li>UDP是无连接协议，在发送数据之前不需要建立连接</li><li>UDP使用尽最大努力交付，不保证可靠交付，同时也不使用拥塞控制</li><li>UDP是面向报文，适合多媒体通信</li><li>UDP支持一对一、一对多、多对一、多对多的交互通信</li><li>UDP的首部开销小，只有8个字节</li></ol><ul><li>不管应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li></ul><p><img src="https://i.imgtg.com/2023/07/16/Oz9iut.md.png#height=250&id=sH2y6&originHeight=500&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"></p><h1 id="🍗传输控制协议TCP"><a href="#🍗传输控制协议TCP" class="headerlink" title="🍗传输控制协议TCP"></a>🍗传输控制协议TCP</h1><p>传输控制协议TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><h2 id="🥡TCP的主要特点"><a href="#🥡TCP的主要特点" class="headerlink" title="🥡TCP的主要特点"></a>🥡TCP的主要特点</h2><ol><li>TCP是面向连接的传输层协议</li><li>每一条TCP连接只能有两个断点，每一条TCP连接只能是点对点的（一对一）</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信</li><li>TCP面向字节流</li></ol><p><img src="https://i.imgtg.com/2023/07/16/Oz9N9p.md.png#height=250&id=oHZYV&originHeight=500&originWidth=968&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=484"></p><ul><li>TCP连接是一种虚连接，不是真正的物理连接</li><li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节</li><li>TCP连接采用<strong>客户服务器方式</strong></li></ul><h2 id="🥡TCP的连接"><a href="#🥡TCP的连接" class="headerlink" title="🥡TCP的连接"></a>🥡TCP的连接</h2><h3 id="🦪TCP连接"><a href="#🦪TCP连接" class="headerlink" title="🦪TCP连接"></a><strong>🦪TCP连接</strong></h3><ol><li>每一条TCP连接有两个端点——套接字或端口</li><li>端口号拼接到IP地址构成套接字</li></ol><h3 id="🦪TCP连接的三个阶段"><a href="#🦪TCP连接的三个阶段" class="headerlink" title="🦪TCP连接的三个阶段"></a><strong>🦪TCP连接的三个阶段</strong></h3><ol><li>连接建立</li><li>数据传送</li><li>连接释放</li></ol><p>连接建立过程中要解决的三个问题：</p><ol><li>要使通信双方都能确知对方的存在</li><li>要允许双方协商一些参数（如最大报文长度，最大窗口大小，服务质量等）</li><li>能够对传输实体资源进行分配</li></ol><h3 id="🦪TCP连接的建立——三次握手"><a href="#🦪TCP连接的建立——三次握手" class="headerlink" title="🦪TCP连接的建立——三次握手"></a><strong>🦪TCP连接的建立——三次握手</strong></h3><ol><li>第一次：客户端——&gt;服务器<ol><li>客户端向服务器提出连接建立请求，即发出同步请求报文。</li></ol></li><li>第二次：服务器——&gt;客户端<ol><li>服务器收到客户端的连接请求后，向客户端发出同意建立连接的同步确认报文。</li></ol></li><li>第三次：客户端——&gt;服务器<ol><li>客户端在收到服务器的同步确认报文后，向服务器发出确认报文。</li></ol></li></ol><p>服务器收到来自客户端的确认报文后，连接即被建立。<br><img src="https://i.imgtg.com/2023/07/16/Oz9yNc.md.png#height=250&id=q8HHI&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=406"></p><h4 id="🍱为什么不采用“两次握手”"><a href="#🍱为什么不采用“两次握手”" class="headerlink" title="🍱为什么不采用“两次握手”"></a>🍱为什么不采用“两次握手”</h4><p>防止两次握手情况下，已经失效的连接请求报文又突然传送到服务器而产生错误。<br>客户A向服务器B发出TCP连接，第一个连接请求报文在网络的某个结点长时间滞留，A超时后认为报文丢失，再重传连接请求，B收到后建立连接。数据传输完毕后双方断开连接，此时前一个滞留在网络中的连接请求到达B，B认为A又发来一次连接请求。若“三次握手”——B向A返回确认报文段，失效；“两次握手”——B认为传输已经连接，并一直等待A传输数据，造成资源浪费。</p><h3 id="🦪TCP连接的释放——四次挥手"><a href="#🦪TCP连接的释放——四次挥手" class="headerlink" title="🦪TCP连接的释放——四次挥手"></a><strong>🦪TCP连接的释放——四次挥手</strong></h3><ol><li>第一次：客户端——&gt;服务器<ol><li>客户端向服务器发出一个连接释放报文</li></ol></li><li>第二次：服务器——&gt;客户端<ol><li>服务器收到客户端的释放连接请求后，向客户端发出确认报文</li></ol></li><li>第三次：服务器——&gt;客户端<ol><li>服务器在发送完最后的数据报后，向客户端发出连接释放确认报文</li></ol></li><li>第四次：客户端——&gt;服务器<ol><li>客户端在收到服务器连接释放报文后，向服务器发出确认报文</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/16/Oz9R9I.md.png#id=q3E2Z&originHeight=500&originWidth=773&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li><strong>TCP连接必须经过时间2MSL后才真正释放掉</strong></li></ul><p>——MSL（Maximum Segment Lifetime）是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃</p><h3 id="🦪必须等待2MSL的时间的原因"><a href="#🦪必须等待2MSL的时间的原因" class="headerlink" title="🦪必须等待2MSL的时间的原因"></a><strong>🦪必须等待2MSL的时间的原因</strong></h3><ol><li>为了保证客户端发送的最后一个ASK报文段能够达到服务器</li><li>防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ASK报文段后，在经过时间2MSL就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h2 id="🥡TCP的计时器"><a href="#🥡TCP的计时器" class="headerlink" title="🥡TCP的计时器"></a>🥡TCP的计时器</h2><h3 id="🦪重传计时器"><a href="#🦪重传计时器" class="headerlink" title="🦪重传计时器"></a><strong>🦪重传计时器</strong></h3><p>当发送发出数据报文后，即启动该计时器。——在设定时间截止之前收到确认报文，传输成功，撤销计时器；否则传输失败，重新发送报文。</p><h3 id="🦪坚持计时器"><a href="#🦪坚持计时器" class="headerlink" title="🦪坚持计时器"></a><strong>🦪坚持计时器</strong></h3><p>当接收方发出一个零窗口确认报文，发送方立即停止发送数据报文直到接收方发出非零窗口的确认报文。由于TCP不会对确认报文进行确认，因此接收方在发出非零窗口确认报文后即进入等待发送方发送数据报文。如果此确认报文在中途丢失，在通信会陷入死锁。<br>坚持计时器（Persistent Timer）即为破解此死锁而设定。当发送方收到一个零窗口确认时，即启动坚持计时器 。 </p><ul><li>若在设定时间到达之前收到接收方的非零窗口确认报文，则撤销该计时器，恢复正常发送数据报文。</li><li>若设定时间到达仍未收到接收方的非零窗口确认报文，则发送方发出一个只有一个字节数据的<strong>探测报文</strong>并消耗一个序号，但该序号会被确认报文所忽略。</li></ul><p>——探测报文：提醒接收方 确认丢失，重新发送</p><h3 id="🦪保活计时器"><a href="#🦪保活计时器" class="headerlink" title="🦪保活计时器"></a><strong>🦪保活计时器</strong></h3><p>保活计时器用于判断两个TCP端点之间长久的连接是否正常。<br>当客户端与服务器建立了TCP连接后，保活计时器即被激活，并设置计时值（通常为2小时）。每当服务器收到来自客户端的报文，即重置计时器。</p><h3 id="🦪时间等待计时器"><a href="#🦪时间等待计时器" class="headerlink" title="🦪时间等待计时器"></a><strong>🦪时间等待计时器</strong></h3><p>时间等待计时器也叫2MSL计时器，是TCP终止连接时启动的计时器——为了能够正常关闭服务段的连接</p><h1 id="🍗TCP可靠传输原理"><a href="#🍗TCP可靠传输原理" class="headerlink" title="🍗TCP可靠传输原理"></a>🍗TCP可靠传输原理</h1><h2 id="🥡可靠传输概念"><a href="#🥡可靠传输概念" class="headerlink" title="🥡可靠传输概念"></a>🥡可靠传输概念</h2><p>可靠传输即无差错传输——所有发送的数据都能被无差错接受<br>差错检测——具有发现传输过程中可能出现的各种差错的能力，即从发送到接收的传输过程的各个阶段都有差错监测能力</p><h3 id="🦪差错监测和控制"><a href="#🦪差错监测和控制" class="headerlink" title="🦪差错监测和控制"></a><strong>🦪差错监测和控制</strong></h3><ol><li>检错码</li><li>纠错码</li></ol><h3 id="🦪可靠传输"><a href="#🦪可靠传输" class="headerlink" title="🦪可靠传输"></a><strong>🦪可靠传输</strong></h3><p>在不可靠的信道上实现可靠传输，需要达到的条件如下：</p><ol><li>各数据位无差错</li><li>无数据丢失</li><li>无数据重复</li><li>接收到的数据顺序与发送端保持一致</li></ol><p>——差错检测<br>——数据编号、数据确认、数据重传</p><h2 id="🥡停止等待协议"><a href="#🥡停止等待协议" class="headerlink" title="🥡停止等待协议"></a>🥡停止等待协议</h2><h3 id="🦪简单流控"><a href="#🦪简单流控" class="headerlink" title="🦪简单流控"></a><strong>🦪简单流控</strong></h3><p>基本思想：由接收端控制发送端发送数据的速度</p><ul><li><strong>停等协议的基本算法</strong></li></ul><ol><li>发送端<ol><li>等待从上层应用中获得数据</li><li>获得数据并封装成可发送的数据报文</li><li>发送报文，等待接收端的确认报文转（1）</li></ol></li><li>接收端<ol><li>等发送端发送数据</li><li>获得数据并转交到上层应用</li><li>向发送端发送确认报文，转（1）</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/16/Oz9DyF.md.png#height=250&id=inFVx&originHeight=500&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=414"></p><h3 id="🦪有差错的流控"><a href="#🦪有差错的流控" class="headerlink" title="🦪有差错的流控"></a><strong>🦪有差错的流控</strong></h3><ol><li>发送端<ol><li>从上层获得数据并计算校验码，封装报文并缓存。</li><li>发送报文并等待接收端应答报文。</li><li>收到接收端应答报文。若肯定，删除缓存并转（1）；若否定，提取缓存数据报文并转（2）。</li></ol></li><li>接收端<ol><li>等待并获得发送端发送的报文，缓存并校验。</li><li>若校验错，删缓存并发否定报文，转（1）；若校验正确，上交缓存并删缓存，发肯定报文，转（1）。</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/16/Oz9Hd6.md.png#height=250&id=eCaWE&originHeight=500&originWidth=801&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=401"></p><h3 id="🦪有报文丢失的流控"><a href="#🦪有报文丢失的流控" class="headerlink" title="🦪有报文丢失的流控"></a><strong>🦪有报文丢失的流控</strong></h3><p>无论是数据报文（发送端发送）还是应答报文（接收端发送），都有可能在传输过程中丢失。</p><ul><li>若数据报文丢失，接收端未收到数据报文，等待发送端发送。</li><li>若应答报文丢失，发送端未收到应答报文，等待接收端发送。</li></ul><p>！死锁！——设置重发计时器——Tout略大于报文平均往返时间</p><h3 id="🦪信达利用率"><a href="#🦪信达利用率" class="headerlink" title="🦪信达利用率"></a><strong>🦪信达利用率</strong></h3><p>停止等待协议的最大优点是<strong>简单</strong>，最大缺点是<strong>信道利用率极低</strong>。<br><img src="https://i.imgtg.com/2023/07/16/Oz9EaP.md.png#height=250&id=D90l4&originHeight=500&originWidth=1060&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=530"></p><h3 id="🦪改进后的停等协议"><a href="#🦪改进后的停等协议" class="headerlink" title="🦪改进后的停等协议"></a><strong>🦪改进后的停等协议</strong></h3><p>具备超时自动重传的能力，改进后的停止等待协议也被称为停止等待自动重传请求协议（Automatic Repeat reQuest，ARQ），简称<strong>停等ARQ协议</strong>。</p><h2 id="🥡连续ARQ协议"><a href="#🥡连续ARQ协议" class="headerlink" title="🥡连续ARQ协议"></a>🥡连续ARQ协议</h2><p>发送方可连续发送多个报文，不必每发完一个报文就停止并等待接收方的确认，也被称为流水线传输。</p><h3 id="🦪流水线传输"><a href="#🦪流水线传输" class="headerlink" title="🦪流水线传输"></a><strong>🦪流水线传输</strong></h3><p>发送方在TD+RTT+TA的时间周期内不必每发送一个报文就等待接收方的确认，而是连续的发送多个报文。<br><img src="https://i.imgtg.com/2023/07/16/Oz9wWp.png#height=178&id=qwIir&originHeight=355&originWidth=1354&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=677"></p><ul><li>有很高的信道利用率</li></ul><p><img src="https://i.imgtg.com/2023/07/16/OzjMgU.png#height=90&id=nUSyl&originHeight=180&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=346"><br>其中：n为在时间周期内可以发送的数据报文的数量。</p><ul><li>代价</li></ul><p>发送方要准备好n个缓冲区，用于暂存n个报文，以备重发。只有收到针对某报文的确认后，相应的缓存报文才能删除。</p><h3 id="🦪GO-Back-N的连续ARQ"><a href="#🦪GO-Back-N的连续ARQ" class="headerlink" title="🦪GO-Back-N的连续ARQ"></a><strong>🦪GO-Back-N的连续ARQ</strong></h3><p>返回N(GO-Back-N  GBN)的连续ARQ是指接收方只接收按序到达的正确报文。</p><h3 id="🦪滑动窗口"><a href="#🦪滑动窗口" class="headerlink" title="🦪滑动窗口"></a><strong>🦪滑动窗口</strong></h3><p>滑动窗口SW是一种流控方法，用于约束发送方可发送报文的数量。窗口是指发送方最多可发送未被确认报文的数量，而滑动则是指每收到一个确认报文，窗口可向前滑动的一个报文，从而纳入新的待发送的报文。</p><ul><li>停等ARQ协议是连续ARQ协议窗口为1的特例</li></ul><h3 id="🦪应答机制改进"><a href="#🦪应答机制改进" class="headerlink" title="🦪应答机制改进"></a><strong>🦪应答机制改进</strong></h3><ol><li>捎带应答</li><li>累积应答</li></ol><h1 id="🍗TCP可靠传输的实现"><a href="#🍗TCP可靠传输的实现" class="headerlink" title="🍗TCP可靠传输的实现"></a>🍗TCP可靠传输的实现</h1><p>在TCP中，每个连接的两端都各两个窗口：一个发送窗口和一个接收窗口。<br>TCP为其传输的每个字节都编制一个序号，并以此为基础构建可靠传输。同样，TCP的确认也都是基于（字节）序号而不是报文序号。</p><h2 id="🥡以字节为单位的滑动窗口"><a href="#🥡以字节为单位的滑动窗口" class="headerlink" title="🥡以字节为单位的滑动窗口"></a>🥡以字节为单位的滑动窗口</h2><p>滑动窗口用于</p><ol><li>差错控制——控制“连续ARQ”的参数</li><li>流量控制——控制发送报文的速率</li></ol><p>TCP滑动窗口的特点——面向<strong>字节流</strong></p><h3 id="🦪发送窗口"><a href="#🦪发送窗口" class="headerlink" title="🦪发送窗口"></a><strong>🦪发送窗口</strong></h3><p>TCP报文首部中的窗口字段即为接收方可允许发送方可以发送的字节数，以约束发送方的发送量。<br><img src="https://i.imgtg.com/2023/07/16/Ozj5Gc.png#height=228&id=HLKbj&originHeight=456&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=748"></p><h3 id="🦪接收窗口"><a href="#🦪接收窗口" class="headerlink" title="🦪接收窗口"></a><strong>🦪接收窗口</strong></h3><p>通常先临时存放在接收窗口中，等收到字节流中所缺少的字节后，再一并交付上层应用程序。<br><img src="https://i.imgtg.com/2023/07/16/OzjB3r.md.png#height=375&id=ML1GM&originHeight=500&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=674"></p><h3 id="🦪缓存与接收缓存的作用"><a href="#🦪缓存与接收缓存的作用" class="headerlink" title="🦪缓存与接收缓存的作用"></a><strong>🦪缓存与接收缓存的作用</strong></h3><ol><li>发送缓存用来暂时存放<ol><li>发送应用程序传送给发送方TCP准备发送的数据</li><li>TCP已发送但尚未收到确认的数据</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/16/OzjWtG.md.png#height=250&id=evxtY&originHeight=500&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=498"></p><ol start="2"><li>接收缓存用来暂时存放<ol><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>不按序到达的数据</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/16/Ozjb21.md.png#height=250&id=f8M6U&originHeight=500&originWidth=885&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=443"></p><h2 id="🥡超时重传时间的选择"><a href="#🥡超时重传时间的选择" class="headerlink" title="🥡超时重传时间的选择"></a>🥡超时重传时间的选择</h2><p>TCP每发送一个报文段，就对这个报文段设置一次计时器，只要计时器设置的这个重传时间到但还没有收到确认，就要重传这一报文段。</p><ul><li>超时重传时间RTO</li><li>往返时间RTT</li><li>加权平均往返时间RTTs——平滑往返时间反应往返时间</li></ul><h3 id="🦪RTT在报文重传过程中的重要性"><a href="#🦪RTT在报文重传过程中的重要性" class="headerlink" title="🦪RTT在报文重传过程中的重要性"></a><strong>🦪RTT在报文重传过程中的重要性</strong></h3><ul><li>RTO小于RTT——会造成很多不必要的重传</li><li>RTO远大于RTT——会降低整体网络的利用率</li></ul><h3 id="🦪指数避退"><a href="#🦪指数避退" class="headerlink" title="🦪指数避退"></a><strong>🦪指数避退</strong></h3><p>在TCP中，当超时而发生连续多次重传时，在两次重传之间的超时阈值的设置遵循“指数避退”原则。</p><h2 id="🥡选择确认"><a href="#🥡选择确认" class="headerlink" title="🥡选择确认"></a>🥡选择确认</h2><p>接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确的告诉发送方，使发送方不要再重复发送这些已收到的数据。</p><h1 id="🍗TCP的流量控制"><a href="#🍗TCP的流量控制" class="headerlink" title="🍗TCP的流量控制"></a>🍗TCP的流量控制</h1><h2 id="🥡利用流量窗口实现流量控制"><a href="#🥡利用流量窗口实现流量控制" class="headerlink" title="🥡利用流量窗口实现流量控制"></a>🥡利用流量窗口实现流量控制</h2><p>流量控制就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。<br><img src="https://i.imgtg.com/2023/07/16/OzjxWI.md.png#height=250&id=xi3E5&originHeight=500&originWidth=842&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=421"></p><h2 id="🥡持续计时器"><a href="#🥡持续计时器" class="headerlink" title="🥡持续计时器"></a>🥡持续计时器</h2><p>TCP为每一个连接设置一个持续计时器。只要TCP连接的一方收到对方的<strong>零窗口</strong>通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文，而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。</p><h2 id="🥡糊涂窗口综合症"><a href="#🥡糊涂窗口综合症" class="headerlink" title="🥡糊涂窗口综合症"></a>🥡糊涂窗口综合症</h2><p>接收端和发送速率不匹配</p><h3 id="🦪你糊涂我不糊涂Nagle"><a href="#🦪你糊涂我不糊涂Nagle" class="headerlink" title="🦪你糊涂我不糊涂Nagle"></a><strong>🦪你糊涂我不糊涂Nagle</strong></h3><p>尽可能避免发送小数据报文，一个TCP连接上最多只能有一个未被确认的小数据报文。<br>在小数据报文的确认报文到达之前不发送其他小数据报文。并且持续接受小数据报文，并在确认到来时以一个较大的报文发送出去。</p><h3 id="🦪治疗接收端糊涂Clark"><a href="#🦪治疗接收端糊涂Clark" class="headerlink" title="🦪治疗接收端糊涂Clark"></a><strong>🦪治疗接收端糊涂Clark</strong></h3><p>只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</p><h1 id="🍗TCP的拥塞控制"><a href="#🍗TCP的拥塞控制" class="headerlink" title="🍗TCP的拥塞控制"></a>🍗TCP的拥塞控制</h1><ol><li><strong>拥塞</strong>——即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网路的吞吐量随之负荷的增大而下降。</li><li><strong>拥塞控制</strong>——防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载。<ol><li>拥塞控制的前提——<strong>网络能够承受现有的网络负荷</strong></li></ol></li></ol><h2 id="🥡拥塞控制的一般原理"><a href="#🥡拥塞控制的一般原理" class="headerlink" title="🥡拥塞控制的一般原理"></a>🥡拥塞控制的一般原理</h2><h3 id="🦪拥塞原因"><a href="#🦪拥塞原因" class="headerlink" title="🦪拥塞原因"></a><strong>🦪拥塞原因</strong></h3><p>产生拥塞——在某段时间，若对网络中某种资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏<br>对资源需求的综合&gt;可用资源</p><h3 id="🦪拥塞控制与流量控制"><a href="#🦪拥塞控制与流量控制" class="headerlink" title="🦪拥塞控制与流量控制"></a><strong>🦪拥塞控制与流量控制</strong></h3><ol><li><strong>拥塞控制</strong>——网络能够承受现有的网络负荷<ol><li>全局性过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素</li></ol></li><li><strong>流量控制</strong>——在给定的发送端和接收端之间的点对点通信量的控制<ol><li>抑制发送端发送数据的速率，以便使接收端来得及接收</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/16/Ozj1Qb.md.png#height=250&id=ziHkj&originHeight=500&originWidth=906&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=453"></p><h2 id="🥡拥塞控制的一般方法"><a href="#🥡拥塞控制的一般方法" class="headerlink" title="🥡拥塞控制的一般方法"></a>🥡拥塞控制的一般方法</h2><h3 id="🦪慢开始和拥塞避免"><a href="#🦪慢开始和拥塞避免" class="headerlink" title="🦪慢开始和拥塞避免"></a><strong>🦪慢开始和拥塞避免</strong></h3><p>发送方维持一个叫做<strong>拥塞窗口cwnd</strong>的状态变量<br>发送方控制cwnd的原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便更多的字节发送出去。只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的字节数。</p><h4 id="🍱慢开始算法的原理"><a href="#🍱慢开始算法的原理" class="headerlink" title="🍱慢开始算法的原理"></a>🍱慢开始算法的原理</h4><ol><li>在主机刚刚开始发送报文段时，可先设置拥塞窗口cwnd&#x3D;1，即设置为一个最大报文段MSS的数值。</li><li>在每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加一个MSS的数值。</li><li>逐步增大发送端的拥塞窗口cwnd，使字节注入到网络的速率更加合理。</li></ol><h4 id="🍱传输轮次"><a href="#🍱传输轮次" class="headerlink" title="🍱传输轮次"></a>🍱传输轮次</h4><p>使用慢开始算法后，每经过一个传输轮次，<strong>拥塞窗口cwnd就加倍</strong>。<br>一个传输轮次所经历的时间就是往返时间RTT。<br>“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>一个传输论次中可能会有发送多个报文段并收到对应的确认报文段。<br><img src="https://i.imgtg.com/2023/07/16/Ozjeig.md.png#height=375&id=anGhr&originHeight=500&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=587"></p><h4 id="🍱门限状态变量及其设置方法"><a href="#🍱门限状态变量及其设置方法" class="headerlink" title="🍱门限状态变量及其设置方法"></a>🍱门限状态变量及其设置方法</h4><p>门限状态变量ssthresh是指网络状态达到某个临界点，继续延续这种状态将导致状态发生转变——ssthresh&#x3D;65535</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p><h4 id="🍱拥塞避免阶段"><a href="#🍱拥塞避免阶段" class="headerlink" title="🍱拥塞避免阶段"></a>🍱拥塞避免阶段</h4><ul><li>在拥塞避免阶段，每经过一个往返传输时间RTT，则CongWindow&#x3D;CongWindow+1个MSS，RTT是动态变化的。</li><li>不管是慢开始阶段，还是拥塞避免阶段，如果TCP检测到拥塞，则将<strong>sstresh缩减成CongWindow的一半</strong>，且<strong>CongWindow恢复为初始大小，即一个MSS</strong>。</li></ul><p><img src="https://i.imgtg.com/2023/07/16/OzjD6x.md.png#height=250&id=SSfBS&originHeight=500&originWidth=1165&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=583"></p><ul><li><strong>“乘法减小”</strong>是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。</li><li><strong>“加法增大”</strong>是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</li></ul><h3 id="🦪快重传和快恢复"><a href="#🦪快重传和快恢复" class="headerlink" title="🦪快重传和快恢复"></a><strong>🦪快重传和快恢复</strong></h3><p>快重传算法首先要求接收方每收到一个失序的报文段后，就立即发出重复确认。——让发送方及早知道有报文段没有到达的地方。<br>发送方连续收到三个重复确认就应当立即重传对方尚未收到的报文段。<br><img src="https://i.imgtg.com/2023/07/16/Oz2ITp.md.png#height=250&id=uUl2E&originHeight=500&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=410"></p><h4 id="🍱快恢复算法"><a href="#🍱快恢复算法" class="headerlink" title="🍱快恢复算法"></a>🍱快恢复算法</h4><ol><li>当发送方收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，但接下去不执行慢开始算法</li><li>由于发送方现在认为网络很可能没有发生拥塞，因此不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是<strong>设置为慢开始门限 ssthresh 减半后的数值</strong>，然后开始执行<strong>拥塞避免算法</strong>（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——设备管理</title>
      <link href="/2023/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/16/OzXz8l.png#id=sw5WH&originHeight=567&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🥗I-x2F-O系统"><a href="#🥗I-x2F-O系统" class="headerlink" title="🥗I&#x2F;O系统"></a>🥗I&#x2F;O系统</h1><h2 id="🥙I-x2F-O系统的基本结构"><a href="#🥙I-x2F-O系统的基本结构" class="headerlink" title="🥙I&#x2F;O系统的基本结构"></a>🥙I&#x2F;O系统的基本结构</h2><h3 id="🥪硬件基本结构"><a href="#🥪硬件基本结构" class="headerlink" title="🥪硬件基本结构"></a>🥪硬件基本结构</h3><p><img src="https://i.imgtg.com/2023/07/16/Oz8zgj.png#id=YD4gb&originHeight=367&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🥪I-x2F-O系统组成成分"><a href="#🥪I-x2F-O系统组成成分" class="headerlink" title="🥪I&#x2F;O系统组成成分"></a>🥪I&#x2F;O系统组成成分</h3><h4 id="🌯I-x2F-O设备"><a href="#🌯I-x2F-O设备" class="headerlink" title="🌯I&#x2F;O设备"></a>🌯I&#x2F;O设备</h4><p>——具体完成数据I&#x2F;O的设备</p><ol><li>按速率分类</li><li>按信息交换单位分类</li></ol><h4 id="🌯设备控制器"><a href="#🌯设备控制器" class="headerlink" title="🌯设备控制器"></a>🌯设备控制器</h4><p>——负责连接I&#x2F;O设备和数据的总线，完成设备控制和数据格式转换</p><ol><li>接受和识别命令</li><li>数据交换</li><li>标志和报告设备状态</li><li>地址识别</li><li>数据缓冲</li><li>差错控制</li></ol><h4 id="🌯I-x2F-O通道"><a href="#🌯I-x2F-O通道" class="headerlink" title="🌯I&#x2F;O通道"></a>🌯I&#x2F;O通道</h4><p>——使原来由CPU处理的I&#x2F;O任务转由通道来承担，从而把CPU从繁杂的I&#x2F;O任务中解脱出来</p><ol><li>特殊的处理器，专门负责输入&#x2F;输出</li><li>一般只有数据传送指令、设备控制指令</li><li>通道没有自己的内存，通道所执行的程序是存放在主机内存中的，它与CPU共享内存</li></ol><h3 id="🥪I-x2F-O系统结构"><a href="#🥪I-x2F-O系统结构" class="headerlink" title="🥪I&#x2F;O系统结构"></a>🥪I&#x2F;O系统结构</h3><h4 id="🌯单通路I-x2F-O系统"><a href="#🌯单通路I-x2F-O系统" class="headerlink" title="🌯单通路I&#x2F;O系统"></a>🌯单通路I&#x2F;O系统</h4><p><img src="https://i.imgtg.com/2023/07/16/Oz8FVp.png#id=iAwFG&originHeight=478&originWidth=1086&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>无冗余设备，容错性差</li></ul><h4 id="🌯多通路I-x2F-O系统"><a href="#🌯多通路I-x2F-O系统" class="headerlink" title="🌯多通路I&#x2F;O系统"></a>🌯多通路I&#x2F;O系统</h4><p><img src="https://i.imgtg.com/2023/07/16/Oz8iqU.png#id=unq6v&originHeight=357&originWidth=804&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>有冗余设备，容错性佳</li></ul><h2 id="🥙I-x2F-O控制方式"><a href="#🥙I-x2F-O控制方式" class="headerlink" title="🥙I&#x2F;O控制方式"></a>🥙I&#x2F;O控制方式</h2><p>设备管理的主要任务之一，是控制设备和内存或CPU之间的数据传送，外围设备和内存之间常用的数据传送控制方式有四种</p><ol><li>程序I&#x2F;O方式</li><li>中断驱动I&#x2F;O控制方式</li><li>直接存储器存储方式-DMA</li><li>通道控制方式</li></ol><h3 id="🥪程序I-x2F-O方式"><a href="#🥪程序I-x2F-O方式" class="headerlink" title="🥪程序I&#x2F;O方式"></a>🥪程序I&#x2F;O方式</h3><p>早期的计算机系统中，没有中断系统，因此CPU和I&#x2F;O设备进行通信，传输数据时CPU速度远快于I&#x2F;O设备，于是CPU需要不断测试I&#x2F;O设备，看其是否完成了传输。<br><img src="https://i.imgtg.com/2023/07/16/Oz8PCP.md.png#height=250&id=NzNOS&originHeight=500&originWidth=386&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=193"></p><h3 id="🥪中断驱动I-x2F-O控制方式"><a href="#🥪中断驱动I-x2F-O控制方式" class="headerlink" title="🥪中断驱动I&#x2F;O控制方式"></a>🥪中断驱动I&#x2F;O控制方式</h3><p>当某进程要启动某个I&#x2F;O设备工作时，便由CPU向相应的设备控制器发出一条I&#x2F;O命令，然后立即返回继续执行原来的任务。仅当输完一个数据时，才需CPU花费极短的时间去做中断处理。<br><img src="https://i.imgtg.com/2023/07/16/Oz8tnb.md.png#height=250&id=ymTgr&originHeight=500&originWidth=442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=221"></p><h3 id="🥪DMA方式"><a href="#🥪DMA方式" class="headerlink" title="🥪DMA方式"></a>🥪DMA方式</h3><p>通过在I&#x2F;O设备和内存之间开启一个可以直接传输数据的通路，采用DMA控制器来控制一个数据块的传输，CPU只需在一个数据块传输开始阶段设置好传输所需的控制信息，并在传输结束阶段做进一步处理。<br><img src="https://i.imgtg.com/2023/07/16/Oz844l.png#height=228&id=ZrOTy&originHeight=455&originWidth=570&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=285"></p><h3 id="🥪通道控制方式"><a href="#🥪通道控制方式" class="headerlink" title="🥪通道控制方式"></a>🥪通道控制方式</h3><p>与DMA方式类似，也是一种内存和设备直接进行数据交换的方式。<br>在数据传送方向存放数据的内存始址及传送的数据块长度均由一个专门负责输入&#x2F;输出的硬件——通道来控制。<br>DMA方式每台设备至少需要一个DMA控制器，而通道控制方式中，一个通道可控制多台设备与内存进行数据交换。</p><h1 id="🥗缓冲管理"><a href="#🥗缓冲管理" class="headerlink" title="🥗缓冲管理"></a>🥗缓冲管理</h1><h2 id="🥙缓冲的引入"><a href="#🥙缓冲的引入" class="headerlink" title="🥙缓冲的引入"></a>🥙缓冲的引入</h2><ul><li><strong>原因</strong></li></ul><ol><li>缓和CPU和I&#x2F;O设备的矛盾</li><li>减少CPU中断的频率</li><li>提高CPU和I&#x2F;O设备的并行性</li></ol><h2 id="🥙单缓冲"><a href="#🥙单缓冲" class="headerlink" title="🥙单缓冲"></a>🥙单缓冲</h2><p><img src="https://i.imgtg.com/2023/07/16/Oz8D6g.png#id=rcX7p&originHeight=281&originWidth=1219&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🥙双缓冲（缓冲对换）"><a href="#🥙双缓冲（缓冲对换）" class="headerlink" title="🥙双缓冲（缓冲对换）"></a>🥙双缓冲（缓冲对换）</h2><p><img src="https://i.imgtg.com/2023/07/16/Oz8LkB.md.png#height=250&id=JRQQG&originHeight=500&originWidth=987&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=494"></p><h2 id="🥙循环缓冲"><a href="#🥙循环缓冲" class="headerlink" title="🥙循环缓冲"></a>🥙循环缓冲</h2><p><img src="https://i.imgtg.com/2023/07/16/Oz8Ems.md.png#height=250&id=g4poo&originHeight=500&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=433"></p><h2 id="🥙缓冲池（公用缓冲池）"><a href="#🥙缓冲池（公用缓冲池）" class="headerlink" title="🥙缓冲池（公用缓冲池）"></a>🥙缓冲池（公用缓冲池）</h2><p><img src="https://i.imgtg.com/2023/07/16/Oz8GYK.md.png#height=250&id=rqcAE&originHeight=500&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=415"></p><h1 id="🥗设备分配"><a href="#🥗设备分配" class="headerlink" title="🥗设备分配"></a>🥗设备分配</h1><h2 id="🥙基本概念"><a href="#🥙基本概念" class="headerlink" title="🥙基本概念"></a>🥙基本概念</h2><ul><li>独占设备——独占分配<ul><li>在一段时间内只允许一个用户（进程）使用的设备</li><li>系统一旦把该设备分配给某进程后，便让它独占直至释放。（可能会引起进程死锁）</li></ul></li><li>共享设备——共享分配<ul><li>在一段时间内允许多个进程同时访问的设备</li><li>共享设备必须是可寻址的和可随机访问的设备。<strong>磁盘</strong></li><li>共享设备不仅可以获得良好的设备利用率，也是实现文件和数据共享的物质基础。</li></ul></li><li>虚拟设备——共享分配<ul><li>通过某种技术将一台独占设备变换为能供若干用户共享的设备</li><li>可见其同时分配给多个用户，从而提高设备里利用率</li><li>SPOOLing技术</li></ul></li></ul><h2 id="🥙设备独立性"><a href="#🥙设备独立性" class="headerlink" title="🥙设备独立性"></a>🥙设备独立性</h2><p>设备独立性——用户程序独立于具体使用的物理设备</p><h3 id="🥪设备独立性的实现"><a href="#🥪设备独立性的实现" class="headerlink" title="🥪设备独立性的实现"></a>🥪设备独立性的实现</h3><p>——采用虚拟技术，编写应用程序时不考虑实际的物理设备</p><ul><li>物理设备：应用程序实际执行时，使用的特定类型设备</li><li>逻辑设备：是对一组具备相同功能物理设备的抽象</li></ul><p>逻辑设备到物理设备的映射——使用<strong>逻辑设备表LUT</strong></p><h3 id="🥪设备独立性的优点"><a href="#🥪设备独立性的优点" class="headerlink" title="🥪设备独立性的优点"></a><strong>🥪设备独立性的优点</strong></h3><ol><li>设备分配时的灵活性</li><li>易于实现I&#x2F;O重定向</li></ol><h2 id="🥙SPOOLing技术"><a href="#🥙SPOOLing技术" class="headerlink" title="🥙SPOOLing技术"></a>🥙SPOOLing技术</h2><p>——为缓和CPU的高速性与I&#x2F;O设备低速性之间的矛盾<br>——典型应用：共享打印机</p><ul><li>通过多道程序技术将一台物理CPU虚拟为多台逻辑CPU，从而允许多个用户共享一台主机</li><li>通过SPOOling技术便可将一台物理I&#x2F;O设备虚拟为多台逻辑I&#x2F;O设备，同样允许多个用户共享一台物理I&#x2F;O设备</li></ul><h3 id="🥪SPOOling基本组成"><a href="#🥪SPOOling基本组成" class="headerlink" title="🥪SPOOling基本组成"></a><strong>🥪SPOOling基本组成</strong></h3><ol><li>输入井和输出井</li><li>输入缓冲区和输出缓冲区</li><li>输入进程和输出进程</li></ol><h4 id="🌯输入井和输出井"><a href="#🌯输入井和输出井" class="headerlink" title="🌯输入井和输出井"></a>🌯输入井和输出井</h4><p>输入井是模拟脱机输入时的磁盘设备，用于暂存I&#x2F;O设备输入的数据。<br>输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</p><h4 id="🌯输入缓冲区和输出缓冲区"><a href="#🌯输入缓冲区和输出缓冲区" class="headerlink" title="🌯输入缓冲区和输出缓冲区"></a>🌯输入缓冲区和输出缓冲区</h4><p>为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟两个缓冲区；输入缓冲区和输出缓冲区。<br>输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。<br>输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</p><h3 id="🥪SPOOling特点"><a href="#🥪SPOOling特点" class="headerlink" title="🥪SPOOling特点"></a><strong>🥪SPOOling特点</strong></h3><ol><li>提高I&#x2F;O速度<ol><li>从对低速I&#x2F;O设备进行的I&#x2F;O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I&#x2F;O速度，缓和了CPU与低速I&#x2F;O设备速度不匹配的矛盾</li></ol></li><li>改造独占设备为共享设备<ol><li>因为在SPOOLing系统的系统中，实际上并没为任何进程分配设备，而知识在输入井或输出井中为进程分配一个存储区和建立一张I&#x2F;O请求表。这样，便把独占设备改造为共享设备。</li></ol></li><li>实现虚拟设备<ol><li>实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。</li></ol></li></ol><h1 id="🥗磁盘存储管理"><a href="#🥗磁盘存储管理" class="headerlink" title="🥗磁盘存储管理"></a>🥗磁盘存储管理</h1><h2 id="🥙磁盘工作原理"><a href="#🥙磁盘工作原理" class="headerlink" title="🥙磁盘工作原理"></a>🥙磁盘工作原理</h2><p>硬盘由多个盘片构成。</p><h2 id="🥙磁盘调度算法"><a href="#🥙磁盘调度算法" class="headerlink" title="🥙磁盘调度算法"></a>🥙磁盘调度算法</h2><p>磁盘是可供多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳调度算法，以使各进程对磁盘的平均访问时间最小。<br>由于在访问磁盘的时间中，主要是<strong>寻道时间</strong>，因此，磁盘调度的目标，是使磁盘的<strong>平均寻道时间最少</strong>。</p><h3 id="🥪先来先服务调度算法FCFS"><a href="#🥪先来先服务调度算法FCFS" class="headerlink" title="🥪先来先服务调度算法FCFS"></a><strong>🥪先来先服务调度算法FCFS</strong></h3><p>根据进程请求磁盘的先后次序进行调度。<br><img src="https://i.imgtg.com/2023/07/16/Oz8C1q.png#height=201&id=Tv0jI&originHeight=401&originWidth=841&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=421"></p><h3 id="🥪最短寻道时间优先调度算法SSTF"><a href="#🥪最短寻道时间优先调度算法SSTF" class="headerlink" title="🥪最短寻道时间优先调度算法SSTF"></a><strong>🥪最短寻道时间优先调度算法SSTF</strong></h3><p>要求访问的磁道，与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。<br><img src="https://i.imgtg.com/2023/07/16/OzXM8r.png#height=185&id=nrfh3&originHeight=369&originWidth=1098&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=549"></p><h3 id="🥪扫描算法SCAN"><a href="#🥪扫描算法SCAN" class="headerlink" title="🥪扫描算法SCAN"></a><strong>🥪扫描算法SCAN</strong></h3><p>在磁头移动方向上，且要求访问的磁道，与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。<br><img src="https://i.imgtg.com/2023/07/16/OzXqf1.png#height=183&id=pIAIM&originHeight=366&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=553"></p><h3 id="🥪循环扫描算法CSCAN"><a href="#🥪循环扫描算法CSCAN" class="headerlink" title="🥪循环扫描算法CSCAN"></a><strong>🥪循环扫描算法CSCAN</strong></h3><p>单向SCAN。只在一个磁头移动方向上满足磁道访问请求。要求访问的磁道，与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。<br><img src="https://i.imgtg.com/2023/07/16/OzXTKD.png#height=178&id=fnW6Q&originHeight=355&originWidth=1079&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=540"></p><h2 id="🥙磁盘高速缓存Disk-Cache"><a href="#🥙磁盘高速缓存Disk-Cache" class="headerlink" title="🥙磁盘高速缓存Disk Cache"></a>🥙磁盘高速缓存Disk Cache</h2><h2 id="🥙提高磁盘I-x2F-O速度的其他方法"><a href="#🥙提高磁盘I-x2F-O速度的其他方法" class="headerlink" title="🥙提高磁盘I&#x2F;O速度的其他方法"></a>🥙提高磁盘I&#x2F;O速度的其他方法</h2><ol><li>提前读</li><li>延迟写</li><li>优化物理块分布</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——存储管理</title>
      <link href="/2023/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/14/OzJoOL.png#id=RRlpM&originHeight=944&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍰程序的装入和链接"><a href="#🍰程序的装入和链接" class="headerlink" title="🍰程序的装入和链接"></a>🍰程序的装入和链接</h1><h2 id="🍦程序的装入"><a href="#🍦程序的装入" class="headerlink" title="🍦程序的装入"></a>🍦程序的装入</h2><h3 id="🍮绝对装入方式"><a href="#🍮绝对装入方式" class="headerlink" title="🍮绝对装入方式"></a>🍮绝对装入方式</h3><ul><li>编程时直接确定内存位置</li></ul><p>在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码——不适合多道程序设计</p><h3 id="🍮可重定位装入方式"><a href="#🍮可重定位装入方式" class="headerlink" title="🍮可重定位装入方式"></a>🍮可重定位装入方式</h3><ul><li><strong>虚拟技术</strong>：编程时使用逻辑地址，运行时使用物理地址，装入时，进行地址重定位</li></ul><p>根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，也称静态重定位。<br>当操作系统为程序分配一个以某地址为起始地址的连续主存区域后，重定位时将程序中指令或操作数的逻辑地址加上这个起始地址就得到了物理地址。——<strong>地址映射</strong></p><h4 id="🍹应用虚拟技术实现存储管理"><a href="#🍹应用虚拟技术实现存储管理" class="headerlink" title="🍹应用虚拟技术实现存储管理"></a>🍹应用虚拟技术实现存储管理</h4><ol><li>逻辑地址（相对地址，虚地址）</li></ol><p>——用户程序经过汇编或编译后形成目标代码，目标代码采用相对地址形式</p><ol><li>首地址为0</li><li>其余指令中地址以相对首地址的偏移为地址</li></ol><p><strong>不能用逻辑地址在内存中读取信息</strong></p><ol start="2"><li>物理地址（绝对地址，实地址）</li></ol><p>——在内存中存储单元的地址，可直接寻址</p><h4 id="🍹地址重定位"><a href="#🍹地址重定位" class="headerlink" title="🍹地址重定位"></a><strong>🍹地址重定位</strong></h4><ol><li><strong>静态地址重定位</strong></li></ol><p>当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换——一般在装入内存时由软件完成</p><ol start="2"><li><strong>动态地址重定位</strong></li></ol><p>在程序运行过程中要访问数据时再进行地址变换（即在逐条指令执行时完成地址映射。一般为了提高效率，此工作由硬件地址映射机制来完成。硬件支持，软硬件结合完成）——硬件上需要一对寄存器的支持</p><h3 id="🍮动态运行时装入方式"><a href="#🍮动态运行时装入方式" class="headerlink" title="🍮动态运行时装入方式"></a><strong>🍮动态运行时装入方式</strong></h3><p>编程时，使用逻辑地址，运行时使用物理地址；运行时进行地址重定位；<br>允许程序运行时在内存中移动位置，把装入模块装入到内存后所有地址都是相对地址，在程序执行过程中每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址。<br>依靠<strong>硬件地址变换机构</strong>。</p><h2 id="🍦程序的链接"><a href="#🍦程序的链接" class="headerlink" title="🍦程序的链接"></a>🍦程序的链接</h2><h3 id="🍮静态链接"><a href="#🍮静态链接" class="headerlink" title="🍮静态链接"></a><strong>🍮静态链接</strong></h3><p>在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开</p><ul><li>编程时，链接所有模块</li></ul><h3 id="🍮装入时动态链接"><a href="#🍮装入时动态链接" class="headerlink" title="🍮装入时动态链接"></a><strong>🍮装入时动态链接</strong></h3><p>将应用程序编译后所得到的一组目标模块在装入内存时采用边装入边链接的方式</p><ul><li>装入时，链接所有模块</li></ul><h3 id="🍮运行时动态链接"><a href="#🍮运行时动态链接" class="headerlink" title="🍮运行时动态链接"></a><strong>🍮运行时动态链接</strong></h3><p>知道程序运行过程中需要一些模块时，才对这些模块进行链接</p><ul><li>运行时，根据需要链接模块</li></ul><h1 id="🍰连续分配方式"><a href="#🍰连续分配方式" class="headerlink" title="🍰连续分配方式"></a>🍰连续分配方式</h1><h2 id="🍦单一连续分配存储管理方案"><a href="#🍦单一连续分配存储管理方案" class="headerlink" title="🍦单一连续分配存储管理方案"></a>🍦单一连续分配存储管理方案</h2><p>基本思想——内存分为两个区域：一个供操作系统使用，一个供用户使用<br>实现——设置基址寄存器、限界寄存器，要求：逻辑地址映射为物理地址后，物理地址必须在两者之间<br><img src="https://i.imgtg.com/2023/07/14/Ozmwwr.md.png#height=250&id=ZCRQK&originHeight=500&originWidth=923&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=462"></p><ul><li>优点：简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持</li><li>缺点：只能用于单用户、单任务的操作系统中，有内部碎片、存储器的利用率极低</li></ul><h2 id="🍦固定分区分配存储管理方案"><a href="#🍦固定分区分配存储管理方案" class="headerlink" title="🍦固定分区分配存储管理方案"></a>🍦固定分区分配存储管理方案</h2><ul><li>多道程序设计系统</li></ul><p>基本思想——</p><ol><li>OS初始化阶段，将用户区划分为若干固定大小的内存区域（分区）;</li><li>每个分区可放一个程序运行；</li><li>一个分区内的程序执行结束，可调入另一个程序执行；</li><li>划分为几个分区，则允许几个程序同时在内存运行；</li><li>分区大小和位置可不同</li></ol><p><img src="https://i.imgtg.com/2023/07/14/OzpaDG.md.png#height=250&id=fjR8v&originHeight=500&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=382"><br>实现——数据结构：分区说明表 算法：分区分配算法；分区回收算法<br><img src="https://i.imgtg.com/2023/07/14/Ozp5kI.png#height=194&id=NFnet&originHeight=387&originWidth=951&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=476"></p><ul><li>特点</li></ul><ol><li>最早的支持多道程序设计的存储管理方案</li><li>简单，现在仍在嵌入式系统中使用</li><li>“内零头”严重——分配给进程，而进程未用到的内存部分</li></ol><h2 id="🍦动态分区分配存储管理方案"><a href="#🍦动态分区分配存储管理方案" class="headerlink" title="🍦动态分区分配存储管理方案"></a>🍦动态分区分配存储管理方案</h2><p>基本思想——</p><ol><li>OS初始化阶段，将用户区划分为一个大的空白分区</li><li>每个程序运行时，划分出一个大小合适的分区</li><li>程序执行结束，其所在的分区撤消</li></ol><p><img src="https://i.imgtg.com/2023/07/14/OzpW56.md.png#height=250&id=g4c1O&originHeight=500&originWidth=906&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=453"><br>实现——</p><ol><li>数据结构<ol><li>空闲分区表</li></ol></li></ol><p><img src="https://i.imgtg.com/2023/07/14/OzpbKP.md.png#height=250&id=CDni0&originHeight=500&originWidth=825&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=413"></p><ol start="2"><li>空闲分区链</li></ol><p><img src="https://i.imgtg.com/2023/07/14/Ozpk0b.md.png#height=250&id=NhyKp&originHeight=500&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=377"></p><h3 id="🍮实现算法"><a href="#🍮实现算法" class="headerlink" title="🍮实现算法"></a><strong>🍮实现算法</strong></h3><ol><li>分区分配算法<ol><li><strong>首次适应算法</strong></li></ol></li></ol><p>按地址递增顺序排列空闲分区链；分配内存时，总是从低地址端开始扫描空闲区；找到的第一个大小合适的分区，就分割分配；否则失败。</p><ul><li>高址端有大空闲区概率大</li><li>低址端迅速被划分，碎片出现速度快<ol start="2"><li><strong>循环首次适应算法</strong></li></ol></li></ul><p>按地址递增顺序排列空闲分区链；设置当前指针；分配内存时，从指针所指位置开始扫描空闲区；找到的第一个大小合适的分区，就分割分配；否则失败。</p><ul><li>碎片分布均匀</li><li>高址端有大空闲区概率小<ol start="3"><li><strong>最佳适应算法</strong></li></ol></li></ul><p>按大小递增顺序排列空闲分区链；分配内存时，从链首开始扫描空闲区；找到的第一个大小合适的分区，就分割分配；否则失败。</p><ul><li>碎片迅速出现</li><li>“最佳”匹配<ol start="4"><li><strong>最坏适应算法</strong></li></ol></li></ul><p>按大小递减顺序排列空闲分区链；分配内存时，总是分配链首空闲区；否则失败。</p><ul><li>碎片出现最慢（分割后剩下的分区是最大的）</li><li>“最坏”匹配</li></ul><ol start="2"><li>分区回收算法</li></ol><p><img src="https://i.imgtg.com/2023/07/14/OzphHB.png#height=218&id=XEeCA&originHeight=435&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=419"></p><h3 id="🍮碎片问题"><a href="#🍮碎片问题" class="headerlink" title="🍮碎片问题"></a><strong>🍮碎片问题</strong></h3><p>经过一段时间的分配回收后，内存中存在很多很小的空闲块。它们每一个都很小，不足以满足分配要求；但其总和满足分配要求。这些空闲块被称为碎片造成<strong>存储资源的浪费</strong></p><h2 id="🍦可重定位分区分配存储管理方案"><a href="#🍦可重定位分区分配存储管理方案" class="headerlink" title="🍦可重定位分区分配存储管理方案"></a><strong>🍦可重定位分区分配存储管理方案</strong></h2><p>基本思想——</p><ol><li>采用动态分区分配方式</li><li>引入<strong>“紧凑”机制</strong>，合并小的碎片空闲区</li><li>使用动态地址重定位</li></ol><p><img src="https://i.imgtg.com/2023/07/14/Ozp1xK.md.png#height=250&id=CnzIr&originHeight=500&originWidth=886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=443"></p><h1 id="🍰基本分页存储管理方式"><a href="#🍰基本分页存储管理方式" class="headerlink" title="🍰基本分页存储管理方式"></a>🍰基本分页存储管理方式</h1><p>分区式分配存在的问题——碎片（内外“零头”）问题难以解决</p><h2 id="🍦基本设计思想"><a href="#🍦基本设计思想" class="headerlink" title="🍦基本设计思想"></a>🍦基本设计思想</h2><p><img src="https://i.imgtg.com/2023/07/14/Ozp7Ja.md.png#height=250&id=aVnWd&originHeight=500&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=362"></p><ul><li>页面——一个进程的逻辑地址空间分为若干个大小相等的片</li><li>块&#x2F;页框——把内存空间分为页面相同大小的若干个存储块</li></ul><p>为进程分配内存时，以块为单位将进程若干个页装入物理块中<br><img src="https://i.imgtg.com/2023/07/14/OzprBN.md.png#height=250&id=BTXBh&originHeight=500&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=373"></p><ul><li>页表——实现了从页号到物理块号的地址映射</li><li>地址变换机构——从逻辑地址到物理地址的转换</li><li>地址结构——页号，页内地址（偏移量）</li></ul><h2 id="🍦地址重定位"><a href="#🍦地址重定位" class="headerlink" title="🍦地址重定位"></a>🍦地址重定位</h2><h3 id="🍮基本地址变换机构"><a href="#🍮基本地址变换机构" class="headerlink" title="🍮基本地址变换机构"></a>🍮基本地址变换机构</h3><p><img src="https://i.imgtg.com/2023/07/14/OzpvMi.md.png#height=250&id=sins8&originHeight=500&originWidth=779&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=390"></p><ul><li>地址变换的过程<strong>访问2次内存</strong>——第一次查页表，第二次访问内存单元——解决方案：块表</li></ul><h3 id="🍮页表"><a href="#🍮页表" class="headerlink" title="🍮页表"></a><strong>🍮页表</strong></h3><ul><li>分页系统的核心数据结构</li></ul><ol><li>记录程序各页面所在的页框位置</li><li>支持进行地址重定位</li><li>实现页面访问控制</li><li>存储保护：限制程序在操作系统指定的内存区域内运行</li></ol><h3 id="🍮页表和块表"><a href="#🍮页表和块表" class="headerlink" title="🍮页表和块表"></a><strong>🍮页表和块表</strong></h3><p>页表指出逻辑地址中的页号与所占主存块号的对应关系。<br>作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。<br>块表指存放在高速缓冲存储器的部分页表。<br>由于采用页表做地址转换，读写内存数据时要访问两次CPU，有了块表只要访问一次CPU，加速查找并提高指令执行速度。</p><h3 id="🍮具有快表的地址变换机构"><a href="#🍮具有快表的地址变换机构" class="headerlink" title="🍮具有快表的地址变换机构"></a>🍮具有快表的地址变换机构</h3><p><img src="https://i.imgtg.com/2023/07/14/Ozpy1X.md.png#height=250&id=LkEGs&originHeight=500&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=385"></p><ul><li>块表</li></ul><ol><li>设置在CPU内部</li><li>有并行查找能力</li><li>暂存当前正在使用的页表项</li></ol><h2 id="🍦两级和多级页表"><a href="#🍦两级和多级页表" class="headerlink" title="🍦两级和多级页表"></a>🍦两级和多级页表</h2><h3 id="🍮两级页表"><a href="#🍮两级页表" class="headerlink" title="🍮两级页表"></a>🍮两级页表</h3><p><img src="https://i.imgtg.com/2023/07/14/OzpgHt.png#height=234&id=Qg78I&originHeight=468&originWidth=873&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=437"><br>地址结构——外层页号P1 页号P2 页内地址&#x2F;偏移量W</p><h1 id="🍰基本分段存储管理方式"><a href="#🍰基本分段存储管理方式" class="headerlink" title="🍰基本分段存储管理方式"></a>🍰基本分段存储管理方式</h1><p>分页系统存在的问题：信息共享和保护困难；编程不便</p><h2 id="🍦基本设计思想-1"><a href="#🍦基本设计思想-1" class="headerlink" title="🍦基本设计思想"></a>🍦基本设计思想</h2><p><img src="https://i.imgtg.com/2023/07/14/OzpRlU.md.png#height=375&id=dsSbo&originHeight=500&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=552"></p><ul><li><strong>分段</strong></li></ul><ol><li>分段是一段有意义的信息集合</li><li>分段的划分由程序员完成</li><li>分段的长度不定</li><li>指令不存在跨分段情况</li></ol><ul><li><strong>段表</strong></li></ul><p><img src="https://i.imgtg.com/2023/07/14/OzpDZv.md.png#height=375&id=NhmXJ&originHeight=500&originWidth=721&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=541"><br>段表结构：段号 段基址（段在内存的起始地址） 段长 </p><ul><li>段表<strong>存储在内存</strong></li><li>段表起始地址保存在PCB中</li><li><strong>地址结构</strong></li></ul><p>段号 段内地址&#x2F;偏移量W</p><h2 id="🍦地址重定位-1"><a href="#🍦地址重定位-1" class="headerlink" title="🍦地址重定位"></a>🍦地址重定位</h2><h3 id="🍮分段地址变换及存储保护机构"><a href="#🍮分段地址变换及存储保护机构" class="headerlink" title="🍮分段地址变换及存储保护机构"></a>🍮分段地址变换及存储保护机构</h3><p><img src="https://i.imgtg.com/2023/07/14/OzpHcq.md.png#height=375&id=TkaNY&originHeight=500&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=582"></p><h3 id="🍮段表的作用"><a href="#🍮段表的作用" class="headerlink" title="🍮段表的作用"></a>🍮段表的作用</h3><ol><li>记录程序各分段所在的内存位置</li><li>支持进行地址重定位</li><li>实现分段访问控制</li><li>存储保护：限制程序在操作系统指定的内存区域内运行</li></ol><h2 id="🍦分段和分页的区别"><a href="#🍦分段和分页的区别" class="headerlink" title="🍦分段和分页的区别"></a>🍦分段和分页的区别</h2><ul><li><strong>都离散分配方式，通过地址映射实现地址变换</strong></li></ul><p><img src="https://i.imgtg.com/2023/07/14/OzpQLM.png#id=qyELr&originHeight=340&originWidth=1020&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🍦信息共享"><a href="#🍦信息共享" class="headerlink" title="🍦信息共享"></a>🍦信息共享</h2><p>在每个进程中，配局部数据区，执行中可能变得部分——数据区修改<br>不改变共享的代码</p><ol><li>分页信息共享</li><li>分段信息共享</li></ol><h1 id="🍰段页式存储管理方式"><a href="#🍰段页式存储管理方式" class="headerlink" title="🍰段页式存储管理方式"></a>🍰段页式存储管理方式</h1><p>分段系统存在的问题——碎片（内外“零头”）问题难以解决<br>解决方案(<strong>分段+分页</strong>)：</p><ul><li>分页系统：</li></ul><p>负责解决主存分配问题：内存按页分配</p><ul><li>分段系统：</li></ul><p>负责解决逻辑地址空间管理问题：按段为应用程序分配逻辑地址空间</p><h2 id="🍦基本设计思想-2"><a href="#🍦基本设计思想-2" class="headerlink" title="🍦基本设计思想"></a>🍦基本设计思想</h2><p><img src="https://i.imgtg.com/2023/07/14/OzpSXG.md.png#height=375&id=uzXb5&originHeight=500&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=549"></p><h3 id="🍮段表和页表"><a href="#🍮段表和页表" class="headerlink" title="🍮段表和页表"></a>🍮段表和页表</h3><p><img src="https://i.imgtg.com/2023/07/14/OzpdJI.png#id=VIDUQ&originHeight=423&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li>访问段表——页表起始</li><li>访问内存页表——物理块号得到地址</li><li>取指令&#x2F;数据</li></ol><h3 id="🍮地址结构"><a href="#🍮地址结构" class="headerlink" title="🍮地址结构"></a>🍮地址结构</h3><p>段号S 页号P 页内地址&#x2F;偏移量W</p><h2 id="🍦地址变换"><a href="#🍦地址变换" class="headerlink" title="🍦地址变换"></a>🍦地址变换</h2><p><img src="https://i.imgtg.com/2023/07/14/OzpYTF.png#id=WO6bZ&originHeight=440&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍰段页式存储管理方式-1"><a href="#🍰段页式存储管理方式-1" class="headerlink" title="🍰段页式存储管理方式"></a>🍰段页式存储管理方式</h1><h2 id="🍦理论基础"><a href="#🍦理论基础" class="headerlink" title="🍦理论基础"></a>🍦理论基础</h2><h3 id="🍮程序运行基本特征"><a href="#🍮程序运行基本特征" class="headerlink" title="🍮程序运行基本特征"></a>🍮程序运行基本特征</h3><p>局部性原理：在一段时间内一个程序的执行往往呈现出高度的局部性</p><ol><li>时间局部性——一条指令被执行了，则在不久的将来它可能再被执行；在一段时间内，访问的代码范围是有限的</li><li>空间局部性——若某一存储单元被使用，在一定时间内，与该存储单元相邻的单元可能被使用</li></ol><h2 id="🍦虚拟存储器概念"><a href="#🍦虚拟存储器概念" class="headerlink" title="🍦虚拟存储器概念"></a>🍦虚拟存储器概念</h2><p><strong>具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</strong><br>逻辑容量——内存容量与外存容量之和</p><h3 id="🍮特征"><a href="#🍮特征" class="headerlink" title="🍮特征"></a>🍮特征</h3><ol><li>多次性</li><li>对换性</li><li>虚拟性</li></ol><h3 id="🍮实现方法"><a href="#🍮实现方法" class="headerlink" title="🍮实现方法"></a>🍮实现方法</h3><ol><li>分页请求系统（页式虚拟存储器，请求分页系统）</li></ol><p>在基本分页系统基础上，增加以页面为单位的请求调入和自动置换功能 </p><ol start="2"><li>请求分段系统（段式虚拟存储器，分段请求系统）</li></ol><p>在基本分段系统基础上，增加以分段为单位的请求调入和自动置换功能 </p><ol start="3"><li>段页式虚拟存储器</li></ol><p>在段页式系统基础上，增加以分页为单位的请求调入和自动置换功能</p><h1 id="🍰请求分页管理方式"><a href="#🍰请求分页管理方式" class="headerlink" title="🍰请求分页管理方式"></a>🍰请求分页管理方式</h1><p><img src="https://i.imgtg.com/2023/07/14/OzpfZ6.md.png#height=375&id=AGUwf&originHeight=500&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=615"></p><ul><li>置换以页面为单位</li></ul><h2 id="🍦请求分页的硬件支持"><a href="#🍦请求分页的硬件支持" class="headerlink" title="🍦请求分页的硬件支持"></a>🍦请求分页的硬件支持</h2><h3 id="🍮页表机制"><a href="#🍮页表机制" class="headerlink" title="🍮页表机制"></a>🍮页表机制</h3><p>逻辑地址变换为物理地址<br><img src="https://i.imgtg.com/2023/07/14/OzpjOb.png#height=214&id=yjUuP&originHeight=428&originWidth=842&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=421"><br>状态位P——该页是否已经调入内存<br>访问字段A——本页在一段时间内被访问的次数，多久没有被访问（置换出去）<br>修改位M——调入内存后是否被修改</p><h3 id="🍮缺页中断机制"><a href="#🍮缺页中断机制" class="headerlink" title="🍮缺页中断机制"></a>🍮缺页中断机制</h3><p>——要访问的指令不在内存中，请求调入</p><ol><li>指令执行期间：发出中断并相应处理中断，返回</li><li>一条指令可能法出多次缺页中断</li></ol><h3 id="🍮地址重定位"><a href="#🍮地址重定位" class="headerlink" title="🍮地址重定位"></a>🍮地址重定位</h3><p><img src="https://i.imgtg.com/2023/07/14/Ozpuzs.md.png#id=VEiMb&originHeight=500&originWidth=644&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>基本分页管理地址变换过程+产生缺页中断请求调页</p><h2 id="🍦内存分配策略和算法"><a href="#🍦内存分配策略和算法" class="headerlink" title="🍦内存分配策略和算法"></a>🍦内存分配策略和算法</h2><h3 id="🍮最小物理块个数"><a href="#🍮最小物理块个数" class="headerlink" title="🍮最小物理块个数"></a>🍮最小物理块个数</h3><p>——由机器指令的结构决定</p><h3 id="🍮物理块分配策略"><a href="#🍮物理块分配策略" class="headerlink" title="🍮物理块分配策略"></a>🍮物理块分配策略</h3><ol><li>固定分配局部置换<ol><li>为进程分配物理块</li><li>在进程运行期间，物理块个数不变</li><li>新页面，只能置换入该进程已经分配的物理块</li></ol></li><li>可变分配全局置换<ol><li>为进程分配物理块</li><li>在进程运行期间，物理块个数随时变化</li><li>新页面，在全局范围内置换物理块（OS空闲物理块队列）</li></ol></li><li>可变分配局部置换<ol><li>为进程分配物理块</li><li>在进程运行期间，物理块个数可变化</li><li>新页面，在该进程已经分配物理块内置换</li><li>引入缺页率，保证：低限阈值 &lt;&#x3D; 缺页率 &lt;&#x3D; 高限阈值</li></ol></li></ol><h3 id="🍮物理块分配算法"><a href="#🍮物理块分配算法" class="headerlink" title="🍮物理块分配算法"></a>🍮物理块分配算法</h3><ol><li>平均分配</li><li>按比例分配</li><li>加权分配</li></ol><h2 id="🍦页面策略"><a href="#🍦页面策略" class="headerlink" title="🍦页面策略"></a>🍦页面策略</h2><p><img src="https://i.imgtg.com/2023/07/14/Ozp39a.md.png#id=u2swF&originHeight=500&originWidth=857&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🍦页面置换算法"><a href="#🍦页面置换算法" class="headerlink" title="🍦页面置换算法"></a>🍦页面置换算法</h2><p>页面置换&#x2F;淘汰：Cache更新—<strong>预测未来的页面访问情况</strong></p><h3 id="🍮最佳置换算法-OPT算法"><a href="#🍮最佳置换算法-OPT算法" class="headerlink" title="🍮最佳置换算法(OPT算法)"></a>🍮最佳置换算法(OPT算法)</h3><ol><li>基本思想<ol><li>选择以后再也不用的页面</li><li>没有的话，选择以后最长时间不用的页面</li></ol></li><li>实现<ol><li>无法实现，页面访问顺序无法预知</li></ol></li></ol><h3 id="🍮先进先出算法-FIFO算法"><a href="#🍮先进先出算法-FIFO算法" class="headerlink" title="🍮先进先出算法(FIFO算法)"></a>🍮先进先出算法(FIFO算法)</h3><ol><li>基本思想<ol><li>基于程序的顺序执行特点</li><li>选择到达内存最早的页面，予以淘汰</li></ol></li><li>实现<ol><li>页面在内存中按时间排序</li></ol></li></ol><h3 id="🍮最久未使用页面置换算法-LRU算法"><a href="#🍮最久未使用页面置换算法-LRU算法" class="headerlink" title="🍮最久未使用页面置换算法(LRU算法)"></a>🍮最久未使用页面置换算法(LRU算法)</h3><ol><li>基本思想<ol><li>基于程序运行的局部性原理</li><li>选择最近以来最久未使用的页面，予以淘汰</li></ol></li><li>实现<ol><li>移位寄存器，栈</li></ol></li></ol><h3 id="🍮Clock置换算法"><a href="#🍮Clock置换算法" class="headerlink" title="🍮Clock置换算法"></a>🍮Clock置换算法</h3><h1 id="🍰请求分段存储管理方式"><a href="#🍰请求分段存储管理方式" class="headerlink" title="🍰请求分段存储管理方式"></a>🍰请求分段存储管理方式</h1><p><img src="https://i.imgtg.com/2023/07/14/OzpwTS.md.png#height=375&id=yhR6F&originHeight=500&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=578"></p><h2 id="🍦硬件支持"><a href="#🍦硬件支持" class="headerlink" title="🍦硬件支持"></a>🍦硬件支持</h2><h3 id="🍮段表机制"><a href="#🍮段表机制" class="headerlink" title="🍮段表机制"></a>🍮段表机制</h3><p><img src="https://i.imgtg.com/2023/07/14/OzJMvN.png#id=M0XTh&originHeight=447&originWidth=1020&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🍦分段共享与保护"><a href="#🍦分段共享与保护" class="headerlink" title="🍦分段共享与保护"></a>🍦分段共享与保护</h2><h3 id="🍮数据结构"><a href="#🍮数据结构" class="headerlink" title="🍮数据结构"></a>🍮数据结构</h3><ol><li>共享段表（所有进程共享）<ol><li>整个系统设置1张共享段表</li><li>记录：分段信息，共享该分段进程的信息(存取控制，进程数量count，段号)。</li></ol></li><li>进程段表（私有段表）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极速救援——内涝问题解决专家</title>
      <link href="/2023/07/13/%E6%9E%81%E9%80%9F%E6%95%91%E6%8F%B4%E2%80%94%E2%80%94%E5%86%85%E6%B6%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%93%E5%AE%B6/"/>
      <url>/2023/07/13/%E6%9E%81%E9%80%9F%E6%95%91%E6%8F%B4%E2%80%94%E2%80%94%E5%86%85%E6%B6%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%93%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>省级学科竞赛研究项目-极速救援——内涝问题解决专家</strong><br>:::success<br>针对大气气流季节性异常，短时内大量降雨所造成得城市排涝系统瘫痪的情况，团队提出系统化的内涝问题解决方案。作为项目成员，负责设计城市监测预警抢险系统的前端界面并对全国气象数据进行可视化设计。<br>:::</li></ul><h1 id="🍜极速救援——全国气象数据采集及可视化系统"><a href="#🍜极速救援——全国气象数据采集及可视化系统" class="headerlink" title="🍜极速救援——全国气象数据采集及可视化系统"></a>🍜极速救援——全国气象数据采集及可视化系统</h1><h2 id="🍥项目介绍"><a href="#🍥项目介绍" class="headerlink" title="🍥项目介绍"></a>🍥项目介绍</h2><p>通过爬取中国天气网的各个城市数据，然后保存到自己的数据库，然后通过python以及echart技术对这些数据进行初步分析以及可视化。项目采用B&#x2F;S架构，通过浏览器即可访问。完善版本实现了所有可视化与后台数据进行关联，并且爬虫也进行了优化处理。</p><h2 id="🍥项目技术"><a href="#🍥项目技术" class="headerlink" title="🍥项目技术"></a>🍥项目技术</h2><ul><li>python爬虫技术</li><li>Flask后端框架</li><li>python、mysql数据库</li><li>echart大数据可视化</li><li>layui后台管理前端框架</li></ul><h2 id="🍥分类说明"><a href="#🍥分类说明" class="headerlink" title="🍥分类说明"></a>🍥分类说明</h2><h3 id="🍣空气质量指数AQI"><a href="#🍣空气质量指数AQI" class="headerlink" title="🍣空气质量指数AQI"></a>🍣空气质量指数AQI</h3><ol><li>0-50：良好</li><li>51-100：中等</li><li>101-150：偏差，对敏感人群不健康</li><li>151-200：差，不健康</li><li>201-300：极差，非常不健康</li><li>300+：有毒</li></ol><h3 id="🍣风力等级"><a href="#🍣风力等级" class="headerlink" title="🍣风力等级"></a>🍣风力等级</h3><p><img src="https://i.imgtg.com/2023/07/16/OzfuSi.md.png#height=375&id=c6WBg&originHeight=500&originWidth=510&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=383"></p><h3 id="🍣数据库字段说明"><a href="#🍣数据库字段说明" class="headerlink" title="🍣数据库字段说明"></a>🍣数据库字段说明</h3><p><img src="https://i.imgtg.com/2023/07/16/OzfICX.md.png#height=375&id=Nj5sV&originHeight=500&originWidth=1356&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1017"></p><h2 id="🍥爬虫介绍"><a href="#🍥爬虫介绍" class="headerlink" title="🍥爬虫介绍"></a>🍥爬虫介绍</h2><h3 id="🍣自动爬虫"><a href="#🍣自动爬虫" class="headerlink" title="🍣自动爬虫"></a>🍣自动爬虫</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬虫自动运行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">job_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;爬虫任务执行开始！&quot;</span>)</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line">    executor.submit(online())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    scheduler = APScheduler()</span><br><span class="line">    scheduler.init_app(app)</span><br><span class="line">    <span class="comment"># 定时任务，每隔10s执行1次</span></span><br><span class="line">    scheduler.add_job(func=job_function, trigger=<span class="string">&#x27;interval&#x27;</span>, seconds=<span class="number">1800</span>, <span class="built_in">id</span>=<span class="string">&#x27;my_cloud_spider_id&#x27;</span>)</span><br><span class="line">    scheduler.start()</span><br></pre></td></tr></table></figure><p>项目启动，定时间隔半小时爬取一次数据</p><h3 id="🍣手动爬虫"><a href="#🍣手动爬虫" class="headerlink" title="🍣手动爬虫"></a>🍣手动爬虫</h3><p>通过后台控制台，点击启动爬虫，后台静默爬取实时天气数据，智能跳过已经获取到的数据。</p><h2 id="🍥软件主界面"><a href="#🍥软件主界面" class="headerlink" title="🍥软件主界面"></a>🍥软件主界面</h2><p><img src="https://i.imgtg.com/2023/07/16/OzlM6j.png#id=jklnO&originHeight=1491&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://i.imgtg.com/2023/07/16/Ozlz81.md.png#id=PRnRf&originHeight=500&originWidth=983&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1689487876534-a29ff896-29a4-4d2d-bd10-d21a14f704d2.png#averageHue=%23dfdfdf&clientId=u6feb7890-7c8a-4&from=paste&height=655&id=u048930e0&originHeight=1310&originWidth=2560&originalType=binary&ratio=1.600000023841858&rotation=0&showTitle=false&size=257086&status=done&style=none&taskId=u2cb33dc5-fdd9-4352-bc0e-62904df1af8&title=&width=1280" alt="image.png"></p><h2 id="🍥项目亮点"><a href="#🍥项目亮点" class="headerlink" title="🍥项目亮点"></a>🍥项目亮点</h2><ul><li>项目利用Python和Flask后台框架搭建可视化网站，使用requests库对weather网站进行爬取，爬取所给城市信息的气象实时情况，包括天气、湿度、空气质量、风向和风级等信息，网站后端设置每半小时自动爬取该网站相关数据，将所爬取到的数据存储后端数据库的weather表中。利用echart可视化将所爬到的信息进行可视化效果在前端显示。</li><li>同时设置了气象综合分析平台的管理系统，用户登录即可手动对信息进行爬取。与此同时，也可以对登录用户信息、所爬取的具体信息、爬取日志进行增删改查。</li></ul><h1 id="🍜极速救援——城市监测预警抢险系统前端界面"><a href="#🍜极速救援——城市监测预警抢险系统前端界面" class="headerlink" title="🍜极速救援——城市监测预警抢险系统前端界面"></a>🍜极速救援——城市监测预警抢险系统前端界面</h1><p><img src="https://i.imgtg.com/2023/07/16/OzlZHB.png#id=mJ3wP&originHeight=1600&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>基于HTML、CSS和JavaScript制作城市内涝监测预警抢险系统的前端界面<br>内容部分包括以下几个区域：</p><ul><li>重点易内涝检测区域，显示了降水量和降雨强度的信息。</li><li>年降水量情况区域，使用了雷达图展示数据。</li><li>各地区积水量情况区域，使用了柱状图展示数据。</li><li>全国具体地区积水情况，使用地图和详细信息展示数据。</li><li>内涝情况重点地区。</li><li>主要地区水流量，使用折线图展示数据。</li></ul><p>可视化部分利用echarts进行呈现完成整个网页的数据呈现，前端部分可与后端相关爬虫信息或传感器测量数据结合，形成完整城市内涝监测预警抢险系统。</p>]]></content>
      
      
      <categories>
          
          <category> 科研项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统课程设计——学籍管理系统</title>
      <link href="/2023/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="🥁系统开发概念"><a href="#🥁系统开发概念" class="headerlink" title="🥁系统开发概念"></a>🥁系统开发概念</h1><p>在计算机技术高速发展的今天，越来越多的管理平台采用了信息系统，并成为其不可或缺的一部分。研究表明，利用信息系统管理与工作比传统方式可以提高数倍的工作效率，这将大幅减少各项人力与物资消耗，从而能使多余的资源投入到更有用的地方。<br>学籍管理系统是针对高校学生学籍信息进行管理的一套软件系统。它包括学生基本信息、专业变更、奖惩情况、课程计划、课程成绩、体检情况等相关实体，能够实现对这些实体的查询、增加、修改、删除统计等功能，旨在提高学籍管理效率和数据准确性，方便管理员和普通用户进行学籍相关操作和决策。</p><h1 id="🥁系统规划"><a href="#🥁系统规划" class="headerlink" title="🥁系统规划"></a>🥁系统规划</h1><h2 id="🎯设计目的和要求"><a href="#🎯设计目的和要求" class="headerlink" title="🎯设计目的和要求"></a>🎯设计目的和要求</h2><h3 id="🏸设计目的"><a href="#🏸设计目的" class="headerlink" title="🏸设计目的"></a>🏸设计目的</h3><p>通过数据库课程设计，来进一加深对数据库开发与应用的了解，掌握SQL语句与SQL服务的要领，从而达到让我们实践的目的。<br>通过数据库系统课程的学习可以知道数据库课程设计数据库系统开发步骤的要领有：需求分析，概念设计，逻辑结构设计，物理结构设计，数据库实施阶段，由此我们可以展开以下高校学籍管理系统的设计。</p><h3 id="🏸设计要求"><a href="#🏸设计要求" class="headerlink" title="🏸设计要求"></a>🏸设计要求</h3><p>学籍管理系统的设计要求如下：</p><ol><li><strong>功能性要求：</strong><ol><li>学生信息管理：能够查询、录入、修改、删除学生的基本信息，包括个人信息（学号、姓名、性别、学院、专业）、生日和籍贯等。</li><li>学生奖惩情况管理：能够查询当前学生的奖惩情况，包括该学生的姓名、学号和获奖时间、奖励和获奖原因，惩罚情况同理。</li><li>学籍信息管理：能够查询学生的学籍状态和对应的变更时间和变更情况。</li><li>学生成绩管理：能够查询、录入、修改和删除学生的课程成绩以及考试情况，具体包括学生学号、姓名、性别、学院、专业以及所选的课程、当前课程对应的学分、考试情况以及对应的分数。</li><li>学生体检情况管理：能够查询、录入、修改和删除学生的体检信息，包括学生的学号、姓名、性别、身高、体重、肺活量、跳远、坐位体前屈、1000米、800米、仰卧起坐和引体向上的对应成绩。</li><li>数据可视化：为了增加系统的界面友好性，对全体学生的籍贯、专业、奖惩情况以及学籍状态进行了数据可视化。</li></ol></li><li><strong>可靠性要求：</strong><ol><li>数据完整性：保证学生学籍信息的完整性，避免数据丢失或破坏。</li><li>数据精确性：确保学生信息、课程信息和成绩信息的准确性，避免数据错误或不一致。</li><li>数据安全性：采取安全措施保护学生的个人隐私和敏感信息，设计不同用户的登录模式，根据不同的用户修改其对该系统的权限。</li></ol></li><li><strong>可扩展性要求：</strong><ol><li>模块化设计：系统以模块化方式构建，各个功能模块之间解耦合，方便后续功能的添加和修改。</li></ol></li><li><strong>用户界面友好性要求：</strong><ol><li>界面设计：用户界面应简洁、直观、美观，符合用户的使用习惯，提供良好的用户体验。</li><li>操作易用性：系统操作流程简单明了，用户能够快速上手，减少使用门槛和错误操作的可能性。</li></ol></li><li><strong>易维护性要求：</strong><ol><li>代码可读性：代码结构清晰、注释完善、命名规范，提高代码可读性和可维护性。</li><li>文档说明：提供详细的系统使用手册和开发文档，方便后续维护和技术支持人员的工作。</li></ol></li></ol><h2 id="🎯设计环境和工具"><a href="#🎯设计环境和工具" class="headerlink" title="🎯设计环境和工具"></a>🎯设计环境和工具</h2><p>根据设计目的和要求，如下所示选用合适的平台和架构进行设计：</p><table><thead><tr><th>数据库</th><th>MySQL</th></tr></thead><tbody><tr><td>数据库管理工具</td><td>Navicat 15</td></tr><tr><td>后端服务器</td><td>Node.js</td></tr><tr><td>前端技术栈</td><td>Vue ElementUi</td></tr></tbody></table><h1 id="🥁需求分析"><a href="#🥁需求分析" class="headerlink" title="🥁需求分析"></a>🥁需求分析</h1><p>根据设计要求，提过网上查阅、内部讨论等手段，明确学生学籍管理系统的各种需求，包括：数据需求、功能需求及其他需求。</p><h2 id="🎯用户需求说明"><a href="#🎯用户需求说明" class="headerlink" title="🎯用户需求说明"></a>🎯用户需求说明</h2><h3 id="🏸功能需求"><a href="#🏸功能需求" class="headerlink" title="🏸功能需求"></a>🏸功能需求</h3><p>学籍管理系统的功能需求包括管理员和普通用户对功能的需求：<br>管理员对功能的需求：管理员权限最大，可以对学生的基本信息、奖惩情况、学籍信息、成绩、体检信息等进行增删改查，同时可以对管理员和用户信息进行查询和修改。<br>普通用户对功能的需求：普通用户只能利用系统对学生的基本信息、奖惩情况、学籍信息、成绩等相关信息进行查询，而不能进行修改等操作。</p><h3 id="🏸数据需求"><a href="#🏸数据需求" class="headerlink" title="🏸数据需求"></a>🏸数据需求</h3><p>为了区分不同的用户，定义对应的数据表。</p><h2 id="🎯系统需求说明"><a href="#🎯系统需求说明" class="headerlink" title="🎯系统需求说明"></a>🎯系统需求说明</h2><h3 id="🏸功能需求-1"><a href="#🏸功能需求-1" class="headerlink" title="🏸功能需求"></a>🏸功能需求</h3><ol><li>学生基本信息模块<ol><li>新生录入：系统应该提供一个界面或表单，用于录入学生的基本信息，并验证输入数据的有效性和完整性。</li><li>学生信息查看：可以通过页面交互查看已经录入的学生信息。</li><li>学生信息修改：管理员可以修改学生的基本信息，并且对部分信息的修改应有相关权限。</li><li>学生信息删除：管理员可以删除指定学生的信息。</li><li>学生信息查找：可以通过按学号搜索或者按姓名查找来查找指定学生、并支持模糊查找。</li></ol></li><li>成绩管理模块<ol><li>学生成绩修改：支持对已经录入的学生成绩和考试状态修改。</li><li>学生成绩查找：支持按名字、学号、课程查找学生成绩。</li></ol></li><li>学籍信息管理模块<ol><li>学籍变更情况查看：支持查看学生的学籍变更情况。</li></ol></li><li>学生体检情况模块<ol><li>体检情况查看：支持查看学生的各项体检信息。</li><li>体检信息的查询：支持查看学生的学籍变更情况。</li><li>体检情况修改：支持修改学生的体检数据。</li><li>新增学生体检情况：支持对新生表中的学生增加体检情况。</li></ol></li></ol><h1 id="🥁数据库逻辑设计"><a href="#🥁数据库逻辑设计" class="headerlink" title="🥁数据库逻辑设计"></a>🥁数据库逻辑设计</h1><h2 id="🎯E-R图"><a href="#🎯E-R图" class="headerlink" title="🎯E-R图"></a>🎯E-R图</h2><p>根据需求分析阶段中所总结出的实体与联系，绘制相应模块的E-R图如下所示。</p><h3 id="🏸学生信息E-R图"><a href="#🏸学生信息E-R图" class="headerlink" title="🏸学生信息E-R图"></a>🏸学生信息E-R图</h3><p>该E-R图展示了学生信息模块的设计思路，包括学生基本信息、学院信息、专业信息、奖励、奖励信息、惩罚、惩罚信息这几个模块，同时该E-R图中也给出了实体间的联系情况与转换规则：学院信息和学生信息之间是一对多的关系，专业信息和学生信息之间也是一对多的关系，学生信息和惩罚是一对多的关系，学生信息和奖励也是一对多的关系，奖励和奖励信息以及惩罚和惩罚信息之间都是一对一的关系。<br><img src="https://i.imgtg.com/2023/07/18/OFbEqN.md.png#id=DLiqt&originHeight=500&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🏸学籍信息E-R图"><a href="#🏸学籍信息E-R图" class="headerlink" title="🏸学籍信息E-R图"></a>🏸学籍信息E-R图</h3><p>该E-R图展示了学籍信息模块的设计思路，包括学籍信息和学籍改变这两个模块，同时该E-R图中也给出了实体间的联系情况与转换规则：学籍信息和学籍改变之间是一对一的关系。<br><img src="https://i.imgtg.com/2023/07/18/OFbHVS.md.png#id=V8JlU&originHeight=500&originWidth=1002&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🏸学生成绩E-R图"><a href="#🏸学生成绩E-R图" class="headerlink" title="🏸学生成绩E-R图"></a>🏸学生成绩E-R图</h3><p>该E-R图展示了学生成绩模块的设计思路，包括成绩信息和课程信息这两个模块，同时该E-R图中也给出了实体间的联系情况与转换规则：成绩信息和课程信息之间是一对一的关系。<br><img src="https://i.imgtg.com/2023/07/18/OFbDma.md.png#id=xrUP0&originHeight=500&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🏸体检信息E-R图"><a href="#🏸体检信息E-R图" class="headerlink" title="🏸体检信息E-R图"></a>🏸体检信息E-R图</h3><p>该E-R图展示了用户信息模块的设计思路，包括体检信息和学生信息这两个模块，同时该E-R图中也给出了实体间的联系情况与转换规则：体检信息和学生信息之间是一对一的关系。（在验收与老师沟通的过程中，我们也意识到了这部分需求分析的不足，体检信息和学生信息应为一对多的关系）。<br><img src="https://i.imgtg.com/2023/07/18/OFbR2s.md.png#id=ADj68&originHeight=500&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🏸用户信息E-R图"><a href="#🏸用户信息E-R图" class="headerlink" title="🏸用户信息E-R图"></a>🏸用户信息E-R图</h3><p>该E-R图展示了用户信息模块的设计思路。<br><img src="https://i.imgtg.com/2023/07/18/OFb4bK.md.png#height=250&id=f0rNp&originHeight=500&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=404"></p><h2 id="🎯数据库的逻辑结构设计"><a href="#🎯数据库的逻辑结构设计" class="headerlink" title="🎯数据库的逻辑结构设计"></a>🎯数据库的逻辑结构设计</h2><p>将E-R图转换为关系模型实际上就是要将实体型、实体的属性和实体型之间的联系转换为关系模式，这种转换一般遵循如下原则：一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码。现将概念结构设计阶段设计好的基本E-R图转换为关系模型，如下。</p><h3 id="🏸关系模式"><a href="#🏸关系模式" class="headerlink" title="🏸关系模式"></a>🏸关系模式</h3><p>其中，主码使用加粗字体表示，外码使用下划线并注明。</p><ol><li><strong>学生信息关系模式</strong><ol><li>学生信息（<strong>学号</strong>，姓名，性别，学院号，专业号，生日，籍贯）</li><li>学院信息（<strong>学院号</strong>，学院名）</li><li>专业信息（<strong>专业号</strong>，专业名）</li><li>奖励信息（<strong>ID</strong>，学号，奖励等级，奖励时间，奖励描述）</li><li>惩罚信息（<strong>ID</strong>，学号，惩罚等级，惩罚时间，惩罚描述）</li><li>奖励关系（<strong>奖励等级</strong>，奖励）</li><li>惩罚关系（<strong>惩罚等级</strong>，惩罚）</li></ol></li></ol><p>其中，学院号为学员信息中的学院号的外码，专业号为专业信息中的专业号的外码，奖励等级为奖励关系中的奖励等级的外码，惩罚等级为惩罚关系中的惩罚等级的外码。</p><ol start="2"><li><strong>学籍信息关系模式</strong><ol><li>学籍信息（<strong>ID</strong>，学生学号，学籍改变id，学籍改变时间，学籍具体描述）</li><li>学籍对照（<strong>ID</strong>，学籍描述）</li></ol></li></ol><p>其中，学生学号为学生信息中的外码，学籍改变id为学籍对照中ID的外码。</p><ol start="3"><li><strong>课程信息关系模式</strong><ol><li>成绩信息（<strong>ID</strong>，学生学号，课程id，成绩，课程状态）</li><li>课程信息（<strong>课程号</strong>，学分，课程名）</li></ol></li></ol><p>其中，学生学号为学生信息中的外码，课程id为课程信息中课程号外码。</p><ol start="4"><li><strong>体检信息关系模式</strong><ol><li>体检信息（<strong>学生学号</strong>，身高，体重，肺活量，跳远，坐位体前屈，1000米，800米，仰卧起坐，引体向上）</li></ol></li></ol><p>其中，学生学号为体检信息的主码同时也是学生信息的学号的外码。</p><ol start="5"><li><strong>用户信息关系模式</strong><ol><li>用户信息（<strong>ID，</strong>姓名，邮箱，电话，登录名，登陆密码，头像，用户表示，用户token）</li></ol></li></ol><p>因为上述关系的所有非主属性都完全依赖于每个候选码，所有主属性都完全函数依赖于每个不包含它的候选码，没有任何属性完全函数依赖于非码的任何一组属性，所以上述关系属于3NF，也属于BCNF。</p><h3 id="🏸建表属性与SQL代码"><a href="#🏸建表属性与SQL代码" class="headerlink" title="🏸建表属性与SQL代码"></a>🏸建表属性与SQL代码</h3><p>根据我们所定义的关系模式，建立以下关系表。在这部分中我主要负责学生成绩表和学生体检表这两大部分，并由团队三人一同沟通对此进行改进。</p><ol><li><p>创建学生信息表student</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `STUDENTID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `NAME` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `SEX` enum(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `CLASS` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DEPARTMENT` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `BIRTHDAY` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `NATIVE_PLACE` <span class="type">varchar</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`STUDENTID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `CLASS` (`CLASS`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `DEPARTMENT` (`DEPARTMENT`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `CLASS` <span class="keyword">FOREIGN</span> KEY (`CLASS`) <span class="keyword">REFERENCES</span> `class` (`ID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `DEPARTMENT` <span class="keyword">FOREIGN</span> KEY (`DEPARTMENT`) <span class="keyword">REFERENCES</span> `department` (`ID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/18/OFbGrC.png#id=AaCxI&originHeight=385&originWidth=1530&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建奖励情况表reward</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `reward` (</span><br><span class="line">  `ID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `STUDENTID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `LEVELS` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REC_TIME` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DESCRIPTION` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `STUDENTID2` (`STUDENTID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `LEVELS` (`LEVELS`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `LEVELS` <span class="keyword">FOREIGN</span> KEY (`LEVELS`) <span class="keyword">REFERENCES</span> `reward_levels` (`CODE`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `STUDENTID2` <span class="keyword">FOREIGN</span> KEY (`STUDENTID`) <span class="keyword">REFERENCES</span> `student` (`STUDENTID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">17557</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/18/OFbQQL.png#id=vbfso&originHeight=314&originWidth=1490&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建奖励等级对照表reward_levels</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `reward_levels` (</span><br><span class="line">  `CODE` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DESCRIPTION` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`CODE`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/18/OFbSCi.png#id=daQ90&originHeight=208&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建惩罚情况表punishment</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `punishment` (</span><br><span class="line">  `ID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `STUDENTID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `LEVELS` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REC_TIME` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ENABLE` <span class="type">varchar</span>(<span class="number">5</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DESCRIPTION` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `STUDENTID3` (`STUDENTID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `LEVELS2` (`LEVELS`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `LEVELS2` <span class="keyword">FOREIGN</span> KEY (`LEVELS`) <span class="keyword">REFERENCES</span> `punish_levels` (`CODE`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `STUDENTID3` <span class="keyword">FOREIGN</span> KEY (`STUDENTID`) <span class="keyword">REFERENCES</span> `student` (`STUDENTID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">34007</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/18/OFbciX.png#id=qMrIa&originHeight=370&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建惩罚等级对照表punish_levels</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `punish_levels` (</span><br><span class="line">  `CODE` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DESCRIPTION` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`CODE`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/18/OFbd4t.png#id=xS6AU&originHeight=220&originWidth=1418&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建学院对照表department</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `department` (</span><br><span class="line">  `ID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `NAME` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m0pp0r.webp#id=n3aFY&originHeight=224&originWidth=1444&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建专业对照表class</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class` (</span><br><span class="line">  `ID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `NAME` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `MONITOR` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `MONITOR` (`MONITOR`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m13a0v.webp#id=GPsMT&originHeight=254&originWidth=1465&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建课程表course</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `course` (</span><br><span class="line">  `courseid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `class` <span class="type">float</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `coursename` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_0900_as_cs <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`courseid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_as_cs;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m1656c.webp#id=Dj4Z7&originHeight=241&originWidth=1475&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建成绩表grade</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `grade` (</span><br><span class="line">  `ID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `STUDENTID` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `courseid` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `GRADE` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `STATUS` <span class="type">varchar</span>(<span class="number">5</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `STUDEN` (`STUDENTID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `courseid` (`courseid`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `courseid` <span class="keyword">FOREIGN</span> KEY (`courseid`) <span class="keyword">REFERENCES</span> `course` (`courseid`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `STUDEN` <span class="keyword">FOREIGN</span> KEY (`STUDENTID`) <span class="keyword">REFERENCES</span> `student` (`STUDENTID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">200331</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m19p3e.webp#id=Uo5SR&originHeight=141&originWidth=274&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建学籍表change</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `change_` (</span><br><span class="line">  `ID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `STUDENTID` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `CHANGE` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `REC_TIME` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DESCRIPTION` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `STUDENTID` (`STUDENTID`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `CHANGE` (`CHANGE`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `CHANGE` <span class="keyword">FOREIGN</span> KEY (`CHANGE`) <span class="keyword">REFERENCES</span> `change_code` (`CODE`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `STUDENTID` <span class="keyword">FOREIGN</span> KEY (`STUDENTID`) <span class="keyword">REFERENCES</span> `student` (`STUDENTID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">7013</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m1ccfv.webp#id=vrSHs&originHeight=319&originWidth=1480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建学籍对照表change_code</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `change_code` (</span><br><span class="line">  `CODE` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DESCRIPTION` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb3 <span class="keyword">COLLATE</span> utf8mb3_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`CODE`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m1chb1.webp#id=k1DeL&originHeight=385&originWidth=1530&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li><li><p>创建体测表sports</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sports` (</span><br><span class="line">  `studentid` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `height` <span class="keyword">double</span>(<span class="number">20</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `weight` <span class="keyword">double</span>(<span class="number">20</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `vital` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8mb4_0900_as_cs <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `jump` <span class="keyword">double</span>(<span class="number">20</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sitreach` <span class="keyword">double</span>(<span class="number">20</span>,<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `run1000` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_0900_as_cs <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `run800` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_0900_as_cs <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `situp` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8mb4_0900_as_cs <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pullup` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_as_cs <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`studentid`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `id` <span class="keyword">FOREIGN</span> KEY (`studentid`) <span class="keyword">REFERENCES</span> `student` (`STUDENTID`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_as_cs;</span><br></pre></td></tr></table></figure><p><img src="https://i2.100024.xyz/2023/07/18/m1ce6s.webp#id=XHXYo&originHeight=502&originWidth=1499&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li></ol><h1 id="🥁数据库物理辑设计"><a href="#🥁数据库物理辑设计" class="headerlink" title="🥁数据库物理辑设计"></a>🥁数据库物理辑设计</h1><h2 id="🎯索引"><a href="#🎯索引" class="headerlink" title="🎯索引"></a>🎯索引</h2><p>由于排序等功能需要，在数据库中采用的索引如下表所示：</p><table><thead><tr><th>表名</th><th>参数</th></tr></thead><tbody><tr><td>Student表</td><td>Class</td></tr><tr><td></td><td>Department</td></tr><tr><td>Reward表</td><td>Studentid</td></tr><tr><td>Levels</td><td></td></tr><tr><td>Punishment表</td><td>Studentid</td></tr><tr><td></td><td>Levels</td></tr><tr><td>Grade表</td><td>Studentid</td></tr><tr><td></td><td>Courseid</td></tr><tr><td>Class表</td><td>Monitor</td></tr><tr><td>Change表</td><td>Studentid</td></tr><tr><td></td><td>Change</td></tr></tbody></table><h2 id="🎯视图"><a href="#🎯视图" class="headerlink" title="🎯视图"></a>🎯视图</h2><p>视图能简化用户操作，使用户能以多种角度看待同一数据并对重构数据库提供了一定程度的逻辑独立性，建立视图可以提供清晰的信息呈现。因此数据库系统定义了6个视图：v_course、v_punishment、v_reward、v_sports、v_status、v_student。<br>试图部分的创建主要由我负责，为的是能够更好的在前端界面进行显示，同时也可以为之后的增删改查操作提供便利。</p><h3 id="🏸v-student视图"><a href="#🏸v-student视图" class="headerlink" title="🏸v_student视图"></a>🏸v_student视图</h3><p><img src="https://i2.100024.xyz/2023/07/18/m3min6.webp#id=FzUBl&originHeight=721&originWidth=1145&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ALGORITHM <span class="operator">=</span> UNDEFINED DEFINER <span class="operator">=</span> `root` @`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `v_student` <span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">`student`.`STUDENTID` <span class="keyword">AS</span> `STUDENTID`,</span><br><span class="line">`student`.`NAME` <span class="keyword">AS</span> `NAME`,</span><br><span class="line">`student`.`SEX` <span class="keyword">AS</span> `SEX`,</span><br><span class="line">`class`.`NAME` <span class="keyword">AS</span> `class`,</span><br><span class="line">`department`.`NAME` <span class="keyword">AS</span> `department`,</span><br><span class="line">`student`.`BIRTHDAY` <span class="keyword">AS</span> `BIRTHDAY`,</span><br><span class="line">`student`.`NATIVE_PLACE` <span class="keyword">AS</span> `NATIVE_PLACE` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ((</span><br><span class="line">    `student`</span><br><span class="line">    <span class="keyword">JOIN</span> `class` <span class="keyword">ON</span> ((</span><br><span class="line">      `student`.`CLASS` <span class="operator">=</span> `class`.`ID` </span><br><span class="line">    )))</span><br><span class="line">   <span class="keyword">JOIN</span> `department` <span class="keyword">ON</span> ((</span><br><span class="line">     `student`.`DEPARTMENT` <span class="operator">=</span> `department`.`ID` </span><br><span class="line">   )))</span><br></pre></td></tr></table></figure><h3 id="🏸v-course视图"><a href="#🏸v-course视图" class="headerlink" title="🏸v_course视图"></a>🏸v_course视图</h3><p><img src="https://i2.100024.xyz/2023/07/18/m42jxa.webp#id=k4ghW&originHeight=485&originWidth=1013&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ALGORITHM <span class="operator">=</span> UNDEFINED DEFINER <span class="operator">=</span> `root` @`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `v_course` <span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">`student`.`STUDENTID` <span class="keyword">AS</span> `studentid`,</span><br><span class="line">`student`.`NAME` <span class="keyword">AS</span> `name`,</span><br><span class="line">`student`.`SEX` <span class="keyword">AS</span> `sex`,</span><br><span class="line">`class`.`NAME` <span class="keyword">AS</span> `class`,</span><br><span class="line">`department`.`NAME` <span class="keyword">AS</span> `department`,</span><br><span class="line">`grade`.`GRADE` <span class="keyword">AS</span> `GRADE`,</span><br><span class="line">`grade`.`STATUS` <span class="keyword">AS</span> `STATUS`,</span><br><span class="line">`course`.`coursename` <span class="keyword">AS</span> `coursename`,</span><br><span class="line">`course`.`class` <span class="keyword">AS</span> `credit` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ((((</span><br><span class="line">          `student`</span><br><span class="line">          <span class="keyword">JOIN</span> `class` <span class="keyword">ON</span> ((</span><br><span class="line">              `student`.`CLASS` <span class="operator">=</span> `class`.`ID` </span><br><span class="line">            )))</span><br><span class="line">        <span class="keyword">JOIN</span> `department` <span class="keyword">ON</span> ((</span><br><span class="line">            `student`.`DEPARTMENT` <span class="operator">=</span> `department`.`ID` </span><br><span class="line">          )))</span><br><span class="line">      <span class="keyword">JOIN</span> `grade` <span class="keyword">ON</span> ((</span><br><span class="line">          `student`.`STUDENTID` <span class="operator">=</span> `grade`.`STUDENTID` </span><br><span class="line">        )))</span><br><span class="line">    <span class="keyword">JOIN</span> `course` <span class="keyword">ON</span> ((</span><br><span class="line">      `grade`.`courseid` <span class="operator">=</span> `course`.`courseid` </span><br><span class="line">  )))</span><br></pre></td></tr></table></figure><h3 id="🏸v-status视图"><a href="#🏸v-status视图" class="headerlink" title="🏸v_status视图"></a>🏸v_status视图</h3><p><img src="https://i2.100024.xyz/2023/07/18/m42ls2.webp#id=c6EyT&originHeight=493&originWidth=715&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ALGORITHM <span class="operator">=</span> UNDEFINED DEFINER <span class="operator">=</span> `root` @`localhost` <span class="keyword">SQL</span> SECURITY DEFINER <span class="keyword">VIEW</span> `v_status` <span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">`student`.`STUDENTID` <span class="keyword">AS</span> `studentid`,</span><br><span class="line">`student`.`NAME` <span class="keyword">AS</span> `name`,</span><br><span class="line">`student`.`SEX` <span class="keyword">AS</span> `sex`,</span><br><span class="line">`department`.`NAME` <span class="keyword">AS</span> `xueyuan`,</span><br><span class="line">`class`.`NAME` <span class="keyword">AS</span> `classname`,</span><br><span class="line">`change_code`.`DESCRIPTION` <span class="keyword">AS</span> `stu_status`,</span><br><span class="line">`change_`.`DESCRIPTION` <span class="keyword">AS</span> `stu_reason`,</span><br><span class="line">`change_`.`REC_TIME` <span class="keyword">AS</span> `change_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ((((</span><br><span class="line">          `change_code`</span><br><span class="line">          <span class="keyword">JOIN</span> `change_` <span class="keyword">ON</span> ((</span><br><span class="line">              `change_code`.`CODE` <span class="operator">=</span> `change_`.`CHANGE` </span><br><span class="line">            )))</span><br><span class="line">        <span class="keyword">JOIN</span> `student` <span class="keyword">ON</span> ((</span><br><span class="line">            `student`.`STUDENTID` <span class="operator">=</span> `change_`.`STUDENTID` </span><br><span class="line">          )))</span><br><span class="line">      <span class="keyword">JOIN</span> `department` <span class="keyword">ON</span> ((</span><br><span class="line">          `student`.`DEPARTMENT` <span class="operator">=</span> `department`.`ID` </span><br><span class="line">        )))</span><br><span class="line">    <span class="keyword">JOIN</span> `class` <span class="keyword">ON</span> ((</span><br><span class="line">      `student`.`CLASS` <span class="operator">=</span> `class`.`ID` </span><br><span class="line">  )))</span><br></pre></td></tr></table></figure><h3 id="🏸剩余视图"><a href="#🏸剩余视图" class="headerlink" title="🏸剩余视图"></a>🏸剩余视图</h3><p>我们在数据库内建立以上三个和其余三个视图，主要用于前端界面学生信息表、学生成绩表、学生学籍表、学生体检表增删改查的需要v_punishment、v_sports等视图的建立与上述类似，由于篇幅限制，这里不再过多解释。</p><h2 id="🎯触发器"><a href="#🎯触发器" class="headerlink" title="🎯触发器"></a>🎯触发器</h2><p>为统计学生的总数，我们设计了insert、delete触发器以便使其随数据库增、删、修进行变化，语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">TRIGGER</span> `student_insert_trigger` AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `student` <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 更新学生总人数</span></span><br><span class="line">    <span class="keyword">UPDATE</span> `count` <span class="keyword">SET</span> studentcount <span class="operator">=</span> studentcount <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> nameid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">TRIGGER</span> `student_delete_trigger` AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> `student` <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 更新学生总人数</span></span><br><span class="line">    <span class="keyword">UPDATE</span> `count` <span class="keyword">SET</span> studentcount <span class="operator">=</span> studentcount <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> nameid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="🎯存储过程"><a href="#🎯存储过程" class="headerlink" title="🎯存储过程"></a>🎯存储过程</h2><p>定义一个存储过程名为find_course，它接受一个输入参数coursename，类型为VARCHAR(255)。存储过程的作用是根据提供的课程名称查询学生的成绩和相关信息。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `find_course`(<span class="keyword">IN</span> `coursename` <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  #Routine body goes here...</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    s.studentid,s.name,s.sex,s.department,s.class,c.class <span class="keyword">as</span> credit,g.status,g.grade</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    grade g</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> g.studentid <span class="operator">=</span> s.studentid</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> g.courseid <span class="operator">=</span> c.courseid</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    c.coursename <span class="operator">=</span> coursename;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这个存储过程的作用是根据提供的课程名称，在数据库中查找并返回与该课程相关的学生的成绩和相关信息。可以通过调用该存储过程并传入课程名称作为参数来获取查询结果。这样做的好处是将该查询逻辑封装在存储过程中，提高了代码的可重用性和可维护性。</p><h2 id="🎯安全性"><a href="#🎯安全性" class="headerlink" title="🎯安全性"></a>🎯安全性</h2><p>区分用户和管理员模式是为了在系统中设置不同的权限和功能访问级别，以满足管理员和普通用户的不同需求。下面是对管理员和用户模式的详细说明：<br><strong>管理员模式：</strong></p><ol><li>基本信息管理：管理员可以对学生的基本信息进行增加、修改、删除和查询操作。这包括姓名、性别、年龄、联系方式等信息。</li><li>成绩管理：管理员可以对学生的成绩进行增加、修改、删除和查询操作。这涉及到课程名称、学分、学生成绩等信息。</li><li>体检情况管理：管理员可以对学生的体检情况进行增加、修改、删除和查询操作。这包括身高、体重、健康状况等信息。</li><li>用户管理：管理员可以管理系统的用户账号，包括创建新用户、修改用户权限、重置密码等操作。</li><li>系统设置：管理员可以对系统进行一些全局设置，比如修改系统配置、备份数据、导入导出数据等操作。</li></ol><p><strong>用户模式：</strong></p><ol><li>浏览信息：用户可以浏览学生的基本信息、成绩、体检情况，但不能进行修改或删除操作。</li><li>查询功能：用户可以使用系统提供的查询功能，根据不同的条件搜索学生的基本信息、成绩、体检情况。</li></ol><p>需要注意的是，用户模式下的查询功能应该是只读的，用户无法修改任何数据，只能查看和搜索。<br>通过区分用户和管理员模式，可以限制普通用户的功能操作，确保数据的安全和完整性。管理员模式下可以进行更加底层的管理和维护操作，满足系统管理员的需求。而用户模式下的功能和权限则相对较为有限，主要用于普通用户的信息浏览和查询。这种分级的设计可以提高系统的安全性和可控性。</p><h1 id="🥁系统后端接口设计"><a href="#🥁系统后端接口设计" class="headerlink" title="🥁系统后端接口设计"></a>🥁系统后端接口设计</h1><p>系统的后端设计需要考虑数据库操作、API接口设计和安全性。在数据库后端的接口设计部分主要由我和缪蕊忆同学为主要编写，由于这部分的接口比较多，因此这里主要挑选一些重点部分介绍。</p><h2 id="🎯获取全部学生信息接口"><a href="#🎯获取全部学生信息接口" class="headerlink" title="🎯获取全部学生信息接口"></a>🎯获取全部学生信息接口</h2><p>使用Express框架编写后端接口，用于获取学生列表的分页数据。<br>首先定义一个GET请求路由，用于指定当前页码。执行数据库查询并解析请求参数，表示当前页码。执行学生详细信息的查询并将结果返回给前端。由于篇幅限制这部分代码简略。</p><h2 id="🎯按姓名查找接口"><a href="#🎯按姓名查找接口" class="headerlink" title="🎯按姓名查找接口"></a>🎯按姓名查找接口</h2><p>根据学生姓名进行分页查询的功能，具体实现方式与查询学生信息方式相似，因此不做过多分析。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.get(&quot;/select/:stuname/page/:page&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  // console.log(req.params.stuname);</span><br><span class="line">  // console.log(req.params.page);</span><br><span class="line">  // 获取总页数</span><br><span class="line">  let strSql0 =</span><br><span class="line">    &quot;select count(*) as pagenum from student where (name like &#x27;%&quot; +</span><br><span class="line">    req.params.stuname +</span><br><span class="line">    &quot;%&#x27;)&quot;;</span><br><span class="line">  let result1 = await sqlQuery(strSql0);</span><br><span class="line">  // console.log(pageAll);</span><br><span class="line"></span><br><span class="line">  // 每页包含的条数</span><br><span class="line">  let itemPerPage = 8;</span><br><span class="line">  let pageAll = Math.ceil(result1[0].pagenum / itemPerPage);</span><br><span class="line">  let currentPage = parseInt(req.params.page)</span><br><span class="line">  let strSql =</span><br><span class="line">    `SELECT ` +</span><br><span class="line">    `student.studentid, ` +</span><br><span class="line">    `student.NAME AS name, ` +</span><br><span class="line">    `sex, ` +</span><br><span class="line">    `birthday, ` +</span><br><span class="line">    `native_place, ` +</span><br><span class="line">    `class.NAME AS classname, ` +</span><br><span class="line">    `department.NAME AS xueyuan,` +</span><br><span class="line">    `GROUP_CONCAT( punishment.DESCRIPTION ) AS punishstatus, ` +</span><br><span class="line">    `GROUP_CONCAT( reward.DESCRIPTION ) AS rewardstatus ` +</span><br><span class="line">    `FROM ` +</span><br><span class="line">    `student ` +</span><br><span class="line">    `INNER JOIN class ON ( student.class = class.id ) ` +</span><br><span class="line">    `INNER JOIN department ON ( student.department = department.id ) ` +</span><br><span class="line">    `LEFT JOIN punishment ON ( student.studentid = punishment.studentid ) ` +</span><br><span class="line">    `LEFT JOIN reward ON ( student.studentid = reward.STUDENTID ) ` +</span><br><span class="line">    `WHERE student.name like &#x27;%` + req.params.stuname + `%&#x27;` +</span><br><span class="line">    `GROUP BY ` +</span><br><span class="line">    `student.STUDENTID ` +</span><br><span class="line">    `ORDER BY ` +</span><br><span class="line">    `student.STUDENTID ` +</span><br><span class="line">    `LIMIT ` +</span><br><span class="line">    currentPage * itemPerPage +</span><br><span class="line">    &quot;,&quot; +</span><br><span class="line">    itemPerPage +</span><br><span class="line">    &quot; ;&quot;;</span><br><span class="line">  let result2 = await sqlQuery(strSql);</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    data: Array.from(result2),</span><br><span class="line">    pageAll</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🎯查看获奖情况接口"><a href="#🎯查看获奖情况接口" class="headerlink" title="🎯查看获奖情况接口"></a>🎯查看获奖情况接口</h2><p>定义接口用于查询学生奖励信息的功能。<br>定义一个GET请求路由，用于指定学生的ID。构建查询学生奖励信息的SQL语句。执行数据库查询，并将查询结果存储在result中。该结果包含了学生奖励的描述、奖励级别描述和奖励时间等信息。将查询结果以JSON格式返回给前端。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.get(&#x27;/selcetreward/:stuid&#x27;,async(req,res) =&gt; &#123;</span><br><span class="line">    let sql = `SELECT ` +</span><br><span class="line">    `reward.description, `+</span><br><span class="line">    `reward_levels.DESCRIPTION,reward.REC_TIME `+</span><br><span class="line">`FROM `+</span><br><span class="line">    `reward `+</span><br><span class="line">    `INNER JOIN reward_levels ON (LEVELS = CODE) `+</span><br><span class="line">    `where STUDENTID = ` + req.params.stuid</span><br><span class="line">    </span><br><span class="line">    let result1 = await sqlQuery(sql)</span><br><span class="line">    res.json(result1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="🎯更新学生信息接口"><a href="#🎯更新学生信息接口" class="headerlink" title="🎯更新学生信息接口"></a>🎯更新学生信息接口</h2><p>定义后端接口，用于更新学生信息的功能。<br>定义了一个POST请求路由，用于解析请求体中的JSON数据。构建更新学生信息的SQL语句。同时创建一个数组，用于存储更新语句中的参数值。执行数据库更新操作，将SQL语句和参数数组传递给函数，并将结果存储在result中。返回响应给前端，并结束请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.post(&#x27;/update&#x27;,jsonParser,async(req,res) =&gt; &#123;</span><br><span class="line">    let sql = `UPDATE \`student\` `+ </span><br><span class="line">        `SET STUDENTID = ? , student.NAME =  ?,sex= ?, `+`native_place=?,`+</span><br><span class="line">        `student.class = ( SELECT class.id FROM class WHERE class.NAME = ? ),`+</span><br><span class="line">        `student.DEPARTMENT = ( SELECT department.id FROM department WHERE department.NAME = ? ) `+</span><br><span class="line">        `WHERE STUDENTID = ? `</span><br><span class="line">    let arr = []</span><br><span class="line">    arr[0] = req.body.studentid</span><br><span class="line">    arr[1] = req.body.name</span><br><span class="line">    arr[2] = req.body.sex</span><br><span class="line">    arr[3] = req.body.native_place</span><br><span class="line">    arr[4] = req.body.classname</span><br><span class="line">    arr[5] = req.body.xueyuan</span><br><span class="line">    arr[6] = req.body.studentid</span><br><span class="line">    </span><br><span class="line">    let result =await sqlQuery(sql,arr);</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="🎯新增学生信息接口"><a href="#🎯新增学生信息接口" class="headerlink" title="🎯新增学生信息接口"></a>🎯新增学生信息接口</h2><p>定义后端接口，用于添加学生信息的功能。<br>定义了一个POST请求路由，用于解析请求体中的JSON数据。构建插入学生信息的SQL语句。创建一个数组，用于存储插入语句中的参数值。从生日字符串中提取月份和日期，并将其拼接为MM-DD的格式。尝试执行数据库插入操作，将SQL语句和参数数组传递给函数，返回响应给前端，并结束请求。如果插入过程中发生错误，将错误信息打印到控制台，并返回500状态码和错误信息的JSON响应给前端。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.post(&#x27;/add&#x27;, jsonParser, async (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.body.birthday);</span><br><span class="line">    </span><br><span class="line">        let sql1 = `INSERT INTO \`student\` ` +</span><br><span class="line">    `VALUES (?, ?, ?, ` +</span><br><span class="line">    `(SELECT id FROM class WHERE NAME = ?), ` +</span><br><span class="line">    `(SELECT id FROM department WHERE NAME = ?), ` +</span><br><span class="line">    `?, ?)`; // 替换 &quot;?&quot; 为实际字段值</span><br><span class="line"></span><br><span class="line">    let arr = []</span><br><span class="line">    arr[0] = req.body.studentid</span><br><span class="line">    arr[1] = req.body.name</span><br><span class="line">    arr[2] = req.body.sex</span><br><span class="line">    arr[3] = req.body.classname</span><br><span class="line">    arr[4] = req.body.xueyuan</span><br><span class="line">    arr[6] = req.body.native_place</span><br><span class="line"></span><br><span class="line">    let month = req.body.birthday.substring(5, 7); // 从索引位置 5 开始截取，包括索引位置 5</span><br><span class="line">    let day= req.body.birthday.substring(8, 10); // 从索引位置 8 开始截取，包括索引位置 8</span><br><span class="line">    arr[5]= month + &quot;-&quot; + day;</span><br><span class="line">  </span><br><span class="line">    try &#123;</span><br><span class="line">      let result = await sqlQuery(sql1, arr);</span><br><span class="line">      </span><br><span class="line">      res.end();</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      console.error(error);</span><br><span class="line">      res.status(500).json(&#123; error: &#x27;Internal Server Error&#x27; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🎯删除学生信息接口"><a href="#🎯删除学生信息接口" class="headerlink" title="🎯删除学生信息接口"></a>🎯删除学生信息接口</h2><p>定义后端接口，用于删除学生信息的功能。<br>定义了一个POST请求路由，用于解析请求体中的JSON数据。构建删除学生相关表记录的SQL语句。创建一个数组，用于存储SQL语句中的参数值。执行数据库操作，依次执行删除操作并将查询结果存储在各自的result变量中。返回响应给前端，并结束请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.post(&#x27;/delete&#x27;,jsonParser,async(req,res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let sql=`delete from sports where studentid = ?`</span><br><span class="line">    let sql1 = `delete from grade where studentid = ?`</span><br><span class="line">    let sql2 = `delete from change_ where studentid = ?`</span><br><span class="line">    let sql3 = `delete from reward where studentid = ?`</span><br><span class="line">    let sql4 = `delete from student where studentid = ?`</span><br><span class="line">    let arr = []</span><br><span class="line">    arr[0] = req.body.studentid;</span><br><span class="line">    let result3 =await sqlQuery(sql3,arr);</span><br><span class="line">    let result2 =await sqlQuery(sql2,arr);</span><br><span class="line">    let result1 =await sqlQuery(sql1,arr);</span><br><span class="line">    let result =await sqlQuery(sql,arr);</span><br><span class="line">    let result4 =await sqlQuery(sql4,arr);</span><br><span class="line">    </span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="🎯其他接口"><a href="#🎯其他接口" class="headerlink" title="🎯其他接口"></a>🎯其他接口</h2><p>以上以学生信息表中的部分接口为例子，介绍了对学生信息表进行增删改查所需要用到的接口信息。同理对于学籍信息管理表、体测信息表等同样定义类似的接口。</p><h1 id="🥁系统前端设计"><a href="#🥁系统前端设计" class="headerlink" title="🥁系统前端设计"></a>🥁系统前端设计</h1><p>这个系统的前端设计应该考虑管理员和用户两个角色的需求和功能，并且注重用户友好性和易用性。<br>界面主要分为用户登录界面、导航菜单和布局、首页、学生管理和管理员管理界面。为了更好的进行前端的编写，我们主要选择的通过参考HTML相关模板并在此基础上编写Vue ElementUi界面进行相关设计。<br>这一部分主要由团队三人共同编写完成，在后端接口的基础每人负责几个界面的功能设计，最后汇总得到最终系统前端部分的设计。</p><h2 id="🎯用户登录"><a href="#🎯用户登录" class="headerlink" title="🎯用户登录"></a>🎯用户登录</h2><p>定义一个Vue组件的代码，用于实现登录功能。<br>使用import语句导入了getLogin函数，用于发起登录请求。定义了名为Login的Vue组件。在methods中定义了一个submitForm方法，用于提交登录表单。首先通过$refs[loginForm]获取到表单验证组件的引用，然后调用其validate方法进行表单验证。如果验证通过，则会发起登录请求，并根据响应的结果进行处理。如果登录成功，会显示成功提示消息，并导航到首页；如果登录失败，会显示警告提示消息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    // 提交登录</span><br><span class="line">    submitForm(loginForm) &#123;</span><br><span class="line">      this.$refs[loginForm].validate((valid) =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          // console.log(this.loginForm);</span><br><span class="line">          this.$store.dispatch(&quot;login&quot;, this.loginForm).then((res) =&gt; &#123;</span><br><span class="line">            let &#123;data&#125; = res</span><br><span class="line">            console.log(data);</span><br><span class="line">            if(data.code == 1000)&#123;</span><br><span class="line">              this.$message(&#123; message:data.message, type: &quot;success&quot; &#125;);</span><br><span class="line">              // 获取登录用户信息</span><br><span class="line">              // this.$store.dispatch(&quot;getInfo&quot;,data)</span><br><span class="line"></span><br><span class="line">              this.$router.push(&#123; path: this.redirect || &#x27;/&#x27; &#125;)</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              this.$message(&#123; message:data.message, type: &quot;warning&quot; &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;error submit!!&quot;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    resetForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].resetFields();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🎯学生信息管理"><a href="#🎯学生信息管理" class="headerlink" title="🎯学生信息管理"></a>🎯学生信息管理</h2><h3 id="🏸获取学生信息"><a href="#🏸获取学生信息" class="headerlink" title="🏸获取学生信息"></a>🏸获取学生信息</h3><p>定义一个Vue组件中的方法，用于获取学生信息并更新表格数据。<br>在方法体内，通过调用selectallstudent函数发起获取学生信息的请求。假设该函数是一个异步函数，返回了一个Promise对象。在Promise对象的then方法中，处理请求返回的结果。首先获取返回结果中的pageAll属性，该属性表示学生信息的总页数。然后获取返回结果中的data属性，该属性表示学生信息的数据数组。<br>通过调用一个接口函数获取学生信息数据，并更新Vue组件中的表格数据和分页信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getStudentMes(page = 0) &#123;</span><br><span class="line">      // 请求</span><br><span class="line">      selectallstudent(page).then((res) =&gt; &#123;</span><br><span class="line">        this.pagiDataAll = res.data.pageAll;</span><br><span class="line">        // console.log(res);</span><br><span class="line">        let result = res.data.data;</span><br><span class="line"></span><br><span class="line">        // 过滤属性值为null的</span><br><span class="line">        // this.resFilter(result);</span><br><span class="line">        // 清空数组</span><br><span class="line">        this.tableData.splice(0);</span><br><span class="line">        this.tableData.push(...result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="🏸修改和增加学生信息"><a href="#🏸修改和增加学生信息" class="headerlink" title="🏸修改和增加学生信息"></a>🏸修改和增加学生信息</h3><p>定义函数用于接受表单的名称。函数通过this.$refs[formName]获取对应表单的引用，并调用validate方法对表单进行验证。在回调函数中，首先判断表单是否通过验证，根据this.choose的值来判断是修改学生信息还是增加学生。<br>如果this.choose为false，表示修改学生信息。首先检查学号是否有变化，如果学号没有变化，则调用updateStuInfo函数更新学生信息，并根据返回结果显示相应的提示消息。如果学号有变化，首先使用isExit函数判断数据库中是否存在相同的学号。如果存在则显示警告消息，否则调用updateStuInfo函数更新学生信息，并根据返回结果显示相应的提示消息。<br>如果this.choose不为false，表示增加学生。类似修改学生信息的处理流程，首先检查学号是否有变化，然后使用isExit函数判断数据库中是否存在相同的学号。如果存在则显示警告消息，否则调用addStuInfo函数增加学生，并根据返回结果显示相应的提示消息。</p><h3 id="🏸其余函数"><a href="#🏸其余函数" class="headerlink" title="🏸其余函数"></a>🏸其余函数</h3><p>前端部分的其余函数也基本与上述相类似，由于篇幅原因，这里不做过多赘述。</p><h2 id="🎯可视化设计"><a href="#🎯可视化设计" class="headerlink" title="🎯可视化设计"></a>🎯可视化设计</h2><p>在可视化模块部分一共定义了4个基于Vue框架和echarts库的组件的可视化数据表。<br>以学籍变动情况的饼图为例，首先引入echarts库和中国地图的相关文件，然后定义了一个Vue组件对象。在data属性中，定义了一个名为allData的数组，用于存储从后端请求回来的数据。通过给定的节点引用，初始化实例，并设置图表的标题、提示框、图例、工具栏和系列数据等配置信息。具体函数部分代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 引入基本模板</span><br><span class="line">// let echarts = require(&#x27;echarts/lib/echarts&#x27;)</span><br><span class="line">import echarts from &quot;echarts&quot;;</span><br><span class="line">import &quot;echarts/map/js/china.js&quot;;</span><br><span class="line">import &#123; selectStatusChange &#125; from &quot;@/api/request&quot;;</span><br><span class="line">// 引入柱状图组件</span><br><span class="line">require(&quot;echarts/lib/chart/bar&quot;);</span><br><span class="line">// 引入提示框和title组件</span><br><span class="line">require(&quot;echarts/lib/component/tooltip&quot;);</span><br><span class="line">require(&quot;echarts/lib/component/title&quot;);</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Echange&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      allData: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getSelectClassNuber();</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // console.log(this.allData);</span><br><span class="line">    // 当数据加载成功调用</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.echartsInit();</span><br><span class="line">    &#125;, 500);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    echartsInit() &#123;</span><br><span class="line">      // 基于准备好的dom，初始化echarts实例</span><br><span class="line">      let ehartsref = this.$refs.charts;</span><br><span class="line">      // let myChart = this.$echarts.init(document.getElementById(&quot;map&quot;));</span><br><span class="line">      let myChart = echarts.init(ehartsref);</span><br><span class="line">      // 绘制表格</span><br><span class="line">     …</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 数据请求</span><br><span class="line">    async getSelectClassNuber() &#123;</span><br><span class="line">      let result = await selectStatusChange();</span><br><span class="line">      // console.log(result);</span><br><span class="line">      this.allData.push(...result.data);</span><br><span class="line">      // console.log(this.allData);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并在index.vue进行函数的调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &quot;stucharts&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Emap,</span><br><span class="line">    Epie,</span><br><span class="line">    Ereward,</span><br><span class="line">    Echange,</span><br><span class="line">    //Egrade,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="🥁系统界面和功能演示"><a href="#🥁系统界面和功能演示" class="headerlink" title="🥁系统界面和功能演示"></a>🥁系统界面和功能演示</h1><h2 id="🎯登录模块"><a href="#🎯登录模块" class="headerlink" title="🎯登录模块"></a>🎯登录模块</h2><p>用户的登录界面如下所示：<br><img src="https://i2.100024.xyz/2023/07/18/masfzq.webp#id=Iuqu4&originHeight=1518&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>系统共实现了两类用户的登录，分别为管理员模式和普通用户模式，输入对应的用户名和密码即可进入对应系统。同时，输入错误的用户名和密码也会对其进行错误提示。<br>由于管理员系统和普通用户的区别不大，因此这里主要以管理员系统为主进行界面和功能的展示。</p><h2 id="🎯主界面（首页）模块"><a href="#🎯主界面（首页）模块" class="headerlink" title="🎯主界面（首页）模块"></a>🎯主界面（首页）模块</h2><p>输入管理员对应的账号和密码——账号：admin，密码：123456即可进入管理员系统界面，主界面如下所示：主界面展示了全部学生的信息概况，分别为学生总数、学院总数、班级（专业）总数和奖励记录的条数。通过触发器实现当学生信息、学院信息、班级信息或奖励记录发生变化时，更新主界面展示的学生信息概况。同时展现了学生学籍管理系统的项目介绍，分别包括开发成员以及实现技术和环境。<br><img src="https://i2.100024.xyz/2023/07/18/mb6sgc.webp#id=BQupv&originHeight=1519&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎯学生管理模块"><a href="#🎯学生管理模块" class="headerlink" title="🎯学生管理模块"></a>🎯学生管理模块</h2><p>学生管理模块主要分为学生信息管理、学籍信息管理、学生成绩管理、体检情况管理和数据可视化这5个部分。</p><h3 id="🏸学生信息管理"><a href="#🏸学生信息管理" class="headerlink" title="🏸学生信息管理"></a>🏸学生信息管理</h3><p><img src="https://i2.100024.xyz/2023/07/18/mbensu.webp#id=OjmIx&originHeight=1521&originWidth=2560&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>学生信息管理界面如上图所示，该模块共实现了对学生信息的查询、增加、删除、修改以及对该学生奖励和违纪情况的查看。具体来说：</p><ol><li><strong>查询功能</strong></li></ol><p>学生信息管理的查询功能共实现了学号查询、姓名查询和性别查询三种方式，且均实现了模糊查询。以查询学生姓名为例，查询名字中带“吴”的同学为例，如下图所示。<br><img src="https://i2.100024.xyz/2023/07/18/mbv60x.webp#id=wlSGn&originHeight=1123&originWidth=2229&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol start="2"><li><strong>新生录入功能</strong></li></ol><p>点击新生录入按钮即可实现对新生信息的录入，如下图所示增加学生信息。若当前学号在表student中不存在，则会在表中增加对应的学生，反之会提示当前学号已存在。<br><img src="https://i.imgtg.com/2023/07/18/OFbwk1.png#id=Eq4Eg&originHeight=992&originWidth=1661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://i.imgtg.com/2023/07/18/OFkMmI.png#id=TQ2z0&originHeight=857&originWidth=1680&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1689659561022-5bc52101-3f49-49da-9315-8fc277f4b573.png#averageHue=%23a5a494&clientId=u5bd497d9-d1f1-4&from=paste&height=115&id=u760d6d35&originHeight=461&originWidth=1113&originalType=binary&ratio=2&rotation=0&showTitle=false&size=157684&status=done&style=none&taskId=uce19a4a2-ecea-4ee9-b2b7-43c5466f99b&title=&width=278" alt="image.png"></p><ol start="3"><li><strong>学生信息修改功能</strong></li></ol><p>点击“修改”按钮即可实现对当前学生的信息进行修改，在这一模块中，可以对当前学生的所有信息进行修改。<br><img src="https://i.imgtg.com/2023/07/18/OFkOYD.png#id=SMEAW&originHeight=1094&originWidth=1865&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://i.imgtg.com/2023/07/18/OFko5F.png#id=pZFxu&originHeight=1081&originWidth=1837&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol start="4"><li><strong>学生信息删除功能</strong></li></ol><p>在学生信息删除部分，共实现了单个删除和批量删除两种，选中所需要进行删除的学生或者对当前学生进行删除即可。<br><img src="https://i.imgtg.com/2023/07/18/OFk5SP.png#id=v4m8n&originHeight=1152&originWidth=1942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol start="5"><li><strong>学生奖惩情况查看功能</strong></li></ol><p>若当前学生无违纪情况和获奖记录，会显示“无”，反之会显示查看按钮，点击查看按钮即可对该学生的奖惩和获奖情况进行查看。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1689659754777-05594512-6eda-4693-a4b4-9a254bd8b082.png#averageHue=%2360675b&clientId=u5bd497d9-d1f1-4&from=paste&height=174&id=u95421d7a&originHeight=694&originWidth=1100&originalType=binary&ratio=2&rotation=0&showTitle=false&size=309481&status=done&style=none&taskId=u40224cc6-ed4c-48dc-8e0a-44c5d524997&title=&width=275" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1689659784095-9a91e5a1-dfb2-4a8d-8c5f-9eed5cda6d0b.png#averageHue=%237b7a76&clientId=u5bd497d9-d1f1-4&from=paste&height=173&id=u35955f9a&originHeight=690&originWidth=1160&originalType=binary&ratio=2&rotation=0&showTitle=false&size=249132&status=done&style=none&taskId=u1c7cc632-7f13-4dbb-9365-c18dc30cc54&title=&width=290" alt="image.png"></p><h3 id="🏸学籍信息管理"><a href="#🏸学籍信息管理" class="headerlink" title="🏸学籍信息管理"></a>🏸学籍信息管理</h3><p><img src="https://i.imgtg.com/2023/07/18/OFkBwb.png#id=ztJVq&originHeight=1033&originWidth=1748&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>学籍信息管理界面如上所示，该表的展示使用了视图。在设计过程中由于对学生学籍的增删改查等功能与学生信息相似，因此由于课设的时间限制，我们便没有对这一部分增加对应的功能，仅仅实现了学生学籍的查看。</p><h3 id="🏸学生成绩管理"><a href="#🏸学生成绩管理" class="headerlink" title="🏸学生成绩管理"></a>🏸学生成绩管理</h3><p><img src="https://i.imgtg.com/2023/07/18/OFkUnl.png#id=BiGrR&originHeight=1076&originWidth=1815&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>学生成绩管理界面如上图所示，在这一模块实现了对于学生成绩的查询、删除和修改。</p><ol><li><strong>学生成绩管理查询功能</strong></li></ol><p>在按照学号、姓名、性别查询的基础上，这一部分还实现了对于课程名字的查询，同样也是模糊查询。由于基本功能与学生信息管理模块的查询类似，因此这里不再多做展示。</p><ol start="2"><li><strong>学生成绩管理删除功能</strong></li></ol><p>对于学生成绩的删除，同样实现了批量删除和指定对应的学生成绩进行删除这两种情况，基本功能同样与学生信息管理模块中的删除功能相似。</p><ol start="3"><li><strong>学生成绩管理修改功能</strong></li></ol><p>点击所想要修改的学生对应行的“修改”按钮即可出现弹窗实现对当前学生考试情况的修改。通过需求分析，我们设定当前学生的基本信息如学号、姓名、性别、学院、班级（专业）、课程均不可修改，只可修改考试情况和相对应的成绩，如下图所示。<br><img src="https://i.imgtg.com/2023/07/18/OFkb8B.png#id=e4tIa&originHeight=1072&originWidth=1813&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🏸学生体检情况管理"><a href="#🏸学生体检情况管理" class="headerlink" title="🏸学生体检情况管理"></a>🏸学生体检情况管理</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1689660063465-5d4b2bb3-17b3-4605-8520-7912ddcb6c5d.png#averageHue=%23cedccc&clientId=u5bd497d9-d1f1-4&from=paste&height=579&id=uff60ca5c&originHeight=1157&originWidth=1946&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1701526&status=done&style=none&taskId=u27b77a83-8537-406d-bddd-36128daf563&title=&width=973" alt="image.png"><br>学生体检情况管理界面如上图所示，在这一模块实现了对于学生体检情况的录入、查询、删除和修改功能。</p><ol><li><strong>学生体检情况管理查询、删除功能</strong></li></ol><p>学生体检情况的查询同样实现了对学生姓名、学号、性别的模糊查询。而删除也同样实现了批量删除和单独选中删除两种功能。由于前面有介绍，由于篇幅设置这里不再赘述。</p><ol start="2"><li><strong>学生体检情况管理录入功能</strong></li></ol><p>对于学生体检情况的录入功能，共分为两种情况：一是当前学生的学号在学生信息表中不存在，如下图所示，系统会提示该学生不存在从而取消录入。<br><img src="https://i.imgtg.com/2023/07/18/OFkxks.png#id=O1j9c&originHeight=663&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>二是学生表中存在的学号，即可对此进行正常录入，如下图所示。</p><table><thead><tr><th><img src="https://i.imgtg.com/2023/07/18/OFkrDX.png#id=QtZYr&originHeight=871&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th><th><img src="https://i.imgtg.com/2023/07/18/OFkA8t.png#id=DtYe7&originHeight=636&originWidth=1479&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th></tr></thead></table><ol start="3"><li><strong>学生体检情况管理修改功能</strong></li></ol><p>点击所想要修改的学生对应行的“修改”按钮即可出现弹窗实现对当前学生体测情况的修改。通过需求分析，我们设定当前学生的基本信息如学号、姓名、性别不可修改，只可修改对应体检情况的成绩，如下图所示。<br><img src="https://i.imgtg.com/2023/07/18/OFkZxx.png#id=PfU6D&originHeight=961&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🏸数据可视化"><a href="#🏸数据可视化" class="headerlink" title="🏸数据可视化"></a>🏸数据可视化</h3><p><img src="https://i.imgtg.com/2023/07/18/OFkvpj.png#id=yQsk6&originHeight=1005&originWidth=1699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>数据可视化界面如上图所示，当前界面共实现了4个可视化数据图表，分别为生源地学生的分布：根据学生信息中的籍贯绘制可视化地图；各专业人数分布图：根据学生信息中的专业进行人数统计绘制对应饼图；学校总奖惩情况图：根据学生的奖惩情况数量以及对应奖惩的等级进行对应饼图的绘制，并将奖励情况和惩罚情况绘制在同一张表上；学籍变成情况图：根据学生学籍管理模块的学籍变动情况进行绘制，计算每种学籍情况对应的学生数量进行可视化绘制即可。</p><h2 id="🎯管理员管理模块"><a href="#🎯管理员管理模块" class="headerlink" title="🎯管理员管理模块"></a>🎯管理员管理模块</h2><p>管理员管理模块界面如下图所示，该模块实现了对所有可登录系统的用户的信息管理（用户名、昵称、邮箱，手机号、身份等）。同样可以实现用户添加、删除和修改操作，对应逻辑与学生信息管理相同，因此这里也不做过多赘述了。<br><img src="https://i.imgtg.com/2023/07/18/OFkyfp.png#id=DRu4x&originHeight=1040&originWidth=2252&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🥁用户登录系统"><a href="#🥁用户登录系统" class="headerlink" title="🥁用户登录系统"></a>🥁用户登录系统</h1><p>点击系统界面右上角用户头像，即可进入对应界面，点击退出进入系统登录界面。使用“用户”账号——账号：custom 密码：123456即可进入普通用户界面。<br><img src="https://i.imgtg.com/2023/07/18/OFkpKY.png#height=237&id=H9mGo&originHeight=474&originWidth=774&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=387"><br><img src="https://i.imgtg.com/2023/07/18/OFkJ0v.png#id=K4Q3q&originHeight=934&originWidth=1580&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>用户系统界面主界面如上图所示，总体而言与管理员系统界面相类似，具体区别如下：普通用户系统中的学生管理部分仅能实现对学生信息、学籍信息、学生成绩的查询，而没有对其增删改的权限；同时也对管理员部分进行了隐藏，普通用户没有可以查看和修改登录用户的权力。</p><h1 id="🥁总结"><a href="#🥁总结" class="headerlink" title="🥁总结"></a>🥁总结</h1><p>本次数据库课程设计所实现的是学籍管理系统，总的来说最终所呈现的系统还是基本符合我们的预期的，但还是有很多地方值得我们去学习和改进。<br>从整个设计过程来说，在最开始确定选题后我们小组就提过网上查阅、内部讨论等手段，明确该课题的各种需求，通过绘制E-R图、数据流图与数据字典等确定需求分析。<br>有了之前数据库实验的经验，整个学籍管理系统的后端数据库的建立部分对我们来说还是很得心应手的。我们使用Navicat简化数据库的创建、表结构设计、数据导入导出等操作，提高开发效率。利用Navicat的直观的数据可视化界面，进行数据查询和管理。而前端部分则是我们比较头疼和花费了很大一部分精力的地方。由于之前我们并没有前后端分离软件系统的经验，因此我们参考了很多相关的项目，最后决定使用Vue作为前端技术栈，ElementUI作为界面组件库，可以很好地实现前端界面的开发和交互。同时，使用Node.js作为后端服务器，可以提供高性能和可扩展性。通过这样的架构，前后端开发团队可以独立进行开发，提高开发效率并减少耦合。在整个实现过程中，通过API进行数据交互是我们比较头疼的点，确保接口的一致性和数据传递的准确性对我们来说还是花了较多的时间的。<br>从团队协作方面来说，我们小组在数据库课设之前还一同实现了计网等课设，因此团队之间的协作和分工还是很得心应手的。在确定对应的需求后，我们便将学籍管理系统分为学生信息管理模块、学生学籍管理模块、学生体检管理模块、学生成绩管理模块等，并各自对相应模块进行后端数据库的实现和对应接口的编写。再由我和缪蕊忆同学完成前端以及前后端部分的连接，由王玫同学对数据库的整体系统进行完善和改进，增加如触发器、函数等部分使其能够更好的实现我们所想要实现的功能。<br>经过不断的调试，最终实现了我们的系统，由于本学期有实现数据可视化的经验，因此经过我们团队讨论，在增加界面友好性方面就准备将我们的所学利用起来，对如学生籍贯、学生奖惩情况等信息实现数据的可视化，一方面可以增加前端部分的可读性和界面的美化，另一方面也可以对我们的所学进行一定的巩固。总体来说，这次的团队协作还是十分顺利的，通过团队成员之间的协作和沟通也是达到了1+1+1&gt;3的效果。<br>从验收过程来说，在验收过程中，我们也是与老师介绍了我们的整体设计思路并演示了我们的整个系统过程，还是很顺利的。在与老师的沟通交流中，我们也是发现了很多我们在设计过程中没有考虑到的问题，比如学生体检信息可以将其分为不同的学期、学生学籍部分可以对此进行扩充等等，这些都是我们在一开始需求分析中所忽视的。在验收过程中我们也明确了我们的学籍管理系统在未来可以前进的方向，受益匪浅。<br>总的来说，我对于这次数据库课设还是比较满意的，在学习和解决困难的过程中提高了我学习的能力、解决问题的能力和实际工作的能力，学到了许多书本以外的知识，也提高了自己的分析和解决问题的能力。同时也非常感谢老师的指导和小组的另外两位同学对于我的课程设计所提出的建议和帮助！</p><h1 id="🥁附录——参考文献"><a href="#🥁附录——参考文献" class="headerlink" title="🥁附录——参考文献"></a>🥁附录——参考文献</h1><p>[1] 王珊，《数据库系统概论》，高等教育出版社，2005。<br>[2] Abraham Silberschatz,Henry F.Korth，《数据库系统概念》，机械工业出版社，2008。<br>[3] 刘勇，周学军，《SQL Server 2000 基础教程》，人民邮电出版社，2007。<br>[4] 贾铁军，《数据库应用与技术》，中国铁道出版社。</p><h1 id="🥁附录"><a href="#🥁附录" class="headerlink" title="🥁附录"></a>🥁附录</h1><p>项目源代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">https://github.com/xiayi0409/Cassie/tree/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——存储器</title>
      <link href="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1689602453943-716f11a7-8be5-404e-92ba-3f5b2856135a.png#averageHue=%23ededed&clientId=u79ad2ae1-1458-4&from=paste&height=653&id=u07dd1c46&originHeight=1306&originWidth=1237&originalType=binary&ratio=2&rotation=0&showTitle=false&size=841135&status=done&style=none&taskId=u6b800b6b-268d-4dac-b2a4-c8a2f8ae755&title=&width=618.5" alt="image.png"></p><h1 id="🍬概述"><a href="#🍬概述" class="headerlink" title="🍬概述"></a>🍬概述</h1><h2 id="🧁存储器分类"><a href="#🧁存储器分类" class="headerlink" title="🧁存储器分类"></a>🧁存储器分类</h2><h3 id="🍯按存储介质分类"><a href="#🍯按存储介质分类" class="headerlink" title="🍯按存储介质分类"></a>🍯按存储介质分类</h3><ol><li>半导体存储器</li><li>磁表面存储器</li><li>磁芯存储器</li><li>光盘存储器</li></ol><h3 id="🍯按存取分类"><a href="#🍯按存取分类" class="headerlink" title="🍯按存取分类"></a>🍯按存取分类</h3><ol><li>存取时间与物理地址无关（随机访问）<ol><li>随机存储器——在程序的执行过程中可读可写</li><li>只读存储器——在程序的执行过程中只读</li></ol></li><li>存取时间与物理地址有关（串行访问）<ol><li>顺序存取存储器——数据按顺序从存储载体的始端读出或读入，因而存取时间的长短与信息所在位置有关</li><li>直接存取存储器——直接定位到要读写的数据块，在读写某个数据块时按顺序进行（磁盘）</li><li>相联存储器——按内容检索到存储位置进行读写（块表）</li></ol></li></ol><h3 id="🍯按在计算机中的作用分类"><a href="#🍯按在计算机中的作用分类" class="headerlink" title="🍯按在计算机中的作用分类"></a>🍯按在计算机中的作用分类</h3><p><img src="https://i.imgtg.com/2023/07/14/OzRjOv.md.png#height=250&id=QNq7b&originHeight=500&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=432"></p><h3 id="🍯按断电后信息的可保存性分类"><a href="#🍯按断电后信息的可保存性分类" class="headerlink" title="🍯按断电后信息的可保存性分类"></a>🍯按断电后信息的可保存性分类</h3><ol><li>非易失（不挥发）性存储器</li><li>易失性存储器</li></ol><h3 id="🍯按功能-x2F-容量-x2F-速度-x2F-所在位置分类"><a href="#🍯按功能-x2F-容量-x2F-速度-x2F-所在位置分类" class="headerlink" title="🍯按功能&#x2F;容量&#x2F;速度&#x2F;所在位置分类"></a>🍯按功能&#x2F;容量&#x2F;速度&#x2F;所在位置分类</h3><ol><li>寄存器</li><li>高速缓存</li><li>内存储器</li><li>外存储器</li></ol><h2 id="🧁存储器的层次结构"><a href="#🧁存储器的层次结构" class="headerlink" title="🧁存储器的层次结构"></a>🧁存储器的层次结构</h2><p><img src="https://i.imgtg.com/2023/07/14/OzR6Lc.md.png#height=250&id=K5a8S&originHeight=500&originWidth=1002&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=501"></p><h3 id="🍯三级存储器结构"><a href="#🍯三级存储器结构" class="headerlink" title="🍯三级存储器结构"></a>🍯三级存储器结构</h3><p>由高速缓冲存储器、主存储器和外存储器组成</p><ol><li>内存储器——CPU能直接访问的存储器——高速缓冲存储器+主存储器</li><li>外存储器——CPU不能直接访问的存储器，外存储器的信息必须调入内存储器后才能由CPU进行处理</li></ol><p><img src="https://i.imgtg.com/2023/07/14/OzR8ur.md.png#height=250&id=bLlOG&originHeight=500&originWidth=858&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=429"></p><h3 id="🍯Cache-主存存储层次（Cache存储系统）"><a href="#🍯Cache-主存存储层次（Cache存储系统）" class="headerlink" title="🍯Cache-主存存储层次（Cache存储系统）"></a>🍯Cache-主存存储层次（Cache存储系统）</h3><p><img src="https://i.imgtg.com/2023/07/14/OzR391.png#height=209&id=uN9lx&originHeight=418&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=441"><br>——解决CPU和主存速度不匹配问题<br>从CPU看，速度接近Cache，容量是主存的容量，价格接近于主存<br>由于Cache存储系统全部采用硬件来调度，因此对系统程序员和应用程序员是透明的</p><h3 id="🍯主存-辅存存储层次（虚拟存储系统）"><a href="#🍯主存-辅存存储层次（虚拟存储系统）" class="headerlink" title="🍯主存-辅存存储层次（虚拟存储系统）"></a>🍯主存-辅存存储层次（虚拟存储系统）</h3><p><img src="https://i.imgtg.com/2023/07/14/OzRwTI.png#height=199&id=uvngc&originHeight=397&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=450"><br>——主要解决主存容量不足而提出的<br>从CPU看，速度接近于主存，容量是虚拟的地址空间，每位价格是接近辅存的价格<br>由于虚拟存储系统需要通过操作系统来调度，因此对系统程序员是不透明的，但对应用程序员是透明的</p><h1 id="🍬主存储器"><a href="#🍬主存储器" class="headerlink" title="🍬主存储器"></a>🍬主存储器</h1><h2 id="🧁概述"><a href="#🧁概述" class="headerlink" title="🧁概述"></a>🧁概述</h2><h3 id="🍯主存的基本组成"><a href="#🍯主存的基本组成" class="headerlink" title="🍯主存的基本组成"></a>🍯主存的基本组成</h3><p><img src="https://i.imgtg.com/2023/07/14/OztMvD.md.png#height=250&id=RLP6W&originHeight=500&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=392"></p><h3 id="🍯主存和CPU的联系"><a href="#🍯主存和CPU的联系" class="headerlink" title="🍯主存和CPU的联系"></a>🍯主存和CPU的联系</h3><p><img src="https://i.imgtg.com/2023/07/14/OztoO6.md.png#height=250&id=FgKVC&originHeight=500&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></p><h3 id="🍯主存中存储单元的分配"><a href="#🍯主存中存储单元的分配" class="headerlink" title="🍯主存中存储单元的分配"></a>🍯主存中存储单元的分配</h3><ol><li>大端方式——将信息的高位字节先送入存储器的低位存储起来</li><li>小端方式</li></ol><h3 id="🍯主存的性能指标"><a href="#🍯主存的性能指标" class="headerlink" title="🍯主存的性能指标"></a>🍯主存的性能指标</h3><ol><li>存储容量——主存存放二进制代码的总数量</li><li>存储速度——存取时间TA（读出时间，写入时间）存取周期TMC（读周期，写周期）</li><li>存储器的带宽——单位时间内存储器存取的信息量<ol><li>提高主存的带宽的措施<ol><li>缩短存取周期</li><li>增加存储字长</li><li>增加存储体</li></ol></li></ol></li><li>可靠性——在指定时间内，存储器无故障读写的概率</li><li>功耗</li></ol><h2 id="🧁半导体存储芯片简介"><a href="#🧁半导体存储芯片简介" class="headerlink" title="🧁半导体存储芯片简介"></a>🧁半导体存储芯片简介</h2><h3 id="🍯基本结构"><a href="#🍯基本结构" class="headerlink" title="🍯基本结构"></a>🍯基本结构</h3><p><img src="https://i.imgtg.com/2023/07/14/OztqNP.png#height=203&id=fyb3c&originHeight=405&originWidth=1224&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=612"><br>——当芯片片选信号CS有效时，芯片被选中，此片所连的地址线才有效，才能对它进行读写操作</p><h3 id="🍯译码驱动方式"><a href="#🍯译码驱动方式" class="headerlink" title="🍯译码驱动方式"></a>🍯译码驱动方式</h3><ol><li>线选法（单译码）</li><li>重合法（双译码）</li></ol><h2 id="🧁随机存储器RAM"><a href="#🧁随机存储器RAM" class="headerlink" title="🧁随机存储器RAM"></a>🧁随机存储器RAM</h2><h3 id="🍯静态RAM（SRAM）"><a href="#🍯静态RAM（SRAM）" class="headerlink" title="🍯静态RAM（SRAM）"></a>🍯静态RAM（SRAM）</h3><p>通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同时多个存储元构成一个存储单元。若干存储单元的集合构成存储体。<br>SRAM的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生。SRAM存取速度快，但集成低，功耗较大，一般用来组成高速缓冲存储器。</p><h3 id="🍯动态RAM（DRAM）"><a href="#🍯动态RAM（DRAM）" class="headerlink" title="🍯动态RAM（DRAM）"></a>🍯动态RAM（DRAM）</h3><p>和SRAM的存储原理不同，DRAM（动态随机存储器）是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，因此比SRAM的密度要高很多。<br>DRAM采用地址复用技术，地址线是原来的1&#x2F;2，且地址信号分行、列两次传送。相对于SRAM来说，DRAM具有容易集成、价位低、容量大和功耗低等优点，但DRAM的存取速度比SRAM的慢，一般用来组成大容量主存系统。</p><ul><li><strong>刷新</strong>——刷新是将元信息读出，再由刷新放大器形成元信息并重新写入的再生过程。<ul><li>刷新过程对CPU透明，<strong>按行进行</strong>。</li><li>集中式、分散式、异步刷新（分散刷新与集中刷新的结合）</li></ul></li></ul><h3 id="🍯SRAM和DRAM比较"><a href="#🍯SRAM和DRAM比较" class="headerlink" title="🍯SRAM和DRAM比较"></a>🍯SRAM和DRAM比较</h3><p><img src="https://i.imgtg.com/2023/07/14/Oztzya.md.png#height=375&id=hYRt6&originHeight=500&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=557"></p><h2 id="🧁只读存储器ROM"><a href="#🧁只读存储器ROM" class="headerlink" title="🧁只读存储器ROM"></a>🧁只读存储器ROM</h2><h3 id="🍯掩膜ROM（MROM）"><a href="#🍯掩膜ROM（MROM）" class="headerlink" title="🍯掩膜ROM（MROM）"></a>🍯掩膜ROM（MROM）</h3><p>以元件的“有&#x2F;无”表示“1&#x2F;0”</p><h3 id="🍯PROM（一次性编程）"><a href="#🍯PROM（一次性编程）" class="headerlink" title="🍯PROM（一次性编程）"></a>🍯PROM（一次性编程）</h3><p>允许用户利用专门的设备（编程器）写入自己的程序，但一旦写入后，其内容将无法改变</p><h3 id="🍯EPROM（多次性编程）"><a href="#🍯EPROM（多次性编程）" class="headerlink" title="🍯EPROM（多次性编程）"></a>🍯EPROM（多次性编程）</h3><p>可由用户利用编程器写入信息，可以多次改写<br>可以分为紫外线擦除、电擦除</p><ul><li>EPROM不能替代RAM<ul><li>EPROM的编程次数是有限的</li><li>EPROM擦除和写入时间过长</li></ul></li></ul><h3 id="🍯Flash-Memory（快擦型存储器）闪存"><a href="#🍯Flash-Memory（快擦型存储器）闪存" class="headerlink" title="🍯Flash Memory（快擦型存储器）闪存"></a>🍯Flash Memory（快擦型存储器）闪存</h3><p>既可在不加电情况下长期保存信息，又能在线进行快速擦除与重写</p><h3 id="🍯总结"><a href="#🍯总结" class="headerlink" title="🍯总结"></a>🍯总结</h3><p>ROM中一旦有了信息，就不能轻易改变，机试掉电也不会丢失，它在计算机系统中是只供读出的存储器。ROM器件有两个显著特点：</p><ol><li>结构简单，位密度比可读写内存储器高</li><li>具有非易失性，可靠性高</li></ol><p><img src="https://i.imgtg.com/2023/07/14/OztCii.md.png#id=VUzEG&originHeight=500&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🧁存储器与CPU的连接"><a href="#🧁存储器与CPU的连接" class="headerlink" title="🧁存储器与CPU的连接"></a><strong>🧁</strong>存储器与CPU的连接</h2><p><strong>存储器容量的扩展</strong>：由于单个芯片的存储器容量有限，为了组成较大容量的存储器，需要多个芯片进行组合。</p><ol><li>位扩展——增加存储字长</li><li>字扩展——增加存储字数量</li><li>字位同时扩展</li></ol><h3 id="🍯扩展"><a href="#🍯扩展" class="headerlink" title="🍯扩展"></a>🍯<strong>扩展</strong></h3><h4 id="🌮位扩展"><a href="#🌮位扩展" class="headerlink" title="🌮位扩展"></a>🌮位扩展</h4><p>——<strong>增加存储字长</strong><br>参与位扩展的多块芯片的CS引脚要连接在一起，保证多个芯片同时工作，并行送出多个位，达到位扩展的目标。</p><h4 id="🌮字扩展"><a href="#🌮字扩展" class="headerlink" title="🌮字扩展"></a>🌮<strong>字扩展</strong></h4><p>——<strong>增加存储字的数量</strong><br>参与字扩展的多块芯片分时工作，每块芯片的地址范围不同，通常用未直接连到芯片上的地址的高位经过非门或者译码器等来连接不同芯片的CS引脚，从而保证参与字扩展的芯片的分时工作且地址范围不同</p><h4 id="🌮字、位扩展"><a href="#🌮字、位扩展" class="headerlink" title="🌮字、位扩展"></a>🌮<strong>字、位扩展</strong></h4><p>参与位扩展的多块芯片的CS引脚连接在一起。参与字扩展的多块芯片：通常用未直接连到芯片上的地址的高位经过非门或者译码器等来连接不同芯片的CS引脚，从而保证参与字扩展的芯片的地址范围不同</p><h3 id="🍯存储器与CPU的连接"><a href="#🍯存储器与CPU的连接" class="headerlink" title="🍯存储器与CPU的连接"></a>🍯<strong>存储器与CPU的连接</strong></h3><ol><li>地址线的连接</li><li>数据线的连接</li><li>读&#x2F;写线的连接</li><li>合理选用芯片，片选信号的连接</li><li>其他</li></ol><h2 id="🧁存储器的校验"><a href="#🧁存储器的校验" class="headerlink" title="🧁存储器的校验"></a><strong>🧁</strong>存储器的校验</h2><p>数据校验码——带有发现某些错误或带有自动纠错能力的数据编码系统<br>数据校验码检错纠错方法——<strong>冗余校验</strong></p><ul><li>由若干位代码组成的一个字叫“码字”</li><li>两个码字中具有不同代码位的个数叫这两个码字间的“距离”</li><li>码制中各码字间最小距离为“码距”，它就是这个码制的距离。</li></ul><p>奇偶校验码、海明校验码、循环冗余校验码（CRC）</p><ul><li>编码的纠错 、检错能力与编码的最小距离有关</li></ul><p><strong>L-1&#x3D;D+C（D≥C）</strong><br>L ：编码的最小距离<br>D ：检测错误的位数<br>C ：纠正错误的位数<br><strong>海明码是具有一位纠错能力的编码</strong></p><h3 id="🍯奇偶校验码"><a href="#🍯奇偶校验码" class="headerlink" title="🍯奇偶校验码"></a><strong>🍯奇偶校验码</strong></h3><p>奇校验：每个码字（包括校验位）中1的个数为奇数<br>偶校验：每个码字（包括校验位）中1的个数为偶数<br> 码距b&#x3D;2</p><h3 id="🍯海明校验码"><a href="#🍯海明校验码" class="headerlink" title="🍯海明校验码"></a>🍯<strong>海明校验码</strong></h3><p>基本思想——分组校验</p><h2 id="🧁提高访存速度的措施"><a href="#🧁提高访存速度的措施" class="headerlink" title="🧁提高访存速度的措施"></a><strong>🧁</strong>提高访存速度的措施</h2><ol><li>采用高速器件</li><li>采用cache（高速缓冲存储器）</li><li>采用并行存储器（多提交叉存储器）</li><li>采用多端口存储器</li><li>采用相联存储器，加长存储器的字长</li></ol><h3 id="🍯单体多字并行主存系统"><a href="#🍯单体多字并行主存系统" class="headerlink" title="🍯单体多字并行主存系统"></a>🍯单体多字并行主存系统</h3><p>对于单体存储器，可以在一个存储周期内并行读出多个指令，通过<strong>提高整体信息吞吐率</strong>来提高访存速度。<br>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。单体多字系统在一个存取周期内从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1&#x2F;m存取周期，CPU向主存存取一条指令</p><ul><li><strong>增加存储器的带宽，可以提高单体存储器的工作速度</strong></li></ul><p>指令和数据在主存中必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显了。</p><h3 id="🍯多体并行系统"><a href="#🍯多体并行系统" class="headerlink" title="🍯多体并行系统"></a>🍯多体并行系统</h3><p>计算机中大容量的主存，可由多个存储体组成，每个存储体都具有自己的读写线路、地址寄存器和数据寄存器，称为“存储模块”。这种多模块存储器可以实现重叠与交叉存取。<br>——由多体模块组成。每个模块都有相同的容量和存取速度每个模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们可并行工作也可交叉工作。</p><ol><li>高位交叉（顺序方式，各个体并行工作）</li><li>地位交叉（交叉方式，各个体轮流编址）<ol><li>在不改变存取周期的前提下，增加存储器的带宽</li></ol></li><li>存储器控制部件（存控）<ol><li>易发生代码丢失的请求源，优先级最高</li><li>严重影响 CPU工作的请求源，给予次高优先级</li></ol></li></ol><h3 id="🍯高性能存储芯片"><a href="#🍯高性能存储芯片" class="headerlink" title="🍯高性能存储芯片"></a>🍯高性能存储芯片</h3><ol><li>SDRAM</li><li>RDRAM</li><li>带Cache的DRAM</li></ol><h3 id="🍯双端口存储器"><a href="#🍯双端口存储器" class="headerlink" title="🍯双端口存储器"></a>🍯双端口存储器</h3><p>双端口随机存储器DPARAM(Dual-port Access RAM)由两个访问端口，即两套MAR、MDR、地址译码器和读写电路，两个端口分别连接两套独立总线，同时接收来自两方的访存请求，使存储器并行工作。<br><img src="https://i.imgtg.com/2023/07/14/Oz4Qkt.png#id=ZAeAs&originHeight=419&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>两个访问端口<strong>独立工作互不干扰</strong>，只有当两个端口试图在同一时间访问同一地址单元，才会发生冲突。</p><h1 id="🍬高速缓冲存储器"><a href="#🍬高速缓冲存储器" class="headerlink" title="🍬高速缓冲存储器"></a>🍬高速缓冲存储器</h1><h2 id="🧁概述-1"><a href="#🧁概述-1" class="headerlink" title="🧁概述"></a>🧁概述</h2><p>避免CPU“空等”现象，CPU和主存（DRAM）的速度差异<br><img src="https://i.imgtg.com/2023/07/17/Oz3bMU.png#height=183&id=UV8yN&originHeight=365&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=417"><br>理论依据——<strong>程序访问的局部性原理</strong>——在一个较短的时间间隔内，CPU对局部范围的存储器地址频繁访问，而对此地址范围外的地址访问很少。<br>Cache是一种小容量高速缓冲存储器，它由SRAM组成。Cache直接制作在CPU芯片内，速度几乎与CPU一样快。程序运行时，CPU使用的一部分数据&#x2F;指令会预先成批拷贝在Cache中，Cache的内容是主存储器中部分内容的映象。<br>当CPU需要从内存读（写）数据或指令时，先检查Cache，若有，就直接从Cache中读取而不用访问主存储器。</p><h3 id="🍯Cache工作原理"><a href="#🍯Cache工作原理" class="headerlink" title="🍯Cache工作原理"></a>🍯Cache工作原理</h3><h4 id="🌮主存和缓存的编址"><a href="#🌮主存和缓存的编址" class="headerlink" title="🌮主存和缓存的编址"></a>🌮<strong>主存和缓存的编址</strong></h4><p>主存由2^n个可编制的字组成，每个字都有唯一的n位地址。为了与Cache映射，将主存与缓存都分为若干块，每块内又包含若干个字，并使它们的块大小相同。<br><img src="https://i.imgtg.com/2023/07/17/Oz3DOa.md.png#height=250&id=IMy9K&originHeight=500&originWidth=785&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=393"></p><h4 id="🌮命中与未命中"><a href="#🌮命中与未命中" class="headerlink" title="🌮命中与未命中"></a>🌮<strong>命中与未命中</strong></h4><p>缓存共有C块，主存共有M块  M&gt;&gt;C</p><ul><li>命中（hit）——主存块调入缓存，主存块与缓存块建立了对应关系<ul><li>用标记记录与某缓存块建立了对应关系的主存块块号</li></ul></li><li>未命中（缺失miss）<ul><li>主存块为调入缓存，主存块与缓存块未建立对应关系</li></ul></li></ul><h4 id="🌮Cache的命中率（hit-rate）"><a href="#🌮Cache的命中率（hit-rate）" class="headerlink" title="🌮Cache的命中率（hit rate）"></a>🌮<strong>Cache的命中率（hit rate）</strong></h4><p>——CPU欲访问的信息在Cache中的比率<br>在程序执行期间，设Nc为访问Cache命中的次数，Nm为访问主存总次数，命中率为h<br>$h&#x3D;\frac{N c}{N c+N m}$</p><ul><li>命中率与Cache的<strong>容量</strong>与<strong>块长</strong>有关</li></ul><h3 id="🍯Cache的基本结构"><a href="#🍯Cache的基本结构" class="headerlink" title="🍯Cache的基本结构"></a>🍯Cache的基本结构</h3><p><img src="https://i.imgtg.com/2023/07/17/Oz39LY.md.png#height=375&id=erpop&originHeight=500&originWidth=788&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=591"><br>Cache主要由Cache存储体、地址映射变换机构、Cache替换机构几大模块组成。</p><h3 id="🍯Cache的读写操作"><a href="#🍯Cache的读写操作" class="headerlink" title="🍯Cache的读写操作"></a>🍯Cache的读写操作</h3><p><img src="https://i.imgtg.com/2023/07/17/Oz3juv.md.png#id=KXoml&originHeight=500&originWidth=773&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当CPU发出主存地址后，首先判断该存储字是否在Cache中，若命中，直接访问Cache，将该字送至CPU，若未命中，一方面要访问主存，将该字传入CPU，于此同时要将该字所在的主存块装入Cache，如果此时Cache已装满，即已无法将主存块调入Cache内时，就要采取替换策略。<br>——如何使Cache与内存内容保持一致的问题</p><h4 id="🌮写直达法write-through"><a href="#🌮写直达法write-through" class="headerlink" title="🌮写直达法write-through"></a>🌮<strong>写直达法write-through</strong></h4><p>写操作时数据<strong>既写入Cache又写入主存</strong>，写操作时间就是访问主存的时间，读操作时不涉及对主存的写操作，更新策略比较容易实现</p><ul><li>命中时：把数据写入Cache的相应块中的同时，也写入其在主存的对应块中</li><li>未命中时：可先把数据写入主存，如果写入主存的数据不需要换入Cache，则结束操作；如果需要换入Cache，直接覆盖掉Cache中对应块即可，因为此块在主存中必有备份，不需要担心数据丢失</li></ul><h4 id="🌮写回法write-back"><a href="#🌮写回法write-back" class="headerlink" title="🌮写回法write-back"></a>🌮<strong>写回法write-back</strong></h4><p>写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存。写操作时间就是访问Cache的时间，读操作Cache失效发生数据替换时，被替换的块需写回主存，增加了Cache的复杂性</p><ul><li>命中时：先把数据写入Cache，仅当被修改的Cache块需要换出时才写回其在主存中对应的块</li><li>未命中时：需要从主存中找出包含此字的数据块。CPU不会在主存中直接修改，而是找到之后直接复制到Cache中进行修改，等从Cache中换出此块时，再复制到主存</li></ul><h4 id="🌮Cache的改进"><a href="#🌮Cache的改进" class="headerlink" title="🌮Cache的改进"></a>🌮<strong>Cache的改进</strong></h4><ol><li>增加Cache的级数——片载Cache 片外Cache</li><li>统一缓存和分开缓存</li></ol><h2 id="🧁Cache映射"><a href="#🧁Cache映射" class="headerlink" title="🧁Cache映射"></a>🧁Cache映射</h2><ul><li>把访问的局部主存区域取到Cache中时，该放到Cache的何处？</li></ul><p>——Cache槽比主存块少，多个主存块映射到一个Cache槽中</p><ul><li>地址映象与变换</li></ul><p>——在主存的地址和Cache地址之间建立一种确定的逻辑关系，也就是根据主存的地址来构建Cache地址。这种地址间的逻辑关系称为映射。</p><ul><li>如何进行映射&#x2F;映象</li></ul><ol><li>把主存空间划分成大小相等的主存块（Block）</li><li>Cache中存放一个主存块的对应单位称为槽（Slot）或行（line）或块（Block）</li><li>将主存块和Cache行按照以下三种方式进行映射<ol><li><strong>直接</strong>——每个主存块映射到Cache的固定行中</li><li><strong>全相联</strong>——每个主存块映射到Cache的任意行中</li><li><strong>组相联</strong>——每个主存块映射到Cache的固定组中的任意一行中</li></ol></li></ol><h3 id="🍯直接映像"><a href="#🍯直接映像" class="headerlink" title="🍯直接映像"></a>🍯直接映像</h3><p>把主存的每一块映射到Cache中的一个固定的Cache行（槽）的方式<br>地址变换速度快，但块冲突的概率较高，当程序往返访问两个相互冲突的块中的数据时，Cache的命中率将急剧下降</p><ul><li>映射公式：Cache行号&#x3D;主存块号 mod Cache行数</li></ul><p><img src="https://i.imgtg.com/2023/07/17/OFoCdl.md.png#id=cNPxj&originHeight=500&originWidth=790&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>特点：</p><ol><li>容易实现，命中时间短</li><li>无需考虑淘汰（替换）问题</li><li>不够灵活，Cache存储空间得不到充分利用，命中率低</li></ol><h3 id="🍯全相联映像"><a href="#🍯全相联映像" class="headerlink" title="🍯全相联映像"></a>🍯全相联映像</h3><p>每个主存块都可映射到任何Cache块的地址映射方式<br>在全相联映射方式下，主存中存储块的数据可调入Cache中任意的块<br>命中率实现比较复杂<br><img src="https://i.imgtg.com/2023/07/17/OFqOeB.md.png#height=375&id=J0loz&originHeight=500&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=509"></p><h3 id="🍯组相联映像"><a href="#🍯组相联映像" class="headerlink" title="🍯组相联映像"></a>🍯组相联映像</h3><p>组相联映像指的是将存储空间分为若干组，主存块与Cache组之间是直接映像，而组内各块之间则是全相联映射<br>将Cache所有行分组，把主存块映射到Cache固定组的任意一行，即：组间直接映射（模映射）、组内全相联映象（全映射）</p><ul><li>Cache组号&#x3D;主存块号 mod Cache组数</li></ul><p>特点：</p><ol><li>结合直接映射和全相联映射的优点。当Cache组数为1时，变为相连映射，当每组只有一个槽时，变为直接映射。</li></ol><p><img src="https://i.imgtg.com/2023/07/17/OFqNjY.md.png#height=375&id=Fs4wY&originHeight=500&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=586"></p><h3 id="🍯Cache中的位数（容量）"><a href="#🍯Cache中的位数（容量）" class="headerlink" title="🍯Cache中的位数（容量）"></a>🍯Cache中的位数（容量）</h3><p>由于每个Cache的地址可能对应于存储器中不同的地址，因此需要在Cache中加标记（tag），标记必须能判断Cache中的字是否为所请求的地址信息<br>标记只包含一位有效位，用于说明Cache块是否能包含有效位置</p><ol><li>Cache不仅存储数据，而且存储标记</li></ol><h2 id="🧁替换算法"><a href="#🧁替换算法" class="headerlink" title="🧁替换算法"></a>🧁替换算法</h2><ol><li>先进先出FIFO——总是把最先进入的那一块淘汰掉</li><li>最近最少使用LRU——总是把最近最少用的那一块淘汰掉</li><li>最不经常使用LFU——替换掉Cache中引用次数最少的块</li><li>随机替换算法——随机地从候选的cache行中选取一个淘汰，与使用情况无关</li></ol><h1 id="🍬辅助存储器"><a href="#🍬辅助存储器" class="headerlink" title="🍬辅助存储器"></a>🍬辅助存储器</h1><ul><li>特点——不直接与CPU交换信息</li><li>磁表面存储器的技术指标<ul><li>记录密度<ul><li>道密度Dt：沿磁盘半径方向长度上的磁道数</li><li>位密度Db：位密度是磁道单位长度上可以记录的二进制代码数位</li></ul></li></ul></li><li><strong>如何增大磁盘片的容量？</strong><ul><li>增加磁道数目——提高磁道密度</li><li>增加扇区数目——提高位密度，并采用可变扇区数</li></ul></li></ul><h2 id="🧁磁表面存储器的技术指标"><a href="#🧁磁表面存储器的技术指标" class="headerlink" title="🧁磁表面存储器的技术指标"></a>🧁磁表面存储器的技术指标</h2><ol><li>存储容量——磁盘存储器可以存储的总字节数<ol><li>格式化容量：是可按照某个特定记录格式利用的磁化单元数，也是用户真正可以使用的容量</li><li>非格式化容量：是磁记录表面可以利用的磁化单元数</li></ol></li><li>平均寻址时间——从读写命令发出后，磁头从某一起始位置出发移动到新的记录位置，到开始从盘片表面读出或写入信息所需要的时间<ol><li>寻道时间：将磁头定位到所要求的磁道上所需要的时间</li><li>等待时间：等待磁道上需要访问的信息到达磁头下的时间</li><li>平均寻址时间＝平均寻道时间＋平均等待时间。</li></ol></li><li>数据传输率——磁盘存储器在单位时间能向主机传送的字节数</li><li>误码率——出错信息位数与读出信息的总位数之比</li></ol><h1 id="🍬虚拟存储器"><a href="#🍬虚拟存储器" class="headerlink" title="🍬虚拟存储器"></a>🍬虚拟存储器</h1><h2 id="🧁概述-2"><a href="#🧁概述-2" class="headerlink" title="🧁概述"></a>🧁概述</h2><h3 id="🍯虚拟存储器"><a href="#🍯虚拟存储器" class="headerlink" title="🍯虚拟存储器"></a>🍯虚拟存储器</h3><p>——建立在主存与辅存物理结构基础之上，由附加硬件设备以及操作系统存储管理软件组成的一种存储体系<br>主存和辅存统一编址，形成一个庞大存储空间，在这个存储空间中，用户可以自由编程<br>编好的程序由计算机操作系统装入辅助存储器中，程序运行时，附加的辅助硬件机构和存储管理软件会把辅存的程序一块块自动调入主存，由CPU执行或从主存调出。</p><h3 id="🍯虚地址和实地址"><a href="#🍯虚地址和实地址" class="headerlink" title="🍯虚地址和实地址"></a>🍯虚地址和实地址</h3><h4 id="🌮虚地址（虚拟地址、逻辑地址）"><a href="#🌮虚地址（虚拟地址、逻辑地址）" class="headerlink" title="🌮虚地址（虚拟地址、逻辑地址）"></a>🌮<strong>虚地址（虚拟地址、逻辑地址）</strong></h4><p>用户编程时指令地址允许涉及到辅存的空间范围。虚地址对应的存储空间称为“虚拟空间”或叫“逻辑空间”</p><h4 id="🌮实地址（主存地址、物理地址）"><a href="#🌮实地址（主存地址、物理地址）" class="headerlink" title="🌮实地址（主存地址、物理地址）"></a>🌮实地址（主存地址、物理地址）</h4><p>实际的主存储器单元的地址实地址对应“主存空间”或称“物理空间”</p><h2 id="🧁虚拟存储器的结构"><a href="#🧁虚拟存储器的结构" class="headerlink" title="🧁虚拟存储器的结构"></a>🧁虚拟存储器的结构</h2><h3 id="🍯段式虚拟存储器"><a href="#🍯段式虚拟存储器" class="headerlink" title="🍯段式虚拟存储器"></a>🍯段式虚拟存储器</h3><p>——内存和辅存调入调出基本单位是段<br>把主存按段分配的存储管理方式。它是一种模块化的存储管理方式，每个用户程序模块可分到一个段，该程序模块只能访问分配给该模块的段所对应的主存空间。段长可以任意设定，并可放大和缩小。<br>系统中通过一个<strong>段表</strong>指明各段在主存中的位置。段表中包括段名(段号)，段起点，装入位和段长等。段表本身也是一个段，段一般是按程序模块分的。</p><ul><li>逻辑地址与物理地址转换——根据该程序的段号查找段表，得到该段首地址，将段首地址与段内偏移地址相加得到物理地址</li></ul><p><img src="https://i.imgtg.com/2023/07/17/OFqS3s.md.png#height=250&id=yKABj&originHeight=500&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=396"></p><ol><li>优点：段的逻辑独立性使它易于编译、管理、修改和保护，还可以实现多道程序共享</li><li>缺点：段的长度各不相同，起点终点不定，不利于调用时在内存中找到合适的空间，常导致在段间留下许多零碎的空余空间，因此不能很好地利用内存存储空间，从而造成浪费。</li></ol><h3 id="🍯页式虚拟存储器"><a href="#🍯页式虚拟存储器" class="headerlink" title="🍯页式虚拟存储器"></a>🍯页式虚拟存储器</h3><p>是把虚拟存储空间和实际空间等分成固定大小的页，各虚拟页可装入主存中的不同实际页面位。页式存储中，处理机逻辑地址由虚页号和页内地址两部分组成，实际地址也分为页号和页内地址两部分，由地址映射机构将虚页号转换成主存的实际页号。页式管理用一个<strong>页表</strong>，包括页号，每页在主存中起始位置，装入位等。页表是虚拟页号与物理页号的映射表。页式管理由操作系统进行，对应用程序员的透明的。<br><img src="https://i.imgtg.com/2023/07/17/OFqciK.md.png#height=250&id=Q9XRM&originHeight=500&originWidth=789&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=395"></p><ol><li>优点：页面起始地址和终止地址是固定的，便于构造页表，新页调入内存也很容易掌握，比段式管理的空间浪费小</li><li>缺点：由于页不是逻辑上独立的实体，所以在处理、保护和共享上都不如段式方便</li></ol><h3 id="🍯段页式虚拟存储器"><a href="#🍯段页式虚拟存储器" class="headerlink" title="🍯段页式虚拟存储器"></a>🍯段页式虚拟存储器</h3><p>上述两种方法的结合，它将存储空间按逻辑模块分成段，每段又分成若干个页，访存通过一个段表和若干个页表进行。段的长度必须是页长的整数倍，段的起点必须是某一页的起点。<br><img src="https://i.imgtg.com/2023/07/17/OFqd4a.md.png#id=f3bsI&originHeight=500&originWidth=821&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li>优点：程序对主存的调入调出是按页面进行的，但又可以按段实现共享和保护。因此兼具了页式和段式系统的优点。</li><li>缺点：地址映射过程中需要多次查表。</li></ol><h3 id="🍯块表TLB"><a href="#🍯块表TLB" class="headerlink" title="🍯块表TLB"></a>🍯块表TLB</h3><p>在虚拟存储器中进行地址变换时，需要虚页号变换成主存中实页号的内部地址变换这一过程缓存时首先要到主存查页表，然后才能根据主存物理地址访问主存的存取指令或数据。因此采用虚拟存储器机制后，访存的次数增加了。<strong>为了减少访存的次数</strong>，往往将页表中最活跃的几个页表项复制到高速缓存中。这种在高速缓存中的页表项称为<strong>快表</strong>（translation look aside buffer）<br>查表时，根据虚页表同时查找快表和慢表，当在快表中查到该虚页号时，就能很快找到对应的实页号，将其送入主存实地址寄存器，同时使慢表的查找作废，这时主存的访问速度没降低多少。如果在快表中查不到，则经过一个访主存的时间延迟后，将从慢表中查到的实页送入实地址寄存器，同时将此虚页号和对应的实页号送入快表。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——网络层</title>
      <link href="/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/14/OzPZ4t.png#id=ng0u3&originHeight=903&originWidth=1183&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>网络层功能——在数据链路层的支持下，为传输层提供源&#x2F;目的主机间的报文分组传输服务</p><h1 id="🍿电路交换和分组交换"><a href="#🍿电路交换和分组交换" class="headerlink" title="🍿电路交换和分组交换"></a>🍿电路交换和分组交换</h1><h2 id="🍔电路交换"><a href="#🍔电路交换" class="headerlink" title="🍔电路交换"></a>🍔电路交换</h2><h3 id="🍟电路交换三个阶段"><a href="#🍟电路交换三个阶段" class="headerlink" title="🍟电路交换三个阶段"></a>🍟电路交换三个阶段</h3><ol><li>建立电路</li></ol><p>在传送数据之前，由发送方发出建立电路请求，交换机根据该请求，设法选择一条空闲的信道连接到接收方。<br>接收方收到该呼叫后，返回一应答信号确认本次连接。</p><ol start="2"><li>传输数据</li></ol><p>建立电路连接后，发送方通过已建立的电路向接收方发送数据。</p><ol start="3"><li>拆除电路</li></ol><p>数据传输完毕，发送方或接收方任一方发出拆线信号，终止电路连接，释放所占用的信道资源。</p><ul><li>优点——实时性，可靠性好。</li><li>缺点——信道利用率低。</li></ul><h2 id="🍔分组交换"><a href="#🍔分组交换" class="headerlink" title="🍔分组交换"></a>🍔分组交换</h2><p>报文——一份完整的信息称为一个报文。<br>分组——报文分组的简称，又叫信息包，将报文划分为若干格式化信息单位作为网络层的数据传输单元，这样的格式化信息单元称为报文分组。</p><h3 id="🍟基本原理"><a href="#🍟基本原理" class="headerlink" title="🍟基本原理"></a>🍟基本原理</h3><p>将一份完整的报文划分为若干组，每个分组以存储&#x2F;转发方式独立的从源结点传输到目的结点，目的结点收到这些分组重新组装成原报文。 </p><h3 id="🍟特点和优缺点"><a href="#🍟特点和优缺点" class="headerlink" title="🍟特点和优缺点"></a>🍟特点和优缺点</h3><ol><li>特点<ol><li>存储转发</li><li>化整为零</li></ol></li><li>优点<ol><li>使多路数据能够复用一条链路，提高链路的利用率。</li><li>有利于差错控制。</li><li>减少结点缓冲区容量。</li></ol></li><li>缺点<ol><li>当网络拥塞时，会导致分组传输延迟增加，尽管对传输的文本文件，二进制文件影响并不大，但对流媒体影响较大。</li></ol></li></ol><h1 id="🍿虚电路和数据报"><a href="#🍿虚电路和数据报" class="headerlink" title="🍿虚电路和数据报"></a>🍿虚电路和数据报</h1><p>分组交换技术的两种实现方式——虚电路、数据报</p><h2 id="🍔虚电路"><a href="#🍔虚电路" class="headerlink" title="🍔虚电路"></a>🍔虚电路</h2><p>通信前发送方和接收方之间必须建立连接（虚电路），所以虚电路是<strong>面向连接的网络服务</strong>。<br>虚电路只是一种逻辑电路，而不是真正的物理电路。<br>一条链路上允许建立多个虚电路。<br>一旦虚电路建立完毕，本地通信的所有分组必须经过该虚电路进行。因此，虚电路能够保证分组的顺序接收。<br>仅当建立虚电路时需要源&#x2F;目的结点地址，数据分组需分配一个虚电路号而无须源&#x2F;目的结点地址。</p><h2 id="🍔数据报"><a href="#🍔数据报" class="headerlink" title="🍔数据报"></a>🍔数据报</h2><p>数据报无需建立连接，每个报文分组携带完整的源&#x2F;目的地址，<strong>独立的选择路径</strong>，通过不同的路径到达目的主机 </p><h3 id="🍟数据报的特征"><a href="#🍟数据报的特征" class="headerlink" title="🍟数据报的特征"></a>🍟数据报的特征</h3><p>无需建立连接就可传输报文分组，因此数据报称为<strong>无连接网络服务</strong>。<br>不同的报文分组可以通过不同的路由到达目的主机，先发出的分组未必先，因此数据报服务不能保证报文分组顺序接收。<br>每个报文分组携带完整的源&#x2F;目的地址，独立的选择路径。</p><h2 id="🍔数据报和虚电路比较"><a href="#🍔数据报和虚电路比较" class="headerlink" title="🍔数据报和虚电路比较"></a>🍔数据报和虚电路比较</h2><p>| </p><p> | <strong>数据报子网</strong> | <strong>虚电路子网</strong> |<br>| — | — | — |<br>| <strong>延时</strong> | 分组传输延时 | 电路建立，分组传输延时 |<br>| <strong>路由选择</strong> | 每个分组单独选择路由 | 建立虚电路时选择路由，以后所有分组都使用该路由 |<br>| <strong>状态信息</strong> | 子网无需保存状态信息 | 每个结点要保存一张虚电路表 |<br>| <strong>地址</strong> | 每个分组包括源和目的的完整地址 | 每个分组含有一个短的虚电路号 |<br>| <strong>结点失败</strong> 的影响** | 除了在崩溃时正在该结点处理的分组都丢失外，无其他影响 | 所有经过失效结点的虚电路都要被终止 |<br>| <strong>拥塞控制</strong> | 难 | 如果有足够的缓冲区分配给已经建立的虚电路，则容易控制 |</p><h1 id="🍿路由选择"><a href="#🍿路由选择" class="headerlink" title="🍿路由选择"></a>🍿路由选择</h1><ul><li>虚电路：需要一次路由选择。</li><li>数据报：每个分组要进行路由选择。</li></ul><p>路由选择——根据某种策略，选择一条最佳路径到达目的主机，对路由器而言，路由选择实质上是选择最佳输出端口。</p><h2 id="🍔静态策略"><a href="#🍔静态策略" class="headerlink" title="🍔静态策略"></a>🍔静态策略</h2><p>——按某种固定的规则进行路由选择，不随网络流量和拓扑结构变化而变化</p><h3 id="🍟扩散法（洪泛法）"><a href="#🍟扩散法（洪泛法）" class="headerlink" title="🍟扩散法（洪泛法）"></a>🍟扩散法（洪泛法）</h3><p>当结点收到一个分组后，把该分组向除进来的链路外的所有其他链路转发，结果至少有一个分组以最快的速度达到目的结点——每个分组设置一个下跳数字段，每经过一个结点，下跳数减1，当下跳数为0时，丢弃该分组。</p><h3 id="🍟固定式路由选择"><a href="#🍟固定式路由选择" class="headerlink" title="🍟固定式路由选择"></a>🍟固定式路由选择</h3><p>每个节点保存一张固定的路由表，当某一分组到达时，根据分组的目的结点，在路由表中找到其对应的输出链路，然后将分组从该链路转发出去。<br>——一般由网管中心根据最佳路由算法为每个路由产生固定路由表并发给该结点。固定路由表一旦生成，就不再改变，除非网管中心重新生成新的路由表。</p><h3 id="🍟最佳路由选择算法"><a href="#🍟最佳路由选择算法" class="headerlink" title="🍟最佳路由选择算法"></a>🍟最佳路由选择算法</h3><p>——最短路径算法——从源到目的结点所花费的费用最小</p><h2 id="🍔动态策略"><a href="#🍔动态策略" class="headerlink" title="🍔动态策略"></a>🍔动态策略</h2><p>动态策略根据当前<strong>拓扑结构和流量的变化</strong>来动态改变路由，又称自适应路由。</p><ol><li>孤立路由算法</li><li>集中路由选择</li><li>分布路由选择</li></ol><h3 id="🍟孤立路由选择"><a href="#🍟孤立路由选择" class="headerlink" title="🍟孤立路由选择"></a>🍟孤立路由选择</h3><p>当一个结点收到一个分组后，选择一条输出队列最短的链路尽快的将其转发出去，不管目的结点位于何方。</p><ul><li>优点——提高链路的利用率</li><li>缺点——有很大盲目性</li></ul><h3 id="🍟逆向自学习算法"><a href="#🍟逆向自学习算法" class="headerlink" title="🍟逆向自学习算法"></a>🍟逆向自学习算法</h3><p>每个分组中包含一个结点计数器，每经过一个结点，该结点计数器加1。<br>当一个结点R从链路L收到一个来自源结点S的分组时，如果结点计数器为n，就知道经L到达S的路径的距离不会超过n。<br>若它以前纪录到S的最短路径超过n时，则将链路L作为到达S的最短输出链路，纪录当前最短路径长度n。<br>经过一段时间的自学习，结点R会找到它到其它结点的最短路径及最小距离值。</p><ul><li>优点——对好消息反应灵敏</li><li>缺点——对坏消息无法了解到</li></ul><h3 id="🍟分布路由选择"><a href="#🍟分布路由选择" class="headerlink" title="🍟分布路由选择"></a>🍟分布路由选择</h3><h4 id="🌭距离向量路由选择（D-V算法）"><a href="#🌭距离向量路由选择（D-V算法）" class="headerlink" title="🌭距离向量路由选择（D-V算法）"></a>🌭距离向量路由选择（D-V算法）</h4><p>基本思想：每个结点都保存一张路由表，路由表包括三个主要字段，即目的地址，最短距离、最佳输出链路。与固定路由选择不同的是：相邻结点之间定期交换路由信息（如每隔三十秒），并根据最新路由信息，刷新路由表。<br>要交换的路由信息由二元组（V,D）组成，其中V为目的地址，D为到达目的地址的距离。又称距离向量算法。</p><ul><li>缺点：对网络变化需经若干周期才能作出反应。特别是对好消息反应快，对坏消息反应迟钝。</li><li>优点：运算量和交换的信息量较小</li></ul><h4 id="🌭链路状态路由选择（L-S算法）"><a href="#🌭链路状态路由选择（L-S算法）" class="headerlink" title="🌭链路状态路由选择（L-S算法）"></a>🌭链路状态路由选择（L-S算法）</h4><p>基本思想：每个结点定期广播路由信息，并根据最新路由信息刷新路由表。</p><ol><li>发现邻居节点</li><li>测量链路开销</li><li>产生链路分组</li></ol><p>向所有结点广播L-S分组。结点获得最新L-S状态后，用最短路径算法计算到每个其他结点的最短路由，并刷新路由表。</p><ul><li>优点：对网络反应迅速</li><li>缺点：广播L-S分组占用信道容量大</li></ul><h4 id="🌭L-S算法和D-V算法"><a href="#🌭L-S算法和D-V算法" class="headerlink" title="🌭L-S算法和D-V算法"></a>🌭L-S算法和D-V算法</h4><table><thead><tr><th></th><th><strong>D-V</strong></th><th><strong>L-S</strong></th></tr></thead><tbody><tr><td><strong>交换路由信息</strong></td><td>定期</td><td>网络拓扑结构发生改变（或定期）</td></tr><tr><td><strong>交换范围</strong></td><td>相邻结点</td><td>全网</td></tr><tr><td><strong>路由更新</strong></td><td>缓慢</td><td>迅速</td></tr><tr><td>**适用范围 **</td><td>小规模，变化缓慢的网络</td><td>大规模，变化较激烈的网络</td></tr></tbody></table><h1 id="🍿路由协议简介"><a href="#🍿路由协议简介" class="headerlink" title="🍿路由协议简介"></a>🍿路由协议简介</h1><h2 id="🍔路由信息协议RIP"><a href="#🍔路由信息协议RIP" class="headerlink" title="🍔路由信息协议RIP"></a>🍔路由信息协议RIP</h2><p>——RIP采用D-V算法，用于小规模网络<br>所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。路由选择表——每条路径的目的地，路径的代价<br>所有结点必须参与距离向量交换，以保证路由的有效性和一致性，所有的结点都监听从其他结点传来的路由选择更新信息，并选择是否更新路由选择表。</p><ol><li>网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录（因此这是一组距离，称为距离向量）。</li><li>距离也称跳数(Hop Count), 规定从一个路由器到直接连接网络的距离（跳数）为1 。而每经过一个路由器，距离（跳数）加1 。</li><li>RIP认为好的路由就是它通过的路由器的数目少，即优先选择跳数少的路径。</li><li>RIP允许一条路径最多只能包含15个路由器（即最多允许15跳）。因此距离等于16时，它表示网络不可达。可见RIP只适用于小型互联网。距离向量路由可能会出现环路的情况，规定路径上的最高跳数的目的是为了防止数据报不断循环在环路上，减少网络拥塞的可能性。</li><li>RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表（动态维护）。</li></ol><h2 id="🍔开放最短路由优先协议OSPF"><a href="#🍔开放最短路由优先协议OSPF" class="headerlink" title="🍔开放最短路由优先协议OSPF"></a>🍔开放最短路由优先协议OSPF</h2><p>——OSPF采用L-S算法</p><ol><li>OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是<strong>洪泛法</strong>。而RIP 仅向自已相邻的几个路由器发送信息。</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。”链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”（或代价）。而在RIP中，发送的信息是本路由器所知道的全部信息，即整u个路由表。</li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，不会出现RIP” 坏消息传得慢＂的问题。而在RIP中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息。</li></ol><p>除以上区别外， OSPF 还有以下特点：</p><ol><li>OSPF对不同的链路可根据IP分组的不同服务类型(TOS) 而设置成不同的代价。因此，OSPF对于不同类型的业务可计算出不同的路由，十分灵活。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为多路径间的负载平衡。</li><li>所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li></ol><h2 id="🍔边界网关协议BGP"><a href="#🍔边界网关协议BGP" class="headerlink" title="🍔边界网关协议BGP"></a>🍔边界网关协议BGP</h2><p>BGP是一个自治域的外部网关协议，是不同自治域间的路由协议。<br>BGP采用改进型的D-V算法，在相邻AS间交换网络可达性信息，并据此进行路由回路检测和基于性能优先和策略约束的路由进行决策。<br>技术特点：<br>路由表中记录到达目的地的确切路由，而不是“距离”，从而解决无穷计算问题。支持策略路由。</p><ol><li>BGP的高层是面向连接的传输层协议，可以提供可靠性保障。</li><li>在BGP的对等体之间是逻辑上的连通而不一定物理直接邻居。</li><li>路由更新时，BGP只发送更新的路由，从而大大减少了传播路由信息时对带宽的占用，适用于在Internet上传播大量的路由信息。</li><li>基于D-V路由协议并进行了优化，在设计上就避免了环路的发生。</li><li>AS之间转发时，只有携带的AS_Path信息标记与途经的AS不同时才允许通过，否则就被丢弃，从而避免了自治域间产生环路。</li><li>BGP提供了丰富的路由策略，能够对路由实现灵活的过滤和选择。</li><li>BGP易于扩展， 能够适应网络新的发展（ipv4单&#x2F;组播、vpv4单&#x2F;组插）。</li></ol><h1 id="🍿IP协议"><a href="#🍿IP协议" class="headerlink" title="🍿IP协议"></a>🍿IP协议</h1><h2 id="🍔概述"><a href="#🍔概述" class="headerlink" title="🍔概述"></a>🍔概述</h2><p>IP提供<strong>无连接的数据报服务</strong>，每个IP分组长度≤64K字节，不能保证分组可靠的、按序到达。</p><h2 id="🍔IP分组结构"><a href="#🍔IP分组结构" class="headerlink" title="🍔IP分组结构"></a>🍔IP分组结构</h2><p><img src="https://i.imgtg.com/2023/07/14/OzJdIX.md.png#height=250&id=bhF3l&originHeight=500&originWidth=1296&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=648"></p><h2 id="🍔IP地址"><a href="#🍔IP地址" class="headerlink" title="🍔IP地址"></a>🍔IP地址</h2><p>TCP&#x2F;IP网络模型将整个Internet视为一个单一的、抽象的网络，<strong>IP地址就是给每个连接在这个网络上的主机、路由器或其他设备分配的一个在全世界范围唯一的 32 位标识符</strong>。</p><h3 id="🍟分类IP地址"><a href="#🍟分类IP地址" class="headerlink" title="🍟分类IP地址"></a>🍟分类IP地址</h3><p>IP地址被分为五类，分别成为A、B、C、D和E类<br>两级的IP地址：IP地址::{&lt;网络号&gt;,&lt;主机号&gt;}<br><img src="https://i.imgtg.com/2023/07/14/OzJVht.md.png#height=375&id=Ks4s8&originHeight=500&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=612"></p><h3 id="🍟划分子网IP地址"><a href="#🍟划分子网IP地址" class="headerlink" title="🍟划分子网IP地址"></a>🍟划分子网IP地址</h3><p>将一个IP类网划分成几个较小的子网，多个物理网共享同一个IP类网前缀<br>IP地址三级结构：IP地址::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</p><ul><li>采用子网掩码来分离网络号和主机号。子网掩码格式：32比特，网络号(包括子网号)部分全为“1”，主机号部分全为“0”。</li></ul><p><img src="https://i.imgtg.com/2023/07/14/OzJfjj.png#height=173&id=fpjui&originHeight=345&originWidth=1133&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=567"></p><h3 id="🍟超网IP地址"><a href="#🍟超网IP地址" class="headerlink" title="🍟超网IP地址"></a>🍟超网IP地址</h3><p>IP地址 ::&#x3D; {&lt;网络前缀&gt;, &lt;主机号&gt;} </p><ul><li>CIDR常使用“斜线记法”(Slash notation)，即在IP地址后面加上一个斜线“&#x2F;”和一个代表网络前缀所占位数的数字，如&#x2F;20。</li><li>将网络前缀都相同的连续的IP地址称为“CIDR地址块”</li></ul><h2 id="🍔IP寻址"><a href="#🍔IP寻址" class="headerlink" title="🍔IP寻址"></a>🍔IP寻址</h2><p>每个路由器中都保存一张路由表（无论是静态还是动态）。路由表的主要项目有两个：网络号、下一跳地址（最佳输出链路）。<br>对于划分子网的IP地址：</p><ul><li>当一个IP分组到达时，路由器通过子网掩码获取其网络号。如果是本网，则启动寻找主机过程；如果是其他网络，则根据路由表中对应网络号的最佳输出链路将分组转发到下一跳路由器。</li><li>如果路由表中找不到目的网络，则将分组转发到一个缺省路由器中，缺省路由器具有更广泛的路由信息。</li></ul><p>对于CIDR：</p><ul><li>应当从匹配结果中选择<strong>具有最长网络前缀的路由</strong>：最长前缀匹配(longest-prefix matching)。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体(more specific) 。最长前缀匹配又称为最长匹配或最佳匹配。</li></ul><h1 id="🍿网际控制报文协议ICMP"><a href="#🍿网际控制报文协议ICMP" class="headerlink" title="🍿网际控制报文协议ICMP"></a>🍿网际控制报文协议ICMP</h1><p>为了提高IP数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。<br>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>ICMP不是高层协议，而是IP层的协议。<br>ICMP报文作为<strong>IP层数据报的数据</strong>，加上数据报的首部，组成IP数据报发送出去。   </p><h2 id="🍔ICMP作用和主要功能"><a href="#🍔ICMP作用和主要功能" class="headerlink" title="🍔ICMP作用和主要功能"></a>🍔ICMP作用和主要功能</h2><p>IP协议提供了以无连接为特征的“尽力而为”的数据通信服务，并不能解决数据包丢失、重复、延迟或乱序等问题。</p><h3 id="🍟目的"><a href="#🍟目的" class="headerlink" title="🍟目的"></a>🍟目的</h3><p>希望对IP包无法传输时提供报告，这些差错报告帮助发送方了解网络中发生了什么问题，以确定应用程序后续操作。</p><h3 id="🍟主要功能"><a href="#🍟主要功能" class="headerlink" title="🍟主要功能"></a>🍟主要功能</h3><ol><li>通告网络错误</li><li>通告网络拥塞</li><li>协助解决故障</li><li>通告超时</li></ol><h2 id="🍔ICMP报文的封装与格式"><a href="#🍔ICMP报文的封装与格式" class="headerlink" title="🍔ICMP报文的封装与格式"></a>🍔ICMP报文的封装与格式</h2><p>ICMP是一个网际层协议，但却需要利用另一个网际层协议–IP协议进行封装，因此ICMP是一种<strong>需要两次封装的网际层协议</strong>。<br><img src="https://i.imgtg.com/2023/07/14/OzPx4B.png#height=163&id=KQca5&originHeight=325&originWidth=1258&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=629"></p><ul><li>ICMP报文是由IP协议封装，因此其也和IP协议一样是一个<strong>不可靠的协议</strong>，既不能保证报文的到达，也不能保证报文按序到达。</li></ul><h2 id="🍔ICMP报文的种类"><a href="#🍔ICMP报文的种类" class="headerlink" title="🍔ICMP报文的种类"></a>🍔ICMP报文的种类</h2><p>ICMP 报文的种类有两种，即<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>。 </p><h1 id="🍿地址解析协议ARP"><a href="#🍿地址解析协议ARP" class="headerlink" title="🍿地址解析协议ARP"></a>🍿地址解析协议ARP</h1><h2 id="🍔MAC地址"><a href="#🍔MAC地址" class="headerlink" title="🍔MAC地址"></a>🍔MAC地址</h2><p>当IP报文被数据链路层协议封装后，包括IP地址在内的IP协议细节均无法被数据链路层协议获得。为了能够在数据链路层的协议中描述源&#x2F;目的节点，需要在数据链路层设计相应的节点标识符，即数据链路层地址。<br>在以太网中，这个地址就称为MAC（Media Access Control）地址。由于数据链路层向下紧邻物理层，受到物理层许多因素的影响，因此也被称为物理地址或硬件地址或机器地址。对应的，IP地址也常常被称为逻辑地址。</p><h3 id="🍟IP地址和MAC地址"><a href="#🍟IP地址和MAC地址" class="headerlink" title="🍟IP地址和MAC地址"></a>🍟IP地址和MAC地址</h3><ul><li>IP地址是网络层使用的地址，它是分层次等级的。</li><li>MAC地址是数据链路层使用的地址，它是平面式的。</li><li>在网络层及网络层之上使用IP地址， IP地址放在IP数据报的首部，而MAC地址放在MAC帧的首部。通过数据封装，把IP数据报分组封装为MAC帧后，数据链路层看不见数据报分组中的IP地址。</li><li>由于路由器的隔离，IP网络中无法通过广播方式依靠MAC地址来完成跨网络的寻址，因此<strong>在IP网络的网络层只使用IP地址来完成寻址</strong>。寻址时，IP每个路由器依据其路由表（依靠静态路由或动态路由协议生成）选择到目标网络（即主机号全为0的网络地址）需要转发到的下一跳（路由器的物理端口号或下一网络地址），而IP分组通过多次路由转发到达目标网络后，改为在目标LAN中通过数据链路层的MAC地址以广播方式寻址。这样可以提高路由选择的效率。</li></ul><p>注意：路由器由于互联多个网络，因此它不仅有多个IP 地址，也有多个硬件地址。</p><h2 id="🍔地址解析协议ARP"><a href="#🍔地址解析协议ARP" class="headerlink" title="🍔地址解析协议ARP"></a>🍔地址解析协议ARP</h2><p>地址解析协议（Address Resolution Protocol，ARP）是IP协议最重要的配套协议之一，其目的就是是<strong>将IP地址转化成MAC（物理或硬件）地址</strong>。</p><h3 id="🍟工作原理"><a href="#🍟工作原理" class="headerlink" title="🍟工作原理"></a>🍟工作原理</h3><p>当主机A有信息向主机B发送时：</p><ul><li>主机A查找本地ARP表，若表中有主机B的IP地址，则按照对应的MAC地址，将要发送的IP包封装成以太帧，并向主机B发送。</li><li>若ARP表中没有主机B的数据项，则以广播方式发出ARP请求包，在本网段内寻找与主机B的MAC地址。</li><li>主机B收到主机A的ARP请求报文后，向主机A发出单播的ARP响应包，并将主机A的IP地址和MAC地址填入自己的ARP表中。</li><li>主机A在收到响应报文后，将主机B的MAC地址填写到自己的ARP表中，按照获得的MAC地址将IP包封装到以太帧，并向主机B发送。</li></ul><h3 id="🍟RARP协议"><a href="#🍟RARP协议" class="headerlink" title="🍟RARP协议"></a>🍟RARP协议</h3><p>RARP正好与ARP相反，知道MAC地址，但不知道IP地址，通过该协议广播询问分组获取IP地址。</p><h1 id="🍿路由器"><a href="#🍿路由器" class="headerlink" title="🍿路由器"></a>🍿路由器</h1><p>路由器主要完成两个功能：一是<strong>路由选择</strong>（确定哪一条路径），二是<strong>分组转发</strong>（当一个分组到达时所采取的动作）。<br>前者是根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。<br>后者处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等。</p><ol><li>路由选择。指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。</li><li>分组转发。指路由器根据转发表将用户的IP数据报从合适的端口转发出去。路由表是根据路由选择算法得出的，而转发表是从路由表得出的。转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——进程管理</title>
      <link href="/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.imgtg.com/2023/07/13/OzACSx.png#id=jZKAq&originHeight=668&originWidth=1182&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></h1><h1 id="🍜进程的基本概念"><a href="#🍜进程的基本概念" class="headerlink" title="🍜进程的基本概念"></a>🍜进程的基本概念</h1><p>程序的顺序执行——顺序性、封闭性、可再现性——整体资源利用率低、单位时间内算题量少<br>程序的并发执行——间断性、失去封闭性、不可再现性</p><h2 id="🍣进程概念"><a href="#🍣进程概念" class="headerlink" title="🍣进程概念"></a>🍣进程概念</h2><p>在多道程序环境下，程序的并发执行代替了程序的顺序执行，程序的活动不再处于封闭系统中，从而出现了许多新特征——进程<br>进程是程序的<strong>运行</strong>过程，是系统进行<strong>资源分配和调度的独立单位</strong></p><ul><li>为什么要引入进程?保证程序在运行时依然保持顺序性、封闭性和可再现性</li></ul><h3 id="🍤程序与进程"><a href="#🍤程序与进程" class="headerlink" title="🍤程序与进程"></a>🍤程序与进程</h3><ol><li>程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li><li>程序是静态的观念，进程是动态的观念；</li><li>进程具有并发性，而程序没有；</li><li>进程是竞争计算机资源的基本单位，程序不是。</li><li>进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序</li></ol><h2 id="🍣进程的特征"><a href="#🍣进程的特征" class="headerlink" title="🍣进程的特征"></a>🍣进程的特征</h2><ol><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li><li>结构特征——程序段、数据段、进程控制块(PCB)</li></ol><h2 id="🍣进程的三种基本状态"><a href="#🍣进程的三种基本状态" class="headerlink" title="🍣进程的三种基本状态"></a>🍣进程的三种基本状态</h2><p><img src="https://i.imgtg.com/2023/07/12/Oz7O0I.png#height=169&id=U4Zr9&originHeight=338&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=260"></p><ol><li>就绪状态Ready</li><li>执行状态Running</li><li>阻塞状态Block</li></ol><p><img src="https://i.imgtg.com/2023/07/12/Oz7xTB.png#height=135&id=E9zvD&originHeight=269&originWidth=1145&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=573"></p><h2 id="🍣进程控制块PCB"><a href="#🍣进程控制块PCB" class="headerlink" title="🍣进程控制块PCB"></a>🍣进程控制块PCB</h2><h3 id="🍤概念"><a href="#🍤概念" class="headerlink" title="🍤概念"></a>🍤概念</h3><p>PCB是OS管理进程的数据结构——位于操作系统内核<br>进程控制块是进程存在的唯一标志</p><h3 id="🍤组织形式"><a href="#🍤组织形式" class="headerlink" title="🍤组织形式"></a>🍤组织形式</h3><p>链接方式、索引方式</p><h1 id="🍜进程控制"><a href="#🍜进程控制" class="headerlink" title="🍜进程控制"></a>🍜进程控制</h1><p>进程创建、进程撤销、进程阻塞、进程唤醒、挂起、激活</p><h1 id="🍜进程同步"><a href="#🍜进程同步" class="headerlink" title="🍜进程同步"></a>🍜进程同步</h1><h2 id="🍣基本概念"><a href="#🍣基本概念" class="headerlink" title="🍣基本概念"></a>🍣基本概念</h2><p>在多道程序的环境中，系统中的多个进程可以并发执行，同时它们又要共享系统中的资源，这些资源有些是可共享使用的，如磁盘，有些是以独占方式使用的，如打印机。由此将会产生错综复杂的进程间相互制约的关系。</p><ol><li>直接相互制约关系：源于进程间合作</li><li>间接相互制约关系：共享某种系统资源</li></ol><p><strong>多个进程因为合作而使得进程的执行有一定的先后顺序。</strong></p><ul><li>为什么需要进程？</li></ul><p>进程有时候会和其他进程共享一些资源，比如内存、数据库等。当多个进程同时读写同一份共享资源的时候，可能会发生冲突。因此需要进程的同步，多个进程按顺序访问资源。</p><h3 id="🍤临界资源"><a href="#🍤临界资源" class="headerlink" title="🍤临界资源"></a>🍤临界资源</h3><p>互斥共享的资源——<strong>一次仅能为一个进程所使用的资源</strong></p><ul><li>硬件资源：打印机</li><li>软件资源：内存变量、指针、数组</li></ul><h3 id="🍤临界区"><a href="#🍤临界区" class="headerlink" title="🍤临界区"></a>🍤临界区</h3><p>进程中访问临界资源的代码段称为临界区</p><h3 id="🍤同步机制遵循的原则"><a href="#🍤同步机制遵循的原则" class="headerlink" title="🍤同步机制遵循的原则"></a>🍤同步机制遵循的原则</h3><ol><li><strong>空闲让进</strong>——无进程处于临界区时，请求进入临界区的进程可立即进入</li><li><strong>忙则等待</strong>——当已有进程进入临界区时，其他试图进入临界区进程须等待</li><li><strong>有限等待</strong>——对要求访问临界资源进程，保证能在有限时间内进入临界区</li><li><strong>让权等待</strong>——当进程不能进入临界区时，应释放处理机</li></ol><h2 id="🍣信号量机制"><a href="#🍣信号量机制" class="headerlink" title="🍣信号量机制"></a>🍣信号量机制</h2><p>信号量可用于同步和互斥</p><h3 id="🍤整数型信号量S"><a href="#🍤整数型信号量S" class="headerlink" title="🍤整数型信号量S"></a>🍤整数型信号量S</h3><p>两个原子操作：wait&#x2F;signal( P&#x2F;V )</p><h3 id="🍤记录型信号量S"><a href="#🍤记录型信号量S" class="headerlink" title="🍤记录型信号量S"></a>🍤记录型信号量S</h3><p>两个原子操作：wait&#x2F;signal( P&#x2F;V )；除初始化外，S只能由wait&#x2F;signal访问</p><ul><li>对信号量的每次<strong>wait</strong>操作，意味着进程请求一个单位的该类资源，因此描述为S.value:&#x3D; S.value-1；当S.value＜0时，表示该类资源已分配完毕，因此进程应进行自我阻塞，放弃处理机，并插入到信号量链表S.L中。</li><li>对信号量的每次<strong>signal</strong>操作，表示执行进程释放一个单位资源，故S.value:&#x3D; S.value+1操作表示资源数目加1。若加1后仍是S.value＜&#x3D;0，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，将S.L链表中的第一个等待进程唤醒。</li></ul><h1 id="🍜进程通信"><a href="#🍜进程通信" class="headerlink" title="🍜进程通信"></a>🍜进程通信</h1><h2 id="🍣基本概念-1"><a href="#🍣基本概念-1" class="headerlink" title="🍣基本概念"></a>🍣基本概念</h2><p>进程通信是指<strong>进程之间的信息交换</strong>，其所交换的信息量，少者是一个状态或数值，多者则是成千上万个字符。</p><h2 id="🍣共享存储器系统"><a href="#🍣共享存储器系统" class="headerlink" title="🍣共享存储器系统"></a>🍣共享存储器系统</h2><p>互相通信的进程共享数据结构或共享存储区，进程之间通过这些空间进行通信。</p><h3 id="🍤分类"><a href="#🍤分类" class="headerlink" title="🍤分类"></a>🍤分类</h3><ol><li>基于共享数据结构的通信方式</li><li>基于共享存储区的通信方式</li></ol><h3 id="🍤特点"><a href="#🍤特点" class="headerlink" title="🍤特点"></a>🍤特点</h3><ol><li>适合大量的数据快速交换</li><li>程序员负担重</li></ol><h2 id="🍣信息通信系统"><a href="#🍣信息通信系统" class="headerlink" title="🍣信息通信系统"></a>🍣信息通信系统</h2><p>进程间的数据交换，是<strong>以格式化的消息</strong>为单位进行通信</p><h3 id="🍤分类-1"><a href="#🍤分类-1" class="headerlink" title="🍤分类"></a>🍤分类</h3><ol><li>直接通信：消息直接传递给接收方</li></ol><p>① 发送进程： Send(receiver,msg);<br>② 接收进程： Receive (sender,msg);</p><ol start="2"><li>间接通信：借助于收发双方进程之外的共享数据结构作为通信中转——<strong>信箱通信</strong></li></ol><p>① 发送进程：Send(mailbox,msg);<br>② 接收进程：Receive(mailbox,msg);</p><ol><li>信箱分类——共有、私有、共享信箱</li><li>特点：操作系统隐藏通信细节；通信程序简单；可以跨网络传输；灵活</li><li>进程同步<ol><li>发送阻塞、接收阻塞</li><li>发送不阻塞、接收阻塞</li><li>发送不阻塞、接收不阻塞</li></ol></li></ol><h2 id="🍣管道（Pipe）通信系统"><a href="#🍣管道（Pipe）通信系统" class="headerlink" title="🍣管道（Pipe）通信系统"></a>🍣管道（Pipe）通信系统</h2><p>在磁盘创造一个文件，大小固定，发送进程写连续字符流，接收进程按顺序读连续字符流</p><h2 id="🍣线程-函数级并发执行"><a href="#🍣线程-函数级并发执行" class="headerlink" title="🍣线程-函数级并发执行"></a>🍣线程-函数级并发执行</h2><h3 id="🍤线程Thread的基本概念"><a href="#🍤线程Thread的基本概念" class="headerlink" title="🍤线程Thread的基本概念"></a>🍤线程Thread的基本概念</h3><p>早期，在OS中能拥有资源和独立运行的基本单位是进程，随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤销与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机的出现，可以满足多个运行单位，而多个进程并行开销过大。</p><ul><li>线程是操作系统能够进行运算调度的最小单元。它被包含在进程中，是进程中的实际运作单位。<strong>一条线程指的是进程中一个单一顺序的控制流，每条线程执行不同的任务</strong>。</li></ul><h3 id="🍤线程和进程"><a href="#🍤线程和进程" class="headerlink" title="🍤线程和进程"></a><strong>🍤线程和进程</strong></h3><ol><li><strong>进程是系统进行资源分配和调度的基本单位；线程是CPU调度和分派的基本单位</strong></li><li>线程依赖进程而存在，一个进程至少有一个线程</li><li>进程有自己的独立地址空间，线程共享所属进程的地址空间</li><li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源和其他线程共享本进程的相关资源和内存、I&#x2F;O、CPU等</li><li>在进程切换时，涉及到整个当前进程CPU环境的保护环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作——进程切换的开销远大于线程切换的开销</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信的方式进行</li><li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但是多进程程序中一个进程崩溃并不会对其他进程造成影响，进程有自己的独立地址空间——多进程更加健壮</li></ol><h3 id="🍤线程的实现方式"><a href="#🍤线程的实现方式" class="headerlink" title="🍤线程的实现方式"></a><strong>🍤线程的实现方式</strong></h3><ol><li>内核支持线程——在同一进程内的线程切换调用内核</li><li>用户级线程——用户级线程仅存在于用户空间中，线程切换不调用核心</li></ol><h1 id="🍜处理机调度与死锁"><a href="#🍜处理机调度与死锁" class="headerlink" title="🍜处理机调度与死锁"></a>🍜处理机调度与死锁</h1><h2 id="🍣三级调度"><a href="#🍣三级调度" class="headerlink" title="🍣三级调度"></a>🍣三级调度</h2><h3 id="🍤高级调度——作业调度"><a href="#🍤高级调度——作业调度" class="headerlink" title="🍤高级调度——作业调度"></a><strong>🍤高级调度——作业调度</strong></h3><p>决定将外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，再将新创建的进程排在就绪队列上，准备执行</p><h3 id="🍤低级调度——进程调度"><a href="#🍤低级调度——进程调度" class="headerlink" title="🍤低级调度——进程调度"></a><strong>🍤低级调度——进程调度</strong></h3><p>决定就绪队列中的哪个进程应获得处理机（CPU），然后再由分派程序执行把处理机分配给该进程的具体操作——最基本的调度</p><ul><li><strong>调度方式</strong></li></ul><ol><li><strong>非抢占方式</strong></li></ol><p>指当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。<br>优点：简单、系统开销小、实时性差<br>缺点：不安全、霸占CPU，造成进程“饥饿”</p><ol start="2"><li><strong>抢占方式</strong></li></ol><p>指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更重要或紧迫的进程。<br>优点：不霸占CPU<br>方式原则：优先权原则、短作业（进程）优先、时间片原则</p><h3 id="🍤中级调度"><a href="#🍤中级调度" class="headerlink" title="🍤中级调度"></a><strong>🍤中级调度</strong></h3><p>目的——为了提高内存利用率和系统吞吐量<br>应使那些暂时不能运行的进程不再占用宝贵的<strong>内存资源</strong>，而将它们调至<strong>外存</strong>上去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。<br>当这些进程重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的哪些进程，重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。<br>——内存管理的“对换”功能</p><h2 id="🍣调度队列模型"><a href="#🍣调度队列模型" class="headerlink" title="🍣调度队列模型"></a>🍣调度队列模型</h2><ol><li>仅有进程调度的调度队列模型</li><li>具有高级调度和低级调度的调度队列模型</li><li>同时具有高、中、低三级调度的调度队列模型</li></ol><h3 id="🍤面向用户的准则"><a href="#🍤面向用户的准则" class="headerlink" title="🍤面向用户的准则"></a><strong>🍤面向用户的准则</strong></h3><ol><li>周转时间短——从作业提交给系统开始，到作业完成为止的时间间隔</li><li>响应时间快——用户从提交键盘命令开始，到系统首次给出响应为止的时间</li><li>截止时间保证——作业&#x2F;进程开始或结束的最晚时间</li></ol><h3 id="🍤面向系统的准则"><a href="#🍤面向系统的准则" class="headerlink" title="🍤面向系统的准则"></a><strong>🍤面向系统的准则</strong></h3><ol><li>系统吞吐量高</li></ol><p>吞吐量：系统单位时间内完成的作业&#x2F;进程数量。</p><ol start="2"><li>处理机利用率好</li><li>资源利用均衡</li></ol><h2 id="🍣调度算法"><a href="#🍣调度算法" class="headerlink" title="🍣调度算法"></a>🍣调度算法</h2><p>根据系统的资源分配策略所规定的资源分配算法。</p><h3 id="🍤先来先服务调度算法FCFS"><a href="#🍤先来先服务调度算法FCFS" class="headerlink" title="🍤先来先服务调度算法FCFS"></a><strong>🍤先来先服务调度算法FCFS</strong></h3><ul><li>既可用于作业调度，也可用于进程调度</li></ul><p>用于作业调度：每次调度都是从后备作业队列中，选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。<br>用于进程调度：则每次调度是从就绪队列中，选择一个最先进入队列的进程，为之分配处理机，使之投入运行<br>特点：实现简单、貌似公平、实际上对短作业不公平</p><h3 id="🍤短作业-x2F-短进程优先调度算法SJF-x2F-SPF"><a href="#🍤短作业-x2F-短进程优先调度算法SJF-x2F-SPF" class="headerlink" title="🍤短作业&#x2F;短进程优先调度算法SJF&#x2F;SPF"></a><strong>🍤短作业&#x2F;短进程优先调度算法SJF&#x2F;SPF</strong></h3><ul><li>既可用于作业调度SJF，也可用于进程调度SPF</li></ul><p>用于作业调度：每次调度都是从后备作业队列中，选择一个要求服务时间（执行时间）最短的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。<br>用于进程调度：则每次调度是从就绪队列中，选择一个执行时间最短的进程，为之分配处理机，使之投入运行<br>特点：实现困难：估算执行时间很难、有利于短作业、对长作业不公平</p><h3 id="🍤高优先权优先调度算法FPF"><a href="#🍤高优先权优先调度算法FPF" class="headerlink" title="🍤高优先权优先调度算法FPF"></a><strong>🍤高优先权优先调度算法FPF</strong></h3><ul><li>既可用于作业调度，也可用于进程调度</li></ul><p>用于作业调度时：系统将从后备队列中选择若干个优先权最高的作业，装入内存。<br>用于进程调度时：该算法是把处理机分配给就绪队列中优先权最高的进程。分为非抢占式优先权算法和抢占式优先权调度算法。<br><strong>优先权</strong>——反应作业&#x2F;进程执行时的迫切程度，是对调度所考虑的实际因素的算法抽象<br>静态优先权、动态优先权</p><h3 id="🍤高响应比优先调度算法HRRN"><a href="#🍤高响应比优先调度算法HRRN" class="headerlink" title="🍤高响应比优先调度算法HRRN"></a><strong>🍤高响应比优先调度算法HRRN</strong></h3><ul><li>用于作业调度</li></ul><p>$优先权&#x3D;\frac{响应时间}{要求服务时间}&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}$<br>等待时间相同，要求服务时间越短，优先级越高——利于短作业<br>要求服务时间相同，等待时间越长，优先级越高——先来先服务</p><h3 id="🍤时间片轮转调度算法RR"><a href="#🍤时间片轮转调度算法RR" class="headerlink" title="🍤时间片轮转调度算法RR"></a><strong>🍤时间片轮转调度算法RR</strong></h3><ul><li>用于作业调度或进程调度</li></ul><h3 id="🍤多级反馈队列调度算法MFQ"><a href="#🍤多级反馈队列调度算法MFQ" class="headerlink" title="🍤多级反馈队列调度算法MFQ"></a><strong>🍤多级反馈队列调度算法MFQ</strong></h3><ul><li>进程调度</li></ul><p>设置多个就绪队列1，2，3…，优先级递减 ，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。</p><h2 id="🍣实时调度"><a href="#🍣实时调度" class="headerlink" title="🍣实时调度"></a>🍣实时调度</h2><p>实时系统中都存在着若干个实时进程或任务，它们用来反应或控制某个（些）外部事件，<strong>往往带有某种程度的紧迫性</strong>，因而对实时系统中的调度提出了某些特殊要求，前面所介绍的多种调度算法，并不能很好地满足实时系统对调度的要求。为此，引入一种新的调度，即实时调度。</p><h3 id="🍤分类-2"><a href="#🍤分类-2" class="headerlink" title="🍤分类"></a><strong>🍤分类</strong></h3><ul><li>根据实时任务性质</li></ul><p><strong>硬实时调度算法</strong>：严格实时<br><strong>软实时调度算法</strong>：非严格实时</p><ul><li>根据调度方式</li></ul><p><strong>非抢占调度算法</strong></p><ol><li>非抢占式轮转调度算法<ol><li>将所有实时任务排列成队列，轮流投入运行；当任务完成，就重新排到队列末尾；调度时选择队首进程</li></ol></li><li>非抢占式优先调度算法<ol><li>为所有实时任务设定优先权；高优先权进程到达队列，排到队首，以待当前任务执行完毕；调度时选择队首进程；</li></ol></li></ol><p><strong>抢占调度算法</strong></p><ol><li>基于时钟中断的抢占式优先权调度算法<ol><li>为所有实时任务设定优先权；高优先权进程到达队列，排到队首，以待时钟中断到达时，调度到CPU上执行</li></ol></li><li>立即抢占的优先权调度算法<ol><li>为所有实时任务设定优先权；高优先权进程到达队列，只要当前进程不在临界区，则立刻抢占CPU；</li></ol></li></ol><ul><li>根据调度时间</li></ul><p><strong>静态调度</strong>：在进程执行前，调度程序便已经决定了各进程间的执行顺序<br><strong>动态调度算法</strong>：在进程的执行过程中，由调度程序届时根据情况临时决定将哪一进程投入运行</p><h3 id="🍤最早截止时间优先调度算法EDF"><a href="#🍤最早截止时间优先调度算法EDF" class="headerlink" title="🍤最早截止时间优先调度算法EDF"></a><strong>🍤最早截止时间优先调度算法EDF</strong></h3><p>根据任务的开始截止时间来确定任务的优先级，截止时间愈早，其优先级愈高。</p><h3 id="🍤最低松弛度优先调度算法LLF"><a href="#🍤最低松弛度优先调度算法LLF" class="headerlink" title="🍤最低松弛度优先调度算法LLF"></a><strong>🍤最低松弛度优先调度算法LLF</strong></h3><p>根据任务的紧急程度（松弛度）来确定任务的优先级。<br>松弛度&#x3D;必须完成时间-本身运行时间-当前时间<br>调度程序在选择任务时，总是选择就绪队列中紧急程度（松弛度）最大任务，为之分配处理机，使之投入运行。</p><h1 id="🍜进程死锁"><a href="#🍜进程死锁" class="headerlink" title="🍜进程死锁"></a>🍜进程死锁</h1><h2 id="🍣死锁及死锁状态"><a href="#🍣死锁及死锁状态" class="headerlink" title="🍣死锁及死锁状态"></a>🍣死锁及死锁状态</h2><h3 id="🍤死锁Deadlock"><a href="#🍤死锁Deadlock" class="headerlink" title="🍤死锁Deadlock"></a><strong>🍤死锁Deadlock</strong></h3><p>多个进程在运行过程中因争夺资源而造成的一种僵局。当进程处于这种僵局时，若无外力作用，它们都将无法再向前推进</p><h3 id="🍤死锁与阻塞的区别"><a href="#🍤死锁与阻塞的区别" class="headerlink" title="🍤死锁与阻塞的区别"></a><strong>🍤死锁与阻塞的区别</strong></h3><p>死锁的进程处于阻塞状态，但仅依靠自己，无法继续运行</p><h2 id="🍣产生死锁的原因"><a href="#🍣产生死锁的原因" class="headerlink" title="🍣产生死锁的原因"></a>🍣产生死锁的原因</h2><ol><li>竞争非剥夺性资源——必须在用完后才能被剥夺，如打印机</li><li>进程推进顺序非法</li></ol><h2 id="🍣产生死锁的必要条件——死锁的特征"><a href="#🍣产生死锁的必要条件——死锁的特征" class="headerlink" title="🍣产生死锁的必要条件——死锁的特征"></a>🍣产生死锁的必要条件——死锁的特征</h2><ol><li>互斥条件——互斥使用条件</li><li>请求和保持条件——进程占有一个资源的同时，请求另外的资源</li><li>不剥夺条件——进程的资源使用完之前，不能被剥夺</li><li>环路等待条件——死锁的n个进程形成环形的进程-资源链</li></ol><h2 id="🍣处理死锁的基本方法"><a href="#🍣处理死锁的基本方法" class="headerlink" title="🍣处理死锁的基本方法"></a>🍣处理死锁的基本方法</h2><h3 id="🍤预防死锁——事先预防"><a href="#🍤预防死锁——事先预防" class="headerlink" title="🍤预防死锁——事先预防"></a><strong>🍤预防死锁——事先预防</strong></h3><p>作法——破坏死锁产生的四个必要条件</p><ol><li>破坏互斥条件——×资源特性决定</li><li>破坏请求和保持条件——进程创建时，一次申请所有的资源，成功则运行，否则阻塞</li><li>破坏不剥夺条件——进程申请资源时，成功则运行，否则释放所有资源后阻塞</li><li>破坏环路等待——编号并按序申请资源</li></ol><h3 id="🍤避免死锁——事先预防"><a href="#🍤避免死锁——事先预防" class="headerlink" title="🍤避免死锁——事先预防"></a><strong>🍤避免死锁——事先预防</strong></h3><p>允许系统具备四个必要条件</p><ul><li>进程在执行过程中动态地申请和释放资源</li><li>每次资源分配时，由系统仔细检查此次资源分配的安全性，只有在安全时才分配，否则不分配，并令进程等待。</li></ul><p><img src="https://i.imgtg.com/2023/07/13/OzAsAB.png#height=126&id=jRCTE&originHeight=252&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=436"></p><h3 id="🍤银行家算法"><a href="#🍤银行家算法" class="headerlink" title="🍤银行家算法"></a><strong>🍤银行家算法</strong></h3><ul><li>主要思想——避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全检查。如果新状态安全，则正式分配上述资源，否则拒绝上述资源——保证系统始终处于安全状态，避免死锁</li></ul><h2 id="🍣死锁的检测和解除"><a href="#🍣死锁的检测和解除" class="headerlink" title="🍣死锁的检测和解除"></a>🍣死锁的检测和解除</h2><p>检测和解除死锁的基本思想：</p><ul><li>进程在执行过程中动态地申请和释放资源</li><li>每次资源分配时，不作任何检查；</li><li>允许系统产生死锁；</li><li>定时或按需检查系统是否有处于死锁状态的进程存在；</li><li>发现死锁，则立即解除所有死锁进程。</li></ul><h3 id="🍤死锁的检测"><a href="#🍤死锁的检测" class="headerlink" title="🍤死锁的检测"></a><strong>🍤死锁的检测</strong></h3><p><strong>死锁定理</strong>——S状态为死锁状态的充分条件是—当且仅当S状态的资源分配图是<strong>不可完全简化</strong>的</p><h3 id="🍤死锁的解除"><a href="#🍤死锁的解除" class="headerlink" title="🍤死锁的解除"></a><strong>🍤死锁的解除</strong></h3><ol><li>剥夺资源</li><li>撤销进程</li></ol><h2 id="🍣饥饿与死锁"><a href="#🍣饥饿与死锁" class="headerlink" title="🍣饥饿与死锁"></a><strong>🍣饥饿与死锁</strong></h2><p>等待时间给进程推进和相应带来明显影响——进程饥饿<br>饥饿不代表系统已经死锁，但至少有一个程序的执行被无限期的推迟<br>差别：</p><ol><li>进入饥饿状态的进程只有一个，死锁必须大于等于两个</li><li>处于<strong>饥饿状态</strong>的进程可以是一个就绪程序，处于<strong>死锁状态</strong>的必定是阻塞进程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——系统总线</title>
      <link href="/2023/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
      <url>/2023/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/13/Ozrjyr.png#id=zWEqo&originHeight=779&originWidth=1447&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🤹‍♀️总线的基本概念"><a href="#🤹‍♀️总线的基本概念" class="headerlink" title="🤹‍♀️总线的基本概念"></a>🤹‍♀️总线的基本概念</h1><h2 id="🤶为什么要用总线"><a href="#🤶为什么要用总线" class="headerlink" title="🤶为什么要用总线"></a>🤶为什么要用总线</h2><ol><li>减少各部件之间的连接线</li><li>方便系统的构成、扩充或更新</li></ol><h2 id="🤶什么是总线"><a href="#🤶什么是总线" class="headerlink" title="🤶什么是总线"></a>🤶什么是总线</h2><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p><h2 id="🤶总线结构"><a href="#🤶总线结构" class="headerlink" title="🤶总线结构"></a>🤶总线结构</h2><h3 id="🕵️‍♀️单总线结构框图"><a href="#🕵️‍♀️单总线结构框图" class="headerlink" title="🕵️‍♀️单总线结构框图"></a>🕵️‍♀️单总线结构框图</h3><p><img src="https://i.imgtg.com/2023/07/13/OzrEvX.md.png#height=250&id=Z4lli&originHeight=500&originWidth=810&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=405"><br>优点：结构简单<br>缺点：快速设备和慢速设备挂在同一条总线上</p><h3 id="🕵️‍♀️面向CPU的双总线结构框图"><a href="#🕵️‍♀️面向CPU的双总线结构框图" class="headerlink" title="🕵️‍♀️面向CPU的双总线结构框图"></a>🕵️‍♀️面向CPU的双总线结构框图</h3><p><img src="https://i.imgtg.com/2023/07/13/OzrGdt.md.png#height=250&id=EZjjJ&originHeight=500&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=409"><br>优点：快速设备和慢速设备挂在两条总线上<br>缺点：结构复杂，外设1送数据给主存要经过CPU中转，占用CPU资源</p><h3 id="🕵️‍♀️与存储器为中心的双总线结构框图"><a href="#🕵️‍♀️与存储器为中心的双总线结构框图" class="headerlink" title="🕵️‍♀️与存储器为中心的双总线结构框图"></a>🕵️‍♀️与存储器为中心的双总线结构框图</h3><p><img src="https://i.imgtg.com/2023/07/13/Ozr0Nj.md.png#height=250&id=M36cb&originHeight=500&originWidth=759&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=380"><br>优点：快速设备和慢速设备挂在两条总线上。外设1送数据给主存不需要经过CPU中转<br>缺点：结构复杂</p><h1 id="🤹‍♀️总线的分类"><a href="#🤹‍♀️总线的分类" class="headerlink" title="🤹‍♀️总线的分类"></a>🤹‍♀️总线的分类</h1><h2 id="🤶片内总线"><a href="#🤶片内总线" class="headerlink" title="🤶片内总线"></a>🤶片内总线</h2><p>芯片内部的总线——用来连接芯片内部的各部件</p><h2 id="🤶系统总线"><a href="#🤶系统总线" class="headerlink" title="🤶系统总线"></a>🤶系统总线</h2><p>计算机各部件之间的信息传输线——用于连接计算机系统内各功能部件</p><ol><li><strong>数据总线</strong>——各个功能部件之间传输数据信息。双向（与机器字长、存储字长有关）单向（与存储地址、I&#x2F;O地址有关）</li><li><strong>地址总线</strong>——用来指明数据总线上，源数据或目的数据所在的主存单元的地址。单向——由CPU发出。存储单元个数&#x3D;2^地址总线根数</li><li><strong>控制总线</strong>——入（中断请求、总线请求）出（存储器读、存储器写、总线允许、中断确认）。发出各种控制信号，监视各部件状态</li></ol><h2 id="🤶通信总线"><a href="#🤶通信总线" class="headerlink" title="🤶通信总线"></a>🤶通信总线</h2><p>（I&#x2F;O总线，外部总线）用于计算机系统之间或计算机系统与其他系统之间的通信</p><ol><li>串行通信总线</li><li>并行通信总线</li></ol><h1 id="🤹‍♀️总线特性及性能指标"><a href="#🤹‍♀️总线特性及性能指标" class="headerlink" title="🤹‍♀️总线特性及性能指标"></a>🤹‍♀️总线特性及性能指标</h1><h2 id="🤶总线特性"><a href="#🤶总线特性" class="headerlink" title="🤶总线特性"></a>🤶总线特性</h2><ol><li>机械特性——机械连接方式上的一些性能，尺寸、形状</li><li>电气特性——每根传输线上的信号的传输方向和有效的电平范围</li><li>功能特性——每根传输线的功能（地址、数据、控制）</li><li>时间特性——信号的时序关系</li></ol><h2 id="🤶性能指标"><a href="#🤶性能指标" class="headerlink" title="🤶性能指标"></a>🤶性能指标</h2><ol><li>总线周期——一次总线操作所需的时间</li><li>总线工作频率——协调总线上各操作的时钟频率</li><li>总线宽度——数据线的根数</li><li>总线带宽——总线数据传输速率，每秒传输的最大字节数（MBps）——总线带宽&#x3D;（总线宽度&#x2F;8）*总线工作频率</li><li>时钟同步&#x2F;异步</li><li>总线复用——一条信号线上分时传送两种信号。数据线和地址线复用</li><li>信号线数——地址线、数据线、控制线的总和</li><li>总线控制方式——突发工作、自动配置、仲裁方式</li></ol><h1 id="🤹‍♀️总线控制"><a href="#🤹‍♀️总线控制" class="headerlink" title="🤹‍♀️总线控制"></a>🤹‍♀️总线控制</h1><h2 id="🤶总线判优控制（仲裁）"><a href="#🤶总线判优控制（仲裁）" class="headerlink" title="🤶总线判优控制（仲裁）"></a>🤶总线判优控制（仲裁）</h2><h3 id="🕵️‍♀️基本概念"><a href="#🕵️‍♀️基本概念" class="headerlink" title="🕵️‍♀️基本概念"></a>🕵️‍♀️基本概念</h3><ul><li>主设备——对总线有控制权</li><li>从设备——响应从主设备发来的总线控制</li></ul><p>总线仲裁——在总线争用时，决定具有总线控制权的设备或模块的过程<br><img src="https://i.imgtg.com/2023/07/13/OzrcEp.png#id=dLSYf&originHeight=359&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>集中式：专门的总线控制器或总线裁决器</p><h3 id="🕵️‍♀️链式查询方式"><a href="#🕵️‍♀️链式查询方式" class="headerlink" title="🕵️‍♀️链式查询方式"></a>🕵️‍♀️链式查询方式</h3><p>根据线的连接顺序依次查询每个部件有无请求<br><img src="https://i.imgtg.com/2023/07/13/OzrdIU.md.png#height=250&id=qtmLc&originHeight=500&originWidth=790&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=395"><br>优点：线数少（3根），设备扩充容易<br>缺点：离总线控制器最近的设备具有最高优先权，优先权低的设备难获得请求；对电路故障敏感</p><h3 id="🕵️‍♀️计数器定时查询方式"><a href="#🕵️‍♀️计数器定时查询方式" class="headerlink" title="🕵️‍♀️计数器定时查询方式"></a>🕵️‍♀️计数器定时查询方式</h3><p>对每个设备编号，用计数器依次查询<br><img src="https://i.imgtg.com/2023/07/13/OzrVFY.md.png#height=250&id=mF4Ti&originHeight=500&originWidth=811&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=406"></p><ol><li>计数器从0开始——与链式优先级相同</li><li>从终止点开始——循环优先级，各个部件优先级相等</li></ol><h3 id="🕵️‍♀️独立请求方式"><a href="#🕵️‍♀️独立请求方式" class="headerlink" title="🕵️‍♀️独立请求方式"></a>🕵️‍♀️独立请求方式</h3><p>在总线控制器排队，按照一定规则批准某个请求——“领导说了算”<br><img src="https://i.imgtg.com/2023/07/13/OzrYRv.md.png#height=250&id=q6Ldq&originHeight=500&originWidth=734&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=367"><br>优点：响应速度快；优先级控制灵活<br>缺点：线数多（2n根），控制复杂</p><h3 id="🕵️‍♀️自举分布式裁决"><a href="#🕵️‍♀️自举分布式裁决" class="headerlink" title="🕵️‍♀️自举分布式裁决"></a>🕵️‍♀️自举分布式裁决</h3><p>优先级固定，各设备独立决定自己是否是最高优先级请求者<br>需请求总线的设备在各自对应的总线请求线上送出请求信号</p><h3 id="🕵️‍♀️冲突检测方式裁决"><a href="#🕵️‍♀️冲突检测方式裁决" class="headerlink" title="🕵️‍♀️冲突检测方式裁决"></a>🕵️‍♀️冲突检测方式裁决</h3><p>当某个设备要使用总线时，它首先检查一下是否有其他设备正在使用总线如果没有，那它就置总线忙，然后使用总线。<br>若两个设备同时检测到总线空闲，则可能会同时使用总线，此时发生冲突；一个设备在传输过程中，它会帧听总线以检测是否发生了冲突；当冲突发生时，两个设备都会停止传输，延迟一个随机时间后再重新使用总线</p><h2 id="🤶总线通信控制"><a href="#🤶总线通信控制" class="headerlink" title="🤶总线通信控制"></a>🤶总线通信控制</h2><p>目的——解决通信双方协调配合的问题<br><strong>总线周期</strong></p><ol><li>申请分配阶段——主模块申请，总线仲裁决定</li><li>寻址阶段——主模块向从模块给出地址和命令</li><li>传数阶段——主模块和从模块交换数据</li><li>结束阶段——主模块撤销有关数据</li></ol><h3 id="🕵️‍♀️四种方式（总线定时方式）"><a href="#🕵️‍♀️四种方式（总线定时方式）" class="headerlink" title="🕵️‍♀️四种方式（总线定时方式）"></a>🕵️‍♀️四种方式（总线定时方式）</h3><p><img src="https://i.imgtg.com/2023/07/13/Ozrfjq.md.png#id=kjk74&originHeight=500&originWidth=858&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="👩‍🔧同步通信"><a href="#👩‍🔧同步通信" class="headerlink" title="👩‍🔧同步通信"></a>👩‍🔧同步通信</h4><p>系统采用<strong>统一的时钟信号</strong>来协调发送和接受双方的传递定时关系<br>优点：规定明确、统一，模块间的配合简单一致；控制逻辑少而速度快<br>缺点：主从模块间时间配合强制同步，影响总线工作效率，局限性，缺乏灵活性</p><h4 id="👩‍🔧异步通信"><a href="#👩‍🔧异步通信" class="headerlink" title="👩‍🔧异步通信"></a>👩‍🔧异步通信</h4><p>非时钟定时，<strong>没有一个公共的时钟标准</strong>。采用应答方式，允许各模块速度不一致。<br>主模块发出请求信号（Request）时，一直等待从模块反馈回来的应答信号(Acknowledge)，才开始通信。这需要主从模块之间增加两条应答线（即<strong>握手</strong>交互信号线Handshaking）。</p><ol><li>不互锁</li><li>半互锁</li><li>全互锁</li></ol><p>优点：灵活，可挂接各种具有不同工作速度的设备<br>缺点：对噪声较敏感（任何时候都可能接收到对方的应答信号）；接口逻辑较复杂</p><h4 id="👩‍🔧半同步通信（同步、异步结合）"><a href="#👩‍🔧半同步通信（同步、异步结合）" class="headerlink" title="👩‍🔧半同步通信（同步、异步结合）"></a>👩‍🔧半同步通信（同步、异步结合）</h4><p>同步——发送方：用系统时钟前沿发信号；接收方用系统时钟后沿判断、识别。<br>异步——允许不同速度的模块和谐工作；增加一条“等待”响应信号WAIT<br><img src="https://i.imgtg.com/2023/07/13/Ozr9Uc.png#height=200&id=lNNJy&originHeight=399&originWidth=869&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=435"></p><h4 id="👩‍🔧分离式通信"><a href="#👩‍🔧分离式通信" class="headerlink" title="👩‍🔧分离式通信"></a>👩‍🔧分离式通信</h4><ol><li>各设备有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各设备准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ol><p>充分发挥了总线的有效占用</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——数据链路层</title>
      <link href="/2023/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgtg.com/2023/07/13/OzrpNK.png#id=o5ZhO&originHeight=1075&originWidth=1060&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🥪数据链路层概述"><a href="#🥪数据链路层概述" class="headerlink" title="🥪数据链路层概述"></a>🥪数据链路层概述</h1><h2 id="🥯基本概念"><a href="#🥯基本概念" class="headerlink" title="🥯基本概念"></a>🥯基本概念</h2><h3 id="🍳专业术语和名词"><a href="#🍳专业术语和名词" class="headerlink" title="🍳专业术语和名词"></a>🍳专业术语和名词</h3><ol><li>结点——计算机或网络设备</li><li>帧——数据链路层的协议数据单元（PDU），用于封装网络层数据报，包括帧首部、数据和帧尾</li><li>最大传输单元（MTU）——结点可以接收报文的最大尺寸（发送方要发送一个超过MTU的报文，分片）</li><li>链路——连接两个相邻结点的物理信道，如双绞线、光纤等</li><li>数据链路——两个结点间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上构成数据链路</li><li>数据链路层的范围——只与本地节点之间的数据交付有关，即在数据链路层，帧的传输不会超过本地网络</li></ol><ul><li><strong>数据链路层传送的是帧</strong></li></ul><h3 id="🍳为网络层提供的主要服务"><a href="#🍳为网络层提供的主要服务" class="headerlink" title="🍳为网络层提供的主要服务"></a>🍳为网络层提供的主要服务</h3><p>为上层提供<strong>可靠、无差错</strong>的节点间数据传输链路。</p><ol><li>无确定的无连接服务</li><li>有确定的无连接服务</li><li>有确定的面向连接服务</li></ol><h3 id="🍳主要功能"><a href="#🍳主要功能" class="headerlink" title="🍳主要功能"></a>🍳主要功能</h3><ul><li>将网络层报文封装成数据帧，按顺序发送</li></ul><ol><li>一种合适的<strong>帧结构</strong>，以便封装上层数据</li><li>一种合适的<strong>数据识别机制</strong>，确保所有数据得到传输</li><li>一种<strong>检错或纠错</strong>机制，以发现并解决传输中的错误</li><li>一种合适的<strong>流量控制</strong>机制，以维持有序通信</li><li>一种获得发送数据权的判断和决策机制</li></ol><h3 id="🍳两种传输方式"><a href="#🍳两种传输方式" class="headerlink" title="🍳两种传输方式"></a>🍳两种传输方式</h3><ol><li><strong>点对点信道数据传输</strong></li></ol><p>在一个数据链路上有且仅有两个结点。两个结点间以双工的方式进行传输数据，即双向都可以发送&#x2F;接收数据。<br>——主要用于<strong>通信子网</strong>的结点(路由器)间数据传输。</p><ol start="2"><li><strong>广播信道数据传输</strong></li></ol><p>多个结点共享一个信道，每个结点都可以通过这个信道向其他结点发送数据，每个结点只接收发送给自己的数据。<br>——主要用于<strong>资源子网</strong>的同一局域网结点间数据传输。</p><h2 id="🥯基本问题"><a href="#🥯基本问题" class="headerlink" title="🥯基本问题"></a>🥯基本问题</h2><ol><li>封装成帧：发送结点的数据链路层将网络层的数据报文添加首部和尾部后封装成帧。</li><li>透明传输：数据报文中的任意数据都可以得到传输，高层应用无需担心特殊字符的传输问题。</li><li>差错控制：接收方只接收无差错的数据帧</li></ol><h3 id="🍳封装成帧"><a href="#🍳封装成帧" class="headerlink" title="🍳封装成帧"></a>🍳封装成帧</h3><ul><li>封装成帧(framing)是在网络层报文的前后分别添加首部和尾部，构成一个帧。首部和尾部的重要作用之一就是进行<strong>帧定界</strong>。</li></ul><p><img src="https://i.imgtg.com/2023/07/13/OzePpc.png#height=179&id=VNJoz&originHeight=357&originWidth=1320&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=660"></p><h3 id="🍳透明传输"><a href="#🍳透明传输" class="headerlink" title="🍳透明传输"></a>🍳透明传输</h3><p>——帧定界符出现在被传输的数据<br><img src="https://i.imgtg.com/2023/07/13/OzeRfr.md.png#height=250&id=zpIW9&originHeight=500&originWidth=1332&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=666"></p><ul><li>透明传输是指无论被传数据是什么样的比特组合，都能够在链路上传送。</li></ul><ol><li><strong>字节填充法</strong></li></ol><p>若被传数据中出现控制字符“SOH”或“EOT”时，发送端的数据链路层则在其前插入一个转义字符“ESC”(其十六进制编码是 1B)。<br>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>如果被传数据中有转义字符时，那么应在转义字符前面再插入一个转义字符。<br>接收端收到连续的两个转义字符时，删除前面一个。<br><img src="https://i.imgtg.com/2023/07/13/Oze4BM.md.png#height=250&id=xpjGP&originHeight=500&originWidth=1412&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=706"></p><ol start="2"><li><strong>比特填充法</strong></li></ol><p>设帧定界符中有连续n个“1”；<br>发送端，只要在帧的数据字段发现有n-1个连续“1”时，则立即填入一个“0”；<br>接收端，对帧的数据字段比特流进行扫描。每当发现n-1个连续“1”时，就删除其后的“0”。</p><h1 id="🥪差错控制"><a href="#🥪差错控制" class="headerlink" title="🥪差错控制"></a>🥪差错控制</h1><p>通过特殊的编码（<strong>差错控制码</strong>），使接收端能够发现甚至自动纠正错误。</p><ol><li>码字——码字有信息位和校验位（冗余位）组成</li><li>码距——两个码字的不同位数</li><li>海明距离——码字表中必存在着两个码字之间的距离最小，这个最小距离称为该码字表（编码系统）的海明距离。——决定纠错和检错能力</li></ol><h2 id="🥯差错控制方法及分类"><a href="#🥯差错控制方法及分类" class="headerlink" title="🥯差错控制方法及分类"></a>🥯差错控制方法及分类</h2><p>（这部分主要计算，因此不做过多解释）奇偶校验码、定比码 、正反码</p><h3 id="🍳检错码"><a href="#🍳检错码" class="headerlink" title="🍳检错码"></a>🍳检错码</h3><p>循环冗余码（CRC码）</p><h3 id="🍳纠错码"><a href="#🍳纠错码" class="headerlink" title="🍳纠错码"></a>🍳纠错码</h3><p>海明码——海明距离只能纠正一位出错</p><h1 id="🥪流量控制"><a href="#🥪流量控制" class="headerlink" title="🥪流量控制"></a>🥪流量控制</h1><h1 id="🥪点到点数据链路层协议"><a href="#🥪点到点数据链路层协议" class="headerlink" title="🥪点到点数据链路层协议"></a>🥪点到点数据链路层协议</h1><h2 id="🥯HDLC协议"><a href="#🥯HDLC协议" class="headerlink" title="🥯HDLC协议"></a>🥯HDLC协议</h2><ul><li>面向比特的链路层协议——以二进制位作为数据帧的基本数据单位</li></ul><p>三种类型站——主站、次站、复合站<br>两种链路结构——非平衡配置、平衡配置<br>三种数据传送操作方式——正常响应方式NRM、异步响应方式ARM、异步平衡方式ABM</p><h3 id="🍳HDLC帧格式"><a href="#🍳HDLC帧格式" class="headerlink" title="🍳HDLC帧格式"></a>🍳HDLC帧格式</h3><p><img src="https://i.imgtg.com/2023/07/13/OzeH01.png#height=109&id=z3d7N&originHeight=217&originWidth=1347&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=674"></p><ol><li><strong>标志</strong></li></ol><p>固定为0111110，标志着一个帧的开始和结束。具有帧之间的同步作用。在连续发送多帧时，可用一个标志字段，既表示帧的开始，又表示帧的结束。<strong>“5‘1’1‘0’插0技术”</strong></p><ol start="2"><li><strong>地址</strong></li></ol><p>全“1”为广播地址，全“0”为无效地址</p><ol start="3"><li><strong>控制</strong></li></ol><p><img src="https://i.imgtg.com/2023/07/13/OzeLwI.md.png#height=250&id=YNELt&originHeight=500&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=405"></p><h3 id="🍳HDLC工作原理"><a href="#🍳HDLC工作原理" class="headerlink" title="🍳HDLC工作原理"></a>🍳HDLC工作原理</h3><ol><li>建立数据链路连接</li><li>传输数据帧</li><li>拆除链路连线</li></ol><h2 id="🥯PPP协议"><a href="#🥯PPP协议" class="headerlink" title="🥯PPP协议"></a>🥯PPP协议</h2><p>Point to Point Protocol——点对点协议——面向字符、全双工、按照顺序传递数据包的协议</p><h3 id="🍳PPP协议组成"><a href="#🍳PPP协议组成" class="headerlink" title="🍳PPP协议组成"></a>🍳PPP协议组成</h3><p><img src="https://i.imgtg.com/2023/07/13/OzeQHF.png#height=133&id=Wrw74&originHeight=265&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=289"></p><ol><li>一个将IP数据报封装到串行链路的方法</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议(LCP)——主要作用于数据链路层中</li><li>一套网络控制协议(NCP)——介于网络层和数据链路层之间起作用</li></ol><ul><li>LCP子层——主要负责数据链路的建立、配置和测试</li><li>NCP子层——根据网络层的不同协议互相交换特定的控制报文、配置不同上层协议</li></ul><h3 id="🍳PPP协议的帧格式"><a href="#🍳PPP协议的帧格式" class="headerlink" title="🍳PPP协议的帧格式"></a>🍳PPP协议的帧格式</h3><p><img src="https://i.imgtg.com/2023/07/13/OzeS86.png#height=188&id=h8mLS&originHeight=375&originWidth=1393&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=697"></p><h3 id="🍳PPP协议的透明传输"><a href="#🍳PPP协议的透明传输" class="headerlink" title="🍳PPP协议的透明传输"></a>🍳PPP协议的透明传输</h3><ol><li>同步方式中的透明传输——零比特填充法5‘1’1‘0’</li><li>异步方式中的透传</li></ol><h3 id="🍳PPP协议运行阶段"><a href="#🍳PPP协议运行阶段" class="headerlink" title="🍳PPP协议运行阶段"></a>🍳PPP协议运行阶段</h3><ol><li>链路不可用阶段：初始阶段。</li><li>链路建立阶段： LCP协商，包括协商认证方式等。</li><li>验证阶段（可选）：PAP&#x2F;CHAP验证</li><li>网络层协议阶段：NCP协商</li><li>维持阶段：维持PPP会话，传输数据、定时测试链路。</li><li>网络终止阶段：终止PPP会话，回到链路不可用阶段。</li></ol><p><img src="https://i.imgtg.com/2023/07/13/OzecxP.png#height=134&id=ZsqbP&originHeight=267&originWidth=1110&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=555"></p><h3 id="🍳LCP"><a href="#🍳LCP" class="headerlink" title="🍳LCP"></a>🍳LCP</h3><p>链路控制协议（Link Control Protocol，LCP）是PPP协议的一个子集，用于点对点通信时发送端和接收端协商确定一系列必要的信息。</p><ol><li><strong>链路配置报文</strong>：建立和配置一条链路</li><li><strong>链路维护报文</strong>：维护和调试链路</li><li><strong>链路终止报文</strong>：终止一条链路</li></ol><ul><li>LCP 两端通过发送请求和应答帧的方式进行交互协商各种配置选项。 发送LCP Config-Request的一方向另一方提出自己需要的选项。接收Config-Request报文的一方根据自身情况选择三种报文之一进行应答。</li></ul><h3 id="🍳PPP协议的认证"><a href="#🍳PPP协议的认证" class="headerlink" title="🍳PPP协议的认证"></a>🍳PPP协议的认证</h3><ol><li><strong>口令认证协议</strong></li></ol><p>由链路的一端向另一端发送用户名和密码，另一端以收到的用户名和密码判断是否建立连接。——明文方式传输</p><ol start="2"><li><strong>挑战握手认证协议</strong></li></ol><p>通常是要求用户名和密码，被认证端将挑战应答的hash函数值发送给认证端。认证端根据收到的响应决定是否建立连接。</p><h3 id="🍳NCP"><a href="#🍳NCP" class="headerlink" title="🍳NCP"></a>🍳NCP</h3><p>网络控制协议(Network Control Protocol，NCP)实际上是一套协议。每个子协议都是为处理相应网络层协议所需的错综复杂的配置而存在。</p><ul><li><strong>IP控制协议（IPCP）</strong>是PPP协议中负责配置和激活网络层IP协议传输的NCP子协议。</li></ul><h1 id="🥪广播信道数据链路层"><a href="#🥪广播信道数据链路层" class="headerlink" title="🥪广播信道数据链路层"></a>🥪广播信道数据链路层</h1><p>广播信道(Broadcasting information channel)是一种可以通过广播方式传输信息的信息通道。通过广播信道，可以<strong>实现一对多的通信</strong>。</p><ul><li>媒介共享技术，也称为多址接入控制（Multiple Access Control，MAC）或媒介访问控制（Medium Access Control，MAC）技术。</li></ul><h2 id="🥯MAC技术"><a href="#🥯MAC技术" class="headerlink" title="🥯MAC技术"></a>🥯MAC技术</h2><p>MAC技术用于解决公共信道使用产生竞争时，如何分配信道使用权的问题。<br>MAC层是数据链路层的一个子层，处于数据链路逻辑控制层（LLC）与物理层之间。——LLC层负责提供本结点到其他相邻结点的“链路”，MAC层负责实现本结点与其他结点有序、高效的共享信道。<br><img src="https://i.imgtg.com/2023/07/13/OzeYBg.md.png#height=250&id=RAjkj&originHeight=500&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=473"></p><h3 id="🍳动态接入分配协议"><a href="#🍳动态接入分配协议" class="headerlink" title="🍳动态接入分配协议"></a>🍳动态接入分配协议</h3><ol><li>随机分配方式</li></ol><h4 id="🥘ALOHA协议"><a href="#🥘ALOHA协议" class="headerlink" title="🥘ALOHA协议"></a>🥘ALOHA协议</h4><p>基本思想——不监听信道、想发就发、随机重发<br>传输机制——<br>发送端发起传输请求后可立即发送数据，无需等待授权，也不需要检测信道否空闲。<br>接收端在成功接收数据后返回一个ACK帧，通知发送端传输成功。<br>接收端收到的数据校验有错，则不发ACK帧。<br>发送端在预定的时间内未收到ACK帧，则认为发生碰撞，并在一个随机时间后重发。若重发再次碰撞，则再等待一个时间后重发，直到接收到ACK帧。<br><img src="https://i.imgtg.com/2023/07/13/Ozel0s.md.jpg#height=250&id=FJzcX&originHeight=500&originWidth=788&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=394"></p><h4 id="🥘时隙ALOHA"><a href="#🥘时隙ALOHA" class="headerlink" title="🥘时隙ALOHA"></a>🥘时隙ALOHA</h4><p>基本思想——不监听信道、规定发送时间<br>传输机制——<br>将时间划分为等长的时隙(slot，也称时槽），每个时隙可以传输1个帧。<br>结点间严格时钟同步，且只能在时隙开始时发送帧。如果2个及以上结点在同一时隙发送帧，结点即检测到冲突。<br>当某个结点发送一个帧后：<br>无碰撞：可以在下一个时隙继续发送新的帧<br>有碰撞：在下一个时隙以概率p重传该帧，直至成功</p><h4 id="🥘CSMA"><a href="#🥘CSMA" class="headerlink" title="🥘CSMA"></a>🥘CSMA</h4><p>基本思想——<strong>载波侦听</strong>：发送数据前先检测信道。信道空闲，立即发送数据；若信道忙，则等待并继续检测信道。<br><img src="https://i.imgtg.com/2023/07/13/Oze27a.md.png#height=250&id=rfcGt&originHeight=500&originWidth=1467&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=734"></p><ul><li>由于只是在发送前检测信道是否被占用，当有两个或两个以上结点同时发送数据时，发送方只有在数据发送完成后才会获悉发生碰撞，数据无法使用，必须重发，从而浪费信道资源。</li></ul><h4 id="🥘CSMA-x2F-CD"><a href="#🥘CSMA-x2F-CD" class="headerlink" title="🥘CSMA&#x2F;CD"></a>🥘CSMA&#x2F;CD</h4><p>CSMA&#x2F;CD 是一种具有<strong>碰撞检测能力</strong>的<strong>广播信道多点接入技术</strong>，称为“载波侦听多址接入&#x2F;碰撞检测”。<br>基本思想——<strong>先听后说，边听边说，发生碰撞，随机避退。</strong></p><ul><li><strong>二进制指数退避算法</strong>（随机等待时间）</li><li>只支持<strong>半双工</strong></li></ul><h4 id="🥘CSMA-x2F-CA"><a href="#🥘CSMA-x2F-CA" class="headerlink" title="🥘CSMA&#x2F;CA"></a>🥘CSMA&#x2F;CA</h4><p>CSMA&#x2F;CA，载波监听多路访问&#x2F;冲突避免机制，一般工作在无线网中。</p><ul><li>隐蔽结点问题——未能检测出媒体上已存在的信号的问题</li><li>暴露结点问题——发送结点检测到有冲突的结点其实并不影响其发送数据</li></ul><p>发送数据前，监听信道，若有冲突，则进行二进制指数避退。若信道空闲，则在维持一段时间后，再等待一段随机的时间后依然没有别的结点使用，即发送数据。由于每个结点采用的随机时间不同，这样可以减少冲突的机会。<br>先发送一段很小的请求传送报文RTS（Request to Send)给目标结点，并等待目标端回应报文CTS（Clear to Send）后，才开始传送数据。在RTS、CTS和后面发送的数据帧中都有一个称为网络分配向量的数据结构，指明本次发送数据所需要的时间，凡是能收到报文的其他结点将不会在这段时间里发送数据，确保接下来传送资料时，不会被碰撞。</p><h2 id="🥯局域网"><a href="#🥯局域网" class="headerlink" title="🥯局域网"></a>🥯局域网</h2><h3 id="🍳特点"><a href="#🍳特点" class="headerlink" title="🍳特点"></a>🍳特点</h3><ol><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ol><h3 id="🍳拓扑"><a href="#🍳拓扑" class="headerlink" title="🍳拓扑"></a>🍳拓扑</h3><p><img src="https://i.imgtg.com/2023/07/13/OzrrPP.md.png#height=250&id=SUb6X&originHeight=500&originWidth=695&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=348"></p><h3 id="🍳局域网的扩展"><a href="#🍳局域网的扩展" class="headerlink" title="🍳局域网的扩展"></a>🍳局域网的扩展</h3><h4 id="🥘中继器"><a href="#🥘中继器" class="headerlink" title="🥘中继器"></a>🥘中继器</h4><p>中继器工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网段，其功能是消除数字信号在基带传输中由于经过一长段电缆而造成的失真和衰减，使信号的波形和强度达到所需的要求；其原理是信号再生。</p><h4 id="🥘中继器-1"><a href="#🥘中继器-1" class="headerlink" title="🥘中继器"></a>🥘中继器</h4><p>集线器(Hub)也工作在<strong>物理层</strong>，相当于一个多接口的中继器，它可将多个结点连接成一个共享式的局域网，但任何时刻都只能有一个结点通过公共信道发送数据。——多个集线器级联成更大的局域网（碰撞域更大）</p><h4 id="🥘网桥"><a href="#🥘网桥" class="headerlink" title="🥘网桥"></a>🥘网桥</h4><p>网桥工作在<strong>数据链路层</strong>，可以互联不同的物理层、不同的MAC 子层及不同速率的以太网。网桥具有过滤帧及存储转发帧的功能，<strong>可以隔离冲突域，但不能隔离广播域</strong>。——将两个不同的局域网互连</p><h4 id="🥘网桥-1"><a href="#🥘网桥-1" class="headerlink" title="🥘网桥"></a>🥘网桥</h4><p>交换机工作在<strong>数据链路层</strong>，相当于一个多端口的网桥，是交换式局域网的核心设备。它允许端口之间建立多个并发连接，实现多个结点之间的并发传输。<br>因此，交换机的每个端口结点所占用的带宽不会因为端口结点数目的增加而减少，且整个交换机的总带宽会随着端口结点的增加而增加。交换机一般工作在全双工方式，有的局域网交换机采用存储转发方式进行转发，也有的交换机采用直通交换方式(即在收到顿的同时立即按顺的目的MAC 地址决定该的转发端口，而不必先缓存再处理)——利用交换机进行局域网扩展可以隔离冲突域，扩大广播风暴。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——操作系统引论</title>
      <link href="/2023/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/"/>
      <url>/2023/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="🥕操作系统"><a href="#🥕操作系统" class="headerlink" title="🥕操作系统"></a>🥕操作系统</h1><h2 id="🍄定义"><a href="#🍄定义" class="headerlink" title="🍄定义"></a>🍄定义</h2><p>操作系统是一组管理和控制计算机软件和硬件资源，合理组织计算机系统工作流程，以及方便用户使用的软件集合。</p><h1 id="🥕OS的目标和作用"><a href="#🥕OS的目标和作用" class="headerlink" title="🥕OS的目标和作用"></a>🥕OS的目标和作用</h1><h2 id="🍄目标"><a href="#🍄目标" class="headerlink" title="🍄目标"></a>🍄目标</h2><ol><li>方便性——配置OS以使计算机更容易使用</li><li>有效性——配置OS以使计算机更加高效</li></ol><h2 id="🍄作用"><a href="#🍄作用" class="headerlink" title="🍄作用"></a>🍄作用</h2><ol><li>OS作为用户与计算机硬件系统之间的接口——命令接口、程序接口、图形接口</li><li>OS作为用户与计算机系统资源的管理者——处理机管理、存储器管理、文件管理、设备管理</li><li>OS用作扩充机器（计算机资源抽象）</li></ol><h1 id="🥕OS的发展过程"><a href="#🥕OS的发展过程" class="headerlink" title="🥕OS的发展过程"></a>🥕OS的发展过程</h1><h2 id="🍄无操作系统时代"><a href="#🍄无操作系统时代" class="headerlink" title="🍄无操作系统时代"></a>🍄无操作系统时代</h2><h2 id="🍄批处理操作系统"><a href="#🍄批处理操作系统" class="headerlink" title="🍄批处理操作系统"></a>🍄批处理操作系统</h2><p>在计算机上加载一个专门监控软件，在其控制下，计算机能够自动地、成批地处理一个或多个用户的一批作业。</p><ol><li>单道批处理系统——一次只调入一个作业到内存中运行</li></ol><p>特点——自动性、顺序性、单道性</p><ol start="2"><li>多道程序设计技术——由不同用户提交的多个作业同时常驻主存运行——流水线</li></ol><p>特点——多道性、无序性、调度性</p><h2 id="🍄分时操作系统"><a href="#🍄分时操作系统" class="headerlink" title="🍄分时操作系统"></a>🍄分时操作系统</h2><p>一台计算机能连接多个用户终端，用户可通过各自的终端使用和控制计算机。<br>特点——多路性、独立性、及时性、交互性</p><h2 id="🍄实时操作系统"><a href="#🍄实时操作系统" class="headerlink" title="🍄实时操作系统"></a>🍄实时操作系统</h2><p>特点——实时性、高可靠性和安全性、系统整体性强、不要求很强的“会话”能力</p><h1 id="🥕操作系统的基本特征"><a href="#🥕操作系统的基本特征" class="headerlink" title="🥕操作系统的基本特征"></a>🥕操作系统的基本特征</h1><h2 id="🍄并发"><a href="#🍄并发" class="headerlink" title="🍄并发"></a>🍄并发</h2><ol><li>并发：两个或多个事件在同一时间段内发生</li><li>并行：两个或多个事件在同一时刻发生</li></ol><p>计算机系统中的并发运行——在多道程序环境下，在一段时间内，宏观上有多个程序在同时运行</p><h2 id="🍄共享"><a href="#🍄共享" class="headerlink" title="🍄共享"></a>🍄共享</h2><p>多个计算任务（或多道程序）对系统资源共同使用<br>资源共享方式——互斥共享方式&#x2F;同时访问方式</p><h2 id="🍄虚拟"><a href="#🍄虚拟" class="headerlink" title="🍄虚拟"></a>🍄虚拟</h2><p>通过某种技术把一个物理实体变为若干个逻辑上的对物。</p><h2 id="🍄异步性"><a href="#🍄异步性" class="headerlink" title="🍄异步性"></a>🍄异步性</h2><p>在多道程序环境下，允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。——进程是以人门不可预知的速度向前推进。</p><h1 id="🥕操作系统结构"><a href="#🥕操作系统结构" class="headerlink" title="🥕操作系统结构"></a>🥕操作系统结构</h1><p>无结构操作系统——模块化操作系统——分层式操作系统——微内核操作系统结构</p><h2 id="🍄大内核和微内核"><a href="#🍄大内核和微内核" class="headerlink" title="🍄大内核和微内核"></a>🍄大内核和微内核</h2><ol><li><strong>大内核</strong></li></ol><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。</p><ol start="2"><li><strong>微内核</strong></li></ol><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原理划分为若干服务，互相独立。<br>在微内核结构下，操作系统被划分为小的、定义良好的模块，只有微内核这一个模块运行在内核态，其他模块运行在用户态。<br>因此需要频繁地在用户态和核心态之间进行切换，所以会有一定地性能损失。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——计算机系统概论</title>
      <link href="/2023/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2023/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.imgtg.com/2023/07/12/Oz1Bmt.png#height=653&id=sKHox&originHeight=871&originWidth=1539&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1154"></h1><h1 id="🍟计算机系统概述"><a href="#🍟计算机系统概述" class="headerlink" title="🍟计算机系统概述"></a>🍟计算机系统概述</h1><h2 id="🌮计算机软、硬件"><a href="#🌮计算机软、硬件" class="headerlink" title="🌮计算机软、硬件"></a>🌮计算机软、硬件</h2><ol><li>硬件——计算机的实体部分，计算机中电子线路和物理装置，如主机、外设等</li><li>软件——看不见摸不着，由人门事先编制的具有各类特殊功能的程序组成，计算机中全部程序和文件<ol><li>系统软件——管理整个计算机系统（操作系统、语言处理程序、服务性程序、数据库管理系统、网络软件）</li><li>应用程序——按任务需要编制的各种程序</li></ol></li></ol><h2 id="🌮翻译方式"><a href="#🌮翻译方式" class="headerlink" title="🌮翻译方式"></a>🌮翻译方式</h2><h3 id="🍱编译"><a href="#🍱编译" class="headerlink" title="🍱编译"></a>🍱编译</h3><p>使用编译程序把高级语言的源程序<strong>翻译成机器代码</strong>的目标程序，并以<strong>文件形式保留</strong>，然后执行。</p><h3 id="🍱解释"><a href="#🍱解释" class="headerlink" title="🍱解释"></a>🍱解释</h3><p>使用解释程序，将源程序的一条语句翻译成对应机器语言的语句，并立即执行这条语句，接着再翻译源程序的下一条语句，并立即执行，并<strong>不形成目标程序</strong>，如此重复，直至完成源程序的全部翻译任务。</p><h2 id="🌮计算机语言"><a href="#🌮计算机语言" class="headerlink" title="🌮计算机语言"></a>🌮计算机语言</h2><h3 id="🍱机器语言"><a href="#🍱机器语言" class="headerlink" title="🍱机器语言"></a>🍱机器语言</h3><p>二进制代码表示的计算机语言，可以直接执行。</p><h3 id="🍱汇编语言"><a href="#🍱汇编语言" class="headerlink" title="🍱汇编语言"></a>🍱汇编语言</h3><p>用助记符（如ADD、SUB、…）编写的语言，需要通过汇编程序翻译成目标程序后才执行。</p><h3 id="🍱高级语言"><a href="#🍱高级语言" class="headerlink" title="🍱高级语言"></a>🍱高级语言</h3><p>如PASCAL，C，JAVA等，便于编写、阅读，接近自然语言，提高了软件的产量，便于移植，独立于硬件环境。</p><h2 id="🌮计算机组成和计算机体系结构"><a href="#🌮计算机组成和计算机体系结构" class="headerlink" title="🌮计算机组成和计算机体系结构"></a>🌮计算机组成和计算机体系结构</h2><h3 id="🍱计算机体系结构"><a href="#🍱计算机体系结构" class="headerlink" title="🍱计算机体系结构"></a>🍱计算机体系结构</h3><p>能够被程序员所见到的<strong>计算机系统的属性</strong>，即概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）——有无乘法指令</p><h3 id="🍱计算机组成"><a href="#🍱计算机组成" class="headerlink" title="🍱计算机组成"></a><strong>🍱计算机组成</strong></h3><p>如何实现计算机体系结构所体现的属性（具体指令的实现）——如何实现乘法指令</p><h1 id="🍟计算机的基本组成"><a href="#🍟计算机的基本组成" class="headerlink" title="🍟计算机的基本组成"></a>🍟计算机的基本组成</h1><h2 id="🌮冯·诺依曼计算机"><a href="#🌮冯·诺依曼计算机" class="headerlink" title="🌮冯·诺依曼计算机"></a>🌮冯·诺依曼计算机</h2><h3 id="🍱特点"><a href="#🍱特点" class="headerlink" title="🍱特点"></a><strong>🍱特点</strong></h3><ol><li>计算机由运算器、存储器、控制器、输入设备和输出设备<strong>五大部件</strong>组成。</li><li>指令和数据以同等地位存放于存储器内，并可按地址寻访。</li><li>指令和数据均用<strong>二进制数</strong>表示。</li><li>指令由<strong>操作码和地址码</strong>组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按顺序存放。</li><li>机器以<strong>运算器</strong>为中心，输入输出设备与存储器间的数据传送通过运算器完成。</li></ol><h3 id="🍱硬件框图"><a href="#🍱硬件框图" class="headerlink" title="🍱硬件框图"></a><strong>🍱硬件框图</strong></h3><p><img src="https://i.imgtg.com/2023/07/12/OznY36.md.png#height=375&id=jFJpD&originHeight=500&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=598"></p><ol><li>运算器——用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内。</li><li>存储器——用来存放数据和程序。</li><li>控制器——用来控制、指挥程序和数据的输入、运行以及处理运算结果。</li><li>输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。</li></ol><ul><li><strong>现代计算机硬件框图</strong></li></ul><p><img src="https://i.imgtg.com/2023/07/12/OznliP.md.png#height=250&id=MTwGh&originHeight=500&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=338"></p><h3 id="🍱存储程序"><a href="#🍱存储程序" class="headerlink" title="🍱存储程序"></a><strong>🍱存储程序</strong></h3><p>存储程序是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直到程序执行结束。</p><h2 id="🌮计算机工作步骤"><a href="#🌮计算机工作步骤" class="headerlink" title="🌮计算机工作步骤"></a>🌮计算机工作步骤</h2><h3 id="🍱上机前准备"><a href="#🍱上机前准备" class="headerlink" title="🍱上机前准备"></a><strong>🍱上机前准备</strong></h3><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h3 id="🍱计算机工作过程"><a href="#🍱计算机工作过程" class="headerlink" title="🍱计算机工作过程"></a><strong>🍱计算机工作过程</strong></h3><ol><li>把程序和数据装入主存储器</li><li>把源程序转换成可执行文件</li><li>从可执行文件的首地址开始逐条执行指令</li></ol><h3 id="🍱指令执行过程"><a href="#🍱指令执行过程" class="headerlink" title="🍱指令执行过程"></a><strong>🍱指令执行过程</strong></h3><p>程序中的一条指令的地址置于PC中，根据PC取出第一条指令，经过译码、执行步骤等，控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址。用新得到的指令地址继续读出第二条指令并执行，知道程序结束为止。<br>以取数指令（将指令地址码指示的存储单元中的操作数取出后送至运算器ACC中）：</p><ol><li>取指令——PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR\</li></ol><p>根据PC取指令到IR，将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读信号送读&#x2F;写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。</p><ol start="2"><li>分析指令——OP(IR)-&gt;CU</li></ol><p>指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。</p><ol start="3"><li>执行指令——Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li></ol><p>取数指令。将IR中指令的地址码送MAR，MAR中的内容送地址线，同时控制器将读信号送读&#x2F;写信号线从主存指定存储单元读出操作数，并通过数据线送至MDR，再传送到ACC中。<br>每取完一条指令，还需为下一条指令做准备，形成下一条指令的地址，(PC)+1-&gt;PC。</p><h1 id="🍟计算机主要技术指标"><a href="#🍟计算机主要技术指标" class="headerlink" title="🍟计算机主要技术指标"></a><strong>🍟计算机主要技术指标</strong></h1><h2 id="🌮机器字长"><a href="#🌮机器字长" class="headerlink" title="🌮机器字长"></a>🌮机器字长</h2><p>机器字长是指CPU一次能处理数据的位数，通常与CPU的寄存器位数有关</p><h2 id="🌮存储容量"><a href="#🌮存储容量" class="headerlink" title="🌮存储容量"></a>🌮存储容量</h2><p>存储器的容量应该包括主存容量和辅存容量。主存容量是指主存中存放二进制代码的总位数——存储容量&#x3D;存储单元个数（MAR的位数）*存储字长（MDR的位数）</p><h2 id="🌮运算速度"><a href="#🌮运算速度" class="headerlink" title="🌮运算速度"></a>🌮运算速度</h2><ol><li>吉普森法$T_{M}&#x3D;\sum_{i&#x3D;1}^{n} f_{i} t_{i}$</li></ol><p>——机器运行速度 &#x3D; 求和（第i种指令占全部操作的百分比数 * 第i种指令的执行时间）</p><ol start="2"><li>MIPS——每秒执行百万条指令</li><li>CPI——执行一条指令所需要的时钟周期数</li><li>FLOPS——每秒浮点运算的次数</li></ol><h2 id="🌮几个概念"><a href="#🌮几个概念" class="headerlink" title="🌮几个概念"></a>🌮几个概念</h2><h3 id="🍱吞吐量和响应时间"><a href="#🍱吞吐量和响应时间" class="headerlink" title="🍱吞吐量和响应时间"></a><strong>🍱吞吐量和响应时间</strong></h3><ol><li><strong>吞吐量</strong></li></ol><p>系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU能多块地取指令，数据能多块地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。——主要取决于主存地存取周期。</p><ol start="2"><li><strong>响应时间</strong></li></ol><p>用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果地等待时间——包括CPU时间（运行一个程序所需要花费的时间）与等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销等的时间）</p><h3 id="🍱主频和CPU时钟周期"><a href="#🍱主频和CPU时钟周期" class="headerlink" title="🍱主频和CPU时钟周期"></a><strong>🍱主频和CPU时钟周期</strong></h3><ol><li><strong>CPU时钟周期</strong></li></ol><p>通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个运作至少需要1个时钟周期</p><ol start="2"><li><strong>主频</strong></li></ol><p>机器内部时钟的频率</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——搜索专题</title>
      <link href="/2023/06/26/%E7%AC%AC%E5%85%AB%E7%AF%87%20%E6%8F%90%E9%AB%98%E7%AF%87%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/"/>
      <url>/2023/06/26/%E7%AC%AC%E5%85%AB%E7%AF%87%20%E6%8F%90%E9%AB%98%E7%AF%87%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="🚑深度优先搜索-DFS"><a href="#🚑深度优先搜索-DFS" class="headerlink" title="🚑深度优先搜索(DFS)"></a>🚑深度优先搜索(DFS)</h1><p>“深度”——一条路走到头<br>深度优先搜是一种枚举所有完整路径以遍历所有情况的搜索方法——使用<strong>递归</strong></p><h2 id="🚠例子——迷宫可行路径数"><a href="#🚠例子——迷宫可行路径数" class="headerlink" title="🚠例子——迷宫可行路径数"></a>🚠例子——迷宫可行路径数</h2><p>现有一个n∗m大小的迷宫，其中1表示不可通过的墙壁，0表示平地。每次移动只能向上下左右移动一格（不允许移动到曾经经过的位置），且只能移动到平地上。求从迷宫左上角到右下角的所有可行路径的条数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxp=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> map1[Maxp][Maxp];</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> isvisit[Maxp][Maxp]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> dx[Max]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[Max]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; map1[x][y]==<span class="number">0</span> &amp;&amp; !isvisit[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n<span class="number">-1</span> &amp;&amp; y==m<span class="number">-1</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isvisit[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Max;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x+dx[i];</span><br><span class="line">        <span class="type">int</span> nexty = y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isValid</span>(nextx,nexty))&#123;</span><br><span class="line">            <span class="built_in">DFS</span>(nextx,nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isvisit[x][y]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;map1[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚠例子——指定步数的迷宫问题"><a href="#🚠例子——指定步数的迷宫问题" class="headerlink" title="🚠例子——指定步数的迷宫问题"></a>🚠例子——指定步数的迷宫问题</h2><ul><li>要注意区别这两个例子之间的区别——增加了<strong>步数的限制</strong></li></ul><p>现有一个n∗m大小的迷宫，其中1表示不可通过的墙壁，0表示平地。每次移动只能向上下左右移动一格（不允许移动到曾经经过的位置），且只能移动到平地上。现从迷宫左上角出发，问能否在恰好第k步时到达右下角。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxp=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> map1[Maxp][Maxp];</span><br><span class="line"><span class="type">bool</span> visited[Maxp][Maxp]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//增加一个是否能够恰好到达的flag标识</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> dx[Max]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[Max]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; map1[x][y]==<span class="number">0</span> &amp;&amp; !visited[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//step标识当前已经是第几步了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>( x==n<span class="number">-1</span> &amp;&amp; y==m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//增加一个判断步数是否到达k</span></span><br><span class="line">        <span class="keyword">if</span>(step==k)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Max;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x+dx[i];</span><br><span class="line">        <span class="type">int</span> nexty = y+dy[i];</span><br><span class="line">        <span class="comment">//增加一个判断步数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isvalid</span>(nextx,nexty) &amp;&amp; step&lt;k )&#123;</span><br><span class="line">            <span class="built_in">DFS</span>(nextx,nexty,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[x][y]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;map1[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="🚑广度优先搜索-BFS"><a href="#🚑广度优先搜索-BFS" class="headerlink" title="🚑广度优先搜索(BFS)"></a>🚑广度优先搜索(BFS)</h1><p>当碰到岔路口时，总是先依次访问从该岔道口能直接到达的所有节点，再按这些节点被访问的顺序去依次访问它们能直接到达的所有结点——<strong>队列</strong><br>广度优先算法一般由<strong>队列</strong>实现，且总是按<strong>层次的顺序</strong>进行遍历，<strong>基本写法</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        取出队首元素top</span><br><span class="line">        访问队首元素top</span><br><span class="line">        将队首元素出队</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚠例子——数字操作"><a href="#🚠例子——数字操作" class="headerlink" title="🚠例子——数字操作"></a>🚠例子——数字操作</h2><p>从整数1开始，每轮操作可以选择将上轮结果加1或乘2。问至少需要多少轮操作才能达到指定整数n。</p><ul><li>一维的BFS的实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max=<span class="number">100000</span>;</span><br><span class="line"><span class="type">bool</span> inQueue[Max]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> cnt = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="type">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(front==n)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            inQueue[front]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(front*<span class="number">2</span>&lt;=n &amp;&amp; !inQueue[front*<span class="number">2</span>])</span><br><span class="line">                q.<span class="built_in">push</span>(front*<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(front+<span class="number">1</span>&lt;=n &amp;&amp; !inQueue[front+<span class="number">1</span>])</span><br><span class="line">                q.<span class="built_in">push</span>(front+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">BFS</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🚠例子——矩阵中的块"><a href="#🚠例子——矩阵中的块" class="headerlink" title="🚠例子——矩阵中的块"></a>🚠例子——矩阵中的块</h2><ul><li>二维数组的实现——要注意当前为队首的元素top<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> map1[Max][Max];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isQueue[Max][Max]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( isQueue[x][y]==<span class="literal">true</span> || map1[x][y]==<span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    Node.x=x,Node.y=y;</span><br><span class="line">    q.<span class="built_in">push</span>(Node);</span><br><span class="line">    isQueue[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node top = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx=top.x+dx[i];</span><br><span class="line">            <span class="type">int</span> nexty=top.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvalid</span>(nextx,nexty))&#123;</span><br><span class="line">                node Temp;</span><br><span class="line">                Temp.x=nextx;</span><br><span class="line">                Temp.y=nexty;</span><br><span class="line">                q.<span class="built_in">push</span>(Temp);</span><br><span class="line">                isQueue[nextx][nexty]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;map1[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举每一个位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isQueue[i][j]==<span class="literal">false</span> &amp;&amp; map1[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">BFS</span>(i,j);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——物理层</title>
      <link href="/2023/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2023/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="🍗基本概念"><a href="#🍗基本概念" class="headerlink" title="🍗基本概念"></a>🍗基本概念</h1><h2 id="🌯概念和术语"><a href="#🌯概念和术语" class="headerlink" title="🌯概念和术语"></a>🌯概念和术语</h2><h3 id="🥗数据、信号和信息"><a href="#🥗数据、信号和信息" class="headerlink" title="🥗数据、信号和信息"></a>🥗数据、信号和信息</h3><ol><li>数据——事件的某些属性规范化后的表现形式，它能被识别，也可以被描述。</li><li>信号——数据的具体表现形式，具有确定的物理描述。模拟信号&#x2F;数字信号</li><li>信息</li><li>带宽——带宽是指物理信道的频带宽度，单位为赫兹（Hz）、kHz、MHz。</li><li>信道容量——物理信道上能够进行无差错传输数据的最大能力C</li></ol><ul><li>香农公式$\mathbf{C}&#x3D;B \log _{2}\left(1+\frac{S}{N}\right)(b &#x2F; S)$——B信道带宽，S信号功率，N信道的加性白噪声</li></ul><h3 id="🥗通信系统模型"><a href="#🥗通信系统模型" class="headerlink" title="🥗通信系统模型"></a>🥗通信系统模型</h3><p><img src="https://i2.100024.xyz/2023/07/12/r2923b.webp#height=400&id=AfIA8&originHeight=800&originWidth=1103&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=552"></p><ul><li><strong>数字通信的优点</strong></li></ul><ol><li>抗干扰能力强</li><li>适合远距离传输</li><li>安全保密性好</li><li>适合多媒体信息传输</li></ol><h2 id="🌯传输媒体"><a href="#🌯传输媒体" class="headerlink" title="🌯传输媒体"></a>🌯传输媒体</h2><p> 金属导体、光导纤维、电磁波</p><h3 id="🥗金属导体"><a href="#🥗金属导体" class="headerlink" title="🥗金属导体"></a>🥗金属导体</h3><ol><li>双绞线</li><li>同轴电缆</li></ol><h3 id="🥗光导纤维"><a href="#🥗光导纤维" class="headerlink" title="🥗光导纤维"></a>🥗光导纤维</h3><p><img src="https://i2.100024.xyz/2023/07/12/r5cypn.webp#height=84&id=l6CuL&originHeight=337&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=293"></p><h3 id="🥗无线传输"><a href="#🥗无线传输" class="headerlink" title="🥗无线传输"></a>🥗无线传输</h3><p>无线通信是利用<strong>电磁波</strong>能够在自由空间中传播的特性进行的通信方式。</p><ol><li>微波传输</li><li>卫星传输</li></ol><h2 id="🌯数据传输方式"><a href="#🌯数据传输方式" class="headerlink" title="🌯数据传输方式"></a>🌯数据传输方式</h2><h3 id="🥗串行和并行方式"><a href="#🥗串行和并行方式" class="headerlink" title="🥗串行和并行方式"></a>🥗串行和并行方式</h3><ol><li>串行传输将待发送数据的各个比特位，按一定顺序依次发送</li><li>并行传输则将待发送数据的各个比特位<strong>使用多个信道同时发出</strong></li></ol><p><img src="https://i2.100024.xyz/2023/07/12/r6t98p.webp#height=223&id=LNb23&originHeight=893&originWidth=1160&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=290"></p><ul><li>串行通信方式只需要在收发双方之间建立<strong>一条通信信道</strong>，并行通信方式收发双方必须建立<strong>多条并行的通信信道</strong></li><li>在同样的传输速率下，并行传输在单位时间内传送码元数是串行传输的n倍</li></ul><h3 id="🥗同步和异步方式"><a href="#🥗同步和异步方式" class="headerlink" title="🥗同步和异步方式"></a>🥗同步和异步方式</h3><p>数据通信的一个基本要求是接收方必须知道接收的每一个比特位的开始时间和持续时间，这样才能正确的接收发送方发送来的数据。</p><ol><li><strong>异步传输方式</strong>——每个字节作为一个单元独立传输，字节之间的传输间隔任意。但是为了标志这一字节的开始和结尾，在这一字节之前加上1个起始位，在结尾处加上1-2位停止位。</li></ol><p><img src="https://i2.100024.xyz/2023/07/12/r8l6vt.webp#height=195&id=jYKPv&originHeight=390&originWidth=1305&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=653"></p><ul><li>每个字符前后的起始和停止位标识字符的开始和结束。</li><li>起始和停止位兼作线路两端的同步时钟，不再需要额外的时钟。</li><li>字符间间隔任意。</li><li>速率较低，适合于误码率高但是数据速率要求低的线路。</li></ul><ol start="2"><li><strong>同步传输方式</strong>——同步传输方式不是对每个字符单独进行同步，而是对一组字符组成的数据块进行同步。——同步的方法不是加起始位和停止位，而是在数据块前加特殊模式的位组合，并通过位填充或字符填充技术，保证数据块中的数据不会与同步字符混淆。</li></ol><p><img src="https://i2.100024.xyz/2023/07/12/ra36n4.webp#height=170&id=X6yZG&originHeight=339&originWidth=1344&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=672"></p><ul><li>开销小、效率高。</li><li>适合较高的速率传输数据。</li><li>整个数据块一旦有一位传错，就必须重传整个数据块的内容。</li></ul><h3 id="🥗单工、半双工、双工方式"><a href="#🥗单工、半双工、双工方式" class="headerlink" title="🥗单工、半双工、双工方式"></a>🥗单工、半双工、双工方式</h3><ol><li>单工信道——只允许数据在信道上的单向传输。</li><li>半双工信道——数据信号可以在信道上双向传输，但同一时刻只允许单向传输。 </li><li>全双工信道——允许数据同时双向传输。</li></ol><p><img src="https://i2.100024.xyz/2023/07/12/rbm7ye.webp#height=352&id=YKQUH&originHeight=703&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=472"></p><h1 id="🍗数字通信的主要过程"><a href="#🍗数字通信的主要过程" class="headerlink" title="🍗数字通信的主要过程"></a>🍗数字通信的主要过程</h1><p><img src="https://i2.100024.xyz/2023/07/12/rdp0m8.webp#height=423&id=h4l97&originHeight=846&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"></p><h2 id="🌯信源编码"><a href="#🌯信源编码" class="headerlink" title="🌯信源编码"></a>🌯信源编码</h2><p>——模拟信号数字化的过程</p><ol><li><strong>抽样</strong>：实现模拟信号离散化</li><li><strong>量化</strong>：无线幅值有限化</li><li><strong>编码</strong>：量化结果码组化</li></ol><h3 id="🥗信道编码"><a href="#🥗信道编码" class="headerlink" title="🥗信道编码"></a>🥗信道编码</h3><ol><li>非归零编码</li></ol><p><img src="https://i2.100024.xyz/2023/07/12/s7ecbl.webp#height=158&id=hMPBx&originHeight=316&originWidth=1292&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=646"></p><ol start="2"><li>曼彻斯特编码</li></ol><p>每一位中间有一次跳变，既表示数据，又作为同步信号。<br>从高电平跳变到低电平表示“0”，从低电平跳变到高电平表示“1”。<br><img src="https://i2.100024.xyz/2023/07/12/s81gzm.webp#height=144&id=EB7Je&originHeight=288&originWidth=1324&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=662"><br>——<strong>占用更多的信道带宽</strong>。即在同样的波特率的情况下，要比非归零编码多占用一信道带宽，或者说编码效率只有50%</p><ol start="3"><li>差分曼彻斯特编码</li></ol><p>每一位中间也有一次跳变，但这种跳变仅作为同步信号，不表示数据。<br>数据值通过每位开始时无跳变来表示；有跳变表示0，无跳变表示1。<br><img src="https://i2.100024.xyz/2023/07/12/s9hub1.webp#id=ZPeog&originHeight=297&originWidth=1307&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍗多路复用技术"><a href="#🍗多路复用技术" class="headerlink" title="🍗多路复用技术"></a>🍗多路复用技术</h1><p>将多路信号复用在一条信道上，使一条信道能够同时传输多路数据信号。</p><ol><li>频分多路复用（Frequency Division Multiplexing,FDM）</li><li>时分多路复用（Time Division Multiplexing,TDM）</li><li>波分复用（Wavelength Division Multiplexing,WDM）</li><li>码分复用（Code Division Multiplexing,CDM）</li></ol><h2 id="🌯频分复用"><a href="#🌯频分复用" class="headerlink" title="🌯频分复用"></a>🌯频分复用</h2><p>在频分多路复用中，信道的带宽被分成若干个互不重叠的频段，每路信号占用其中一个频段，因而在接收端可采用适当的带通滤波器将多路信号分开，从而恢复出所需要的原始信号。<br><img src="https://i2.100024.xyz/2023/07/12/sastbt.webp#height=159&id=RB2xe&originHeight=318&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=391"></p><h2 id="🌯时分复用"><a href="#🌯时分复用" class="headerlink" title="🌯时分复用"></a>🌯时分复用</h2><p>单路抽样信号在时间上离散的相邻脉冲间有很大空隙，在空隙中插入若干路其他抽样信号，只要使各路抽样信号在时间上不重叠并能区分开，那么一个信道就有可能同时传输多路信号，达到多路复用的目的。这种多路复用称为时分多路复用（TDM）。<br><img src="https://i2.100024.xyz/2023/07/12/sdb7zv.webp#height=180&id=zzsOx&originHeight=359&originWidth=771&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=386"><br>时分复用是<strong>将时间划分为一段段等长的时分复用帧（TDM 帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。<br>时分复用的所有用户是在不同的时间占用同样的频带宽度。</p><h2 id="🌯码分复用"><a href="#🌯码分复用" class="headerlink" title="🌯码分复用"></a>🌯码分复用</h2><p>码分复用将每个比特时间都划分为m个短时间片，称为码片（chip）<br>每个参与复用的用户都被分配一个m（128或64）位的码型，各码型之间成正交关系。<br>某用户若要发“1”，则直接发出自己的码型；若要发“0”，则发自己码型的反码。<br>每个用户可以在同样的时间使用同样的频带进行通信，各用户的码型相互正交，因此各用户之间不会造成干扰。在公共信道上这些不同的码型叠加在一起与信道白噪声相似，破译困难，安全性高。<br><img src="https://i.imgtg.com/2023/07/12/OzixBj.md.png#height=250&id=eymSy&originHeight=500&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=459"></p><h2 id="🌯波分复用"><a href="#🌯波分复用" class="headerlink" title="🌯波分复用"></a>🌯波分复用</h2><p>波分复用本质上是光域的频分复用。</p><h1 id="🍗宽带接入技术"><a href="#🍗宽带接入技术" class="headerlink" title="🍗宽带接入技术"></a>🍗宽带接入技术</h1><ol><li>用户数字线技术</li><li>光纤同轴混合技术</li><li>无线技术</li><li>光纤入户技术</li></ol><h1 id="🍗物理层协议"><a href="#🍗物理层协议" class="headerlink" title="🍗物理层协议"></a>🍗物理层协议</h1><p>物理层协议实际上就是指<strong>通信接口标准</strong></p><ol><li>接口的机械特性——规定接口的扦头（座）的规格，尺寸，扦脚数目等。如RS-232C使用25脚扦头（座）。</li><li>功能特性——对接口的各信号线的作用进行定义和说明。</li><li>规程特性——规定各信号线之间的相互关系，动作发生的先后次序。</li><li>电气特性——规定信号的传输速率，电平关系，负载要求和电缆长度等。电压</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——数据结构专题</title>
      <link href="/2023/06/19/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%8F%90%E9%AB%98%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%EF%BC%881%EF%BC%89/"/>
      <url>/2023/06/19/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%8F%90%E9%AB%98%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="🍈栈的应用"><a href="#🍈栈的应用" class="headerlink" title="🍈栈的应用"></a>🍈栈的应用</h1><p>栈（stack）——先进后出</p><ul><li>栈顶指针：始终指向栈的最上方元素的标记——使用数组实现栈时，栈顶指针是一个int型的变量（数组下标从0开始），通常记为TOP；使用链表实现栈时，栈顶指针是一个int*型的指针。<strong>栈中没有元素（栈空时）令TOP为-1</strong>。</li></ul><h2 id="🍉栈的常用操作"><a href="#🍉栈的常用操作" class="headerlink" title="🍉栈的常用操作"></a>🍉栈的常用操作</h2><p>使用数组st[]来实现栈，int型变量TOP表示栈顶元素的下标（数组下标从0开始），这样栈空时TOP为-1</p><ol><li><strong>清空（clear）</strong></li></ol><p>栈清空操作将栈顶指针TOP置为-1，表示栈内没有元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TOP=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>获取栈内元素个数（size）</strong></li></ol><p>由于栈顶原指针TOP始终指向栈顶元素，而数组下标从0开始，因此栈顶元素的数为TOP+1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TOP+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>判空（empty）</strong></li></ol><p>由栈顶指针TOP的定义可知到，TOP为-1时栈空</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TOP==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>进栈（push）</strong></li></ol><p>push(x)操作将元素x置于栈顶，栈顶指针TOP指向栈顶元素，因此先把TOP+1，在把x存到TOP指向的位置</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    st[++TOP]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>出栈（pop）</strong></li></ol><p>pop()操作将栈顶元素出栈，而事实上可以直接将栈顶指针TOP减1来实现这个操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TOP--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>取栈顶元素（top）</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st[TOP];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>使用<strong>STL中的stack</strong>可以轻松的实现栈</li></ul><p>STL中没有实现栈的清空，如果需要实现栈的清空，可以<strong>用一个while循环反复pop出元素直到栈空</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍉例题"><a href="#🍉例题" class="headerlink" title="🍉例题"></a>🍉例题</h2><ol><li><strong>合法的出栈序列</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> x, nowMax = <span class="number">0</span>;<span class="comment">//当前栈中元素的最大值</span></span><br><span class="line">    <span class="type">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; nowMax) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nowMax + <span class="number">1</span>; j &lt;= x; j++) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(j);<span class="comment">//序列中小于这个数的左右数都要先进栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            nowMax = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">top</span>() != x) &#123;<span class="comment">//栈顶与读入的数字</span></span><br><span class="line">            isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(isValid ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="🍈队列的应用"><a href="#🍈队列的应用" class="headerlink" title="🍈队列的应用"></a>🍈队列的应用</h1><p>队列（queue）——先进先出<br>需要<strong>一个队首指针front来指向队首元素的前一个位置</strong>，使用<strong>一个队尾指针rear来指向队尾元素</strong></p><h2 id="🍉队列的常用操作"><a href="#🍉队列的常用操作" class="headerlink" title="🍉队列的常用操作"></a>🍉队列的常用操作</h2><p>使用数组q[]来实现队列，int型变量front存放队首元素的前一个元素的下标，rear存放队尾元素的下标（数组下标从0开始）</p><ol><li><strong>清空（clear）</strong></li></ol><p>使用数组来实现队列，初始状态front&#x3D;-1，rear&#x3D;-1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>获取队列内元素的个数（size）</strong></li></ol><p>队列中的元素个数可以通过rear-front来计算</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear-front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>判空（empty）</strong></li></ol><p>判定队列为空的条件为rear&#x3D;&#x3D;front</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front==rear)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>入队（push）</strong></li></ol><p>由于队尾指针rear指向队尾元素，因此把元素入队时，需要先把rear加1，然后再存放到rear指向的位置</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>出队（pop）</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    front++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>去队首元素（get_front）</strong></p></li></ol><p>由于队首指针front指向的是队首元素的前一个元素，队首元素是front+1的位置</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>去队尾元素（get_rear）</strong></li></ol><p>队尾指针rear指向的是队尾元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_rear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[rear];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样的，STL中的queue可以很好的实现队列</li></ul><p>队列的清空操作同栈，一个while循环反复pop出元素直到队列为空</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="🍈链表处理"><a href="#🍈链表处理" class="headerlink" title="🍈链表处理"></a>🍈链表处理</h1><h2 id="🍉链表的概念"><a href="#🍉链表的概念" class="headerlink" title="🍉链表的概念"></a>🍉链表的概念</h2><p>链表由若干个结点组成（每个结点代表一个元素），且结点在内存中的存储位置通常是不连续的。除此之外，链表的两个结点之间一般通过一个指针来从一个结点指向另一个节点，因此链表一般有两部分构成：数据域和指针域</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">node* next;<span class="comment">//指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据域存放结点要存储的数据，指针域指向下一个结点的地址</li></ul><p>链表是否存在头结点可以把链表分为带头结点的链表和不带头结点的链表。头结点一般称为head，其数据域data不存放任何内容，而指针域next指向第一个数据域有内容的结点（第一个结点）</p><h2 id="🍉为链表结点分配内存空间"><a href="#🍉为链表结点分配内存空间" class="headerlink" title="🍉为链表结点分配内存空间"></a>🍉为链表结点分配内存空间</h2><h3 id="🥭malloc函数"><a href="#🥭malloc函数" class="headerlink" title="🥭malloc函数"></a>🥭malloc函数</h3><p>malloc函数是C语言stdlib.h头文件下用于申请动态内存的函数，其返回类型是申请同变量类型的指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span>* p = (<span class="keyword">typename</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">typename</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><h3 id="🥭new函数"><a href="#🥭new函数" class="headerlink" title="🥭new函数"></a>🥭new函数</h3><p>new是C++中用来申请动态控件的运算符，其返回类型同样是申请的同变量类型的指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span>* p = <span class="keyword">new</span> <span class="keyword">typename</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span></span><br></pre></td></tr></table></figure><h3 id="🥭内存泄漏"><a href="#🥭内存泄漏" class="headerlink" title="🥭内存泄漏"></a>🥭内存泄漏</h3><p>内存泄漏是指使用malloc与new开辟出来的内存空间在使用过后没有释放，导致其在程序结束之前始终占据该内存空间，这在一些较大的程序中容易导致内存消耗过快以致最后无内存可分配</p><ul><li><strong>使用完malloc和new开辟出来的空间后，必须将其释放</strong></li></ul><ol><li><strong>free函数</strong></li></ol><p>free函数对应malloc函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p>实现效果：——指针变量p本身并没有消失，只不过让它指向了空地址NULL</p><ol><li>释放指针变量p所指向的内存空间</li><li>将指针变量p指向空地址NULL</li><li><strong>delete运算符</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(p);</span><br></pre></td></tr></table></figure></li></ol><h2 id="🍉链表的基本操作"><a href="#🍉链表的基本操作" class="headerlink" title="🍉链表的基本操作"></a>🍉链表的基本操作</h2><ol><li><p><strong>创建链表</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="type">int</span> Array[])</span></span>&#123;</span><br><span class="line">    node *p,*pre,*head;</span><br><span class="line">    head=<span class="keyword">new</span> node;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    pre=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> node;</span><br><span class="line">        p-&gt;data=Array[i];</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next=p;</span><br><span class="line">        pre=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>查找元素</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(node* head,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入元素</strong></p></li></ol><p>在第n个位置插入元素x——插入完成后第n个位置为x</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node* head,<span class="type">int</span> pos,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    node* p=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pos<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p=p-&gt;next;<span class="comment">//使p指向插入位置的前一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* q=<span class="keyword">new</span> node;</span><br><span class="line">    q-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=q;</span><br><span class="line">    q-&gt;data=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>删除元素</strong></li></ol><p>删除元素是指删除链表上所有值为给定的数x，需要一个node* pre来存储前驱节点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete</span><span class="params">(node* head,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    node* p=head-&gt;next;</span><br><span class="line">    node* pre=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)&#123;</span><br><span class="line">            pre-&gt;next=p-&gt;next;</span><br><span class="line">            <span class="built_in">delete</span>(p);</span><br><span class="line">            p=pre-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍉静态链表"><a href="#🍉静态链表" class="headerlink" title="🍉静态链表"></a>🍉静态链表</h2><p>静态链表的实现原理是hash，即通过建立一个结构体数组，并令数组下标直接表示结点的地址，来达到直接访问数组中的元素就能访问结点的效果——<strong>静态链表是不需要头结点的</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">typename</span> data;</span><br><span class="line"><span class="type">int</span> next;</span><br><span class="line">&#125;node[size];</span><br></pre></td></tr></table></figure><p>next是一个int型的整数，用以存放下一个结点的地址（数组下标）</p><ul><li>使用静态链表时，尽量不要把结构体类型名和结构体变量名取成相同的名字</li></ul><h3 id="🥭静态链表的通用解题步骤"><a href="#🥭静态链表的通用解题步骤" class="headerlink" title="🥭静态链表的通用解题步骤"></a>🥭静态链表的通用解题步骤</h3><ol><li><p>定义静态链表</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> address;<span class="comment">//结点地址</span></span><br><span class="line"><span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="type">int</span> next;</span><br><span class="line">XXX<span class="comment">//结点的某个性质，根据不同的题目进行设置</span></span><br><span class="line">&#125;node[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure></li><li><p>在程序的时候，对静态链表进行<strong>初始化</strong>——对定义中的XXX进行初始化，将其定义为正常情况下达不到的数字</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">    node[i].XXX=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据题目中所给出的一条链表的首结点，遍历整条链表——同时也可对XXX进行标定，对有效节点的个数进行计数等等</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p = begin,count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="number">-1</span>)&#123;<span class="comment">//-1表示链表结束</span></span><br><span class="line">    XXX=<span class="number">1</span>;</span><br><span class="line">    count++;</span><br><span class="line">    p=node[p]-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用静态链表时，直接采用地址映射即hash的方式，数组的下标会不连续，同时也可能出现不是有效结点的结点（可能不在链表上的结点）为了能够可控的访问有效结点，一般需要对数组进行排序，把有效节点移动到数组左端——可以使用XXX来进行排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.XXX==<span class="number">-1</span>||b.XXX==<span class="number">-1</span>)&#123;<span class="comment">//a和b之间至少有一个是无效结点</span></span><br><span class="line">        <span class="keyword">return</span> a.XXX&gt;b.XXX;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        二级排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——计算机网络体系结构</title>
      <link href="/2023/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="🌺网络体系结构的基本思想"><a href="#🌺网络体系结构的基本思想" class="headerlink" title="🌺网络体系结构的基本思想"></a>🌺网络体系结构的基本思想</h1><h2 id="🌷分层思想"><a href="#🌷分层思想" class="headerlink" title="🌷分层思想"></a>🌷分层思想</h2><p>将一个庞大、复杂的问题分解若干个功能相对单一、结构比较简单、处理更为方便的局部问题，并分别解决。这种“化整为零”的方法就是分层思想。<br>计算机网络体系结构的分层思想——每层在自己下层所提供服务的支持下，通过自身内部功能实现一种或几种特定的服务。</p><h2 id="🌷分层思想的优点"><a href="#🌷分层思想的优点" class="headerlink" title="🌷分层思想的优点"></a>🌷分层思想的优点</h2><ol><li>耦合度低（独立性强）</li><li>适应性强</li><li>易于实现和维护</li></ol><h1 id="🌺计算机网络体系结构"><a href="#🌺计算机网络体系结构" class="headerlink" title="🌺计算机网络体系结构"></a>🌺计算机网络体系结构</h1><h2 id="🌷定义"><a href="#🌷定义" class="headerlink" title="🌷定义"></a>🌷定义</h2><p><strong>层、层间接口</strong>及<strong>协议</strong>的集合被称为计算机网络体系结构。</p><h2 id="🌷一些名词"><a href="#🌷一些名词" class="headerlink" title="🌷一些名词"></a>🌷一些名词</h2><p><img src="https://i2.100024.xyz/2023/07/12/qgs52y.webp#height=236&id=FrFQN&originHeight=472&originWidth=887&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=444"></p><h3 id="🍀实体"><a href="#🍀实体" class="headerlink" title="🍀实体"></a>🍀实体</h3><p>任何可发送或接收信息的硬件或软件进程。</p><h3 id="🍀接口"><a href="#🍀接口" class="headerlink" title="🍀接口"></a><strong>🍀接口</strong></h3><p>同系统内相邻层之间的交互通道，也称为服务访问点SAP（Service Access Point）。</p><h3 id="🍀协议"><a href="#🍀协议" class="headerlink" title="🍀协议"></a><strong>🍀协议</strong></h3><p>控制<strong>对等层实体</strong>间进行数据交换的规则、约定和标准。——协议的影响范围仅限本层，“协议是水平的”</p><h3 id="🍀服务"><a href="#🍀服务" class="headerlink" title="🍀服务"></a><strong>🍀服务</strong></h3><p>为保证上层对等实体间的通信，由下层向上层提供的功能。——服务的影响范围上下相邻层，“服务是垂直的”<br><img src="https://i2.100024.xyz/2023/07/12/qhj9iu.webp#height=336&id=fMo2r&originHeight=671&originWidth=1532&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=766"></p><h2 id="🌷计算机网络体系结构模型"><a href="#🌷计算机网络体系结构模型" class="headerlink" title="🌷计算机网络体系结构模型"></a>🌷计算机网络体系结构模型</h2><ol><li>同一网络中的任意两个端系统必须有相同的层次</li><li>每层都是用其下层提供的服务，也都向其上层提供服务</li><li>通信仅能在对等层之间进行，非对等层之间不能通信</li><li>除了最底层进行实际的物理通信外，其余对等层通信均为逻辑通信</li></ol><h2 id="🌷网络协议"><a href="#🌷网络协议" class="headerlink" title="🌷网络协议"></a>🌷网络协议</h2><p><strong>网络协议</strong>(network protocol，简称协议)，是为进行网络数据交换而建立的规则、标准或约定。<br>——对等实体间的共识就是协议</p><h3 id="🍀通信协议的三要素"><a href="#🍀通信协议的三要素" class="headerlink" title="🍀通信协议的三要素"></a><strong>🍀通信协议的三要素</strong></h3><p>语法、语义、时序（同步）</p><ol><li><strong>语法</strong>——协议元素与数据的组合结构——<strong>报文格式</strong></li><li>语义——对协议中各协议元素的含义的解释</li><li>时序——在通信过程中，通信两方操作的执行顺序与规则</li></ol><h3 id="🍀协议数据单元"><a href="#🍀协议数据单元" class="headerlink" title="🍀协议数据单元"></a><strong>🍀协议数据单元</strong></h3><p>——对等层之间交换的信息报文PDU<br><img src="https://i2.100024.xyz/2023/07/12/qmarbi.webp#height=27&id=HOCiH&originHeight=53&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=273"><br>PDU由协议控制信息（协议头）和数据（SDU）组成</p><h1 id="🌺OSI网络模型"><a href="#🌺OSI网络模型" class="headerlink" title="🌺OSI网络模型"></a>🌺OSI网络模型</h1><p><img src="https://i2.100024.xyz/2023/07/12/qns809.webp#height=401&id=BsMqQ&originHeight=802&originWidth=1078&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=539"></p><h2 id="🌷OSI-x2F-RM的层次、协议和各层PDU"><a href="#🌷OSI-x2F-RM的层次、协议和各层PDU" class="headerlink" title="🌷OSI&#x2F;RM的层次、协议和各层PDU"></a>🌷<strong>OSI&#x2F;RM的层次、协议和各层PDU</strong></h2><p><img src="https://i2.100024.xyz/2023/07/12/qollwf.webp#height=319&id=SElBn&originHeight=637&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=597"></p><h2 id="🌷OSI-x2F-RM各层简介"><a href="#🌷OSI-x2F-RM各层简介" class="headerlink" title="🌷OSI&#x2F;RM各层简介"></a>🌷<strong>OSI&#x2F;RM各层简介</strong></h2><h3 id="🍀应用层"><a href="#🍀应用层" class="headerlink" title="🍀应用层"></a><strong>🍀应用层</strong></h3><p>应用层（Application Layer）是OSI参考模型的最高层，是计算机用户以及各种应用程序和网络之间的接口，其功能是<strong>直接向用户提供服务并完成用户希望在网络上完成的各种工作</strong>。</p><h3 id="🍀表示层"><a href="#🍀表示层" class="headerlink" title="🍀表示层"></a><strong>🍀表示层</strong></h3><p>表示层（Presentation Layer）是<strong>对上层数据或命令进行解释</strong>以保证一个主机应用层信息可以被另一个主机的应用程序理解。</p><h3 id="🍀会话层"><a href="#🍀会话层" class="headerlink" title="🍀会话层"></a><strong>🍀会话层</strong></h3><p>会话层（Session Layer）是<strong>应用程序和网络之间的接口</strong>，负责在网络中的两节点之间<strong>建立、维持和终止通信</strong>。</p><h3 id="🍀传输层"><a href="#🍀传输层" class="headerlink" title="🍀传输层"></a><strong>🍀传输层</strong></h3><p>传输层（Transport layer）是<strong>通信子网与资源子网的分界层</strong>，是通信子网和资源子网的接口和桥梁。向高层屏蔽数据通信的所有细节，<strong>为用户提供透明的报文传输</strong>，保证报文可靠的、正确的传输。<br>——提供面向连接的和面向无连接的传输服务。</p><h3 id="🍀网络层"><a href="#🍀网络层" class="headerlink" title="🍀网络层"></a><strong>🍀网络层</strong></h3><p>网络层（Network layer）是通信子网的最高层，<strong>在下两层的基础上向资源子网提供服务</strong>。在选择路由时，网络层将综合考虑优先权、网络拥塞程度、服务质量以及路由代价等决定从一个节点到另一个节点的<strong>最佳路径</strong>。</p><h3 id="🍀数据链路层"><a href="#🍀数据链路层" class="headerlink" title="🍀数据链路层"></a><strong>🍀数据链路层</strong></h3><p>数据链路层（Data Link Layer）负责建立和管理节点间的链路，<strong>控制网络层与物理层之间的通信</strong>。通过差错控制、流量控制方法，在不可靠的物理介质上提供可靠的数据传输。<br>数据链路层又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p><ul><li>MAC的主要任务是解决共享型网络中的信道竞争问题，完成网络介质的访问控制。</li><li>LLC的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。</li></ul><h3 id="🍀物理层"><a href="#🍀物理层" class="headerlink" title="🍀物理层"></a><strong>🍀物理层</strong></h3><p>物理层（Physical Layer）是OSI的最底层，也是真正将数据在传输媒介上进行传输的层次。物理层的作用是为上层实现在物理介质上正确、透明的传送比特流。</p><h1 id="🌺Internet模型"><a href="#🌺Internet模型" class="headerlink" title="🌺Internet模型"></a>🌺Internet模型</h1><p>模型中两个核心协议为TCP和IP协议，Internet模型也称为TCP&#x2F;IP模型。<br><img src="https://i2.100024.xyz/2023/07/12/qtui46.webp#height=223&id=gD11O&originHeight=445&originWidth=700&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=350"></p><h3 id="🍀应用层-1"><a href="#🍀应用层-1" class="headerlink" title="🍀应用层"></a><strong>🍀应用层</strong></h3><p>大体对应OSI参考模型的应用层、表示层和会话层。</p><h3 id="🍀传输层-1"><a href="#🍀传输层-1" class="headerlink" title="🍀传输层"></a><strong>🍀传输层</strong></h3><p>大体上对应OSI的传输层。该层协议包括：</p><ul><li><strong>TCP(传输控制协议Transmission control protocol)</strong></li></ul><p>——可靠的，面向连接的协议，将报文以字节流形式从源主机进程发到目的主机进程。</p><ul><li><strong>UDP(用户数据报协议User Datagram protocol )</strong></li></ul><p>——不可靠的，无连接的协议。</p><h3 id="🍀网络层-1"><a href="#🍀网络层-1" class="headerlink" title="🍀网络层"></a><strong>🍀网络层</strong></h3><h3 id="🍀网络接口层"><a href="#🍀网络接口层" class="headerlink" title="🍀网络接口层"></a><strong>🍀网络接口层</strong></h3><p>大体上对应OSI的物理层和链路层。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——查找</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="🎰查找"><a href="#🎰查找" class="headerlink" title="🎰查找"></a>🎰查找</h1><p><img src="https://i2.100024.xyz/2023/06/19/h988zv.webp#height=677&id=LoZuO&originHeight=903&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=915"></p><h2 id="🎮查找的基本概念"><a href="#🎮查找的基本概念" class="headerlink" title="🎮查找的基本概念"></a>🎮查找的基本概念</h2><h3 id="🧵查找（Searching）"><a href="#🧵查找（Searching）" class="headerlink" title="🧵查找（Searching）"></a>🧵查找（Searching）</h3><p>就是在由一组记录组成的集合中寻找关键字值<strong>等于给定值的某个记录</strong>，或是寻找属性值符合特定条件的某些记录。若表中存在这样一个记录，则称查找是成功的，此时查找的结果给出<strong>整个记录的信息</strong>，或指示<strong>该记录在查找表中的位置</strong>。若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可以给出一个“空”记录或者“空”指针。</p><h3 id="🧵查找表（Search-Table）"><a href="#🧵查找表（Search-Table）" class="headerlink" title="🧵查找表（Search Table）"></a>🧵查找表（Search Table）</h3><p>是种以同一类型的记录构成的集合为逻辑结构，以查找为核心运算的数据结构。</p><h3 id="🧵关键字（Key）"><a href="#🧵关键字（Key）" class="headerlink" title="🧵关键字（Key）"></a>🧵关键字（Key）</h3><p>是数据元素中某个数据项的值，又称为<strong>键值</strong>，用它可以标识一个数据元素，也可以标识一个记录的某个数据项(字段)。</p><h3 id="🧵主关键字（Primaty-Key）"><a href="#🧵主关键字（Primaty-Key）" class="headerlink" title="🧵主关键字（Primaty Key）"></a>🧵主关键字（Primaty Key）</h3><p>可以<strong>唯一地标识</strong>一个记录的关键字。对于那些可以标识多个数据元素(或记录)的关键字，称为**次关键字(Secondary Key)**。</p><h3 id="🧵查找表的分类"><a href="#🧵查找表的分类" class="headerlink" title="🧵查找表的分类"></a>🧵查找表的分类</h3><h4 id="🧶静态查找表"><a href="#🧶静态查找表" class="headerlink" title="🧶静态查找表"></a>🧶静态查找表</h4><p>只作查找操作的查找表。主要操作有：</p><ol><li>查询某个“特定的”数据元素是否在查找表中</li><li>检索某个“特定的”数据元素和各种属性。</li></ol><ul><li>顺序查找、二分查找、插值查找、斐波那契查找、线性索引查找</li></ul><h4 id="🧶动态查找表"><a href="#🧶动态查找表" class="headerlink" title="🧶动态查找表"></a>🧶动态查找表</h4><p>动态表的特点是表结构本身是在查找过程中动态生成的。同时在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。主要操作有：</p><ol><li>查找时插入数据元素</li><li>查找时删除数据元素</li></ol><p>二叉排序树、平衡二叉树、B 树、散列</p><h3 id="🧵平均查找长度"><a href="#🧵平均查找长度" class="headerlink" title="🧵平均查找长度"></a>🧵平均查找长度</h3><p>在查找的过程中，一次查找的长度是指需要比较的关键字的次数，而平均查找长度则是所有查找过程中进行关键字的比较的次数的平均值。<br>$A S L&#x3D;\sum_{i&#x3D;1}^{n} P i C i$<br>n 表示的是查找表的长度。<br>Pi 表示的是查找第 i 个数据元素的概率，一般认为每个数据元素的查找概率相等。<br>Ci 表示的是找到第 i 个数据元素所需进行的比较次数。<br><strong>平均查找长度是衡量查找算法效率的最主要的指标</strong></p><h2 id="🎮顺序查找法"><a href="#🎮顺序查找法" class="headerlink" title="🎮顺序查找法"></a><strong>🎮顺序查找法</strong></h2><h3 id="🧵基本思想"><a href="#🧵基本思想" class="headerlink" title="🧵基本思想"></a>🧵基本思想</h3><p>顺序查找，就是从第一个元素开始，按索引顺序遍历待查找序列，直到找出给定目标或者查找失败。<br>把待查关键字key放入哨兵位置（i&#x3D;0），再从后往前依次把表中元素和key比较，如果返回值为0则查找失败，表中没有这个key值，如果返回值为元素的位置i（i!&#x3D;0）则查找成功，设置哨兵的位置是为了<strong>加快执行速度</strong>。</p><h3 id="🧵时间复杂度"><a href="#🧵时间复杂度" class="headerlink" title="🧵时间复杂度"></a>🧵时间复杂度</h3><p>O(n)，平均查找时间 &#x3D; 列表长度 &#x2F; 2</p><h3 id="🧵特点"><a href="#🧵特点" class="headerlink" title="🧵特点"></a>🧵特点</h3><ol><li>对待查序列（表）无要求 – 待查找序列可以是有序，也可以是无序；</li><li>从第一个元素开始；</li><li>需要逐一遍历整个待查序列（除非已经找到）；</li><li>若查找到最后一个元素还没找到，则查找失败；</li></ol><h2 id="🎮分块查找法"><a href="#🎮分块查找法" class="headerlink" title="🎮分块查找法"></a><strong>🎮分块查找法</strong></h2><h3 id="🧵基本思想-1"><a href="#🧵基本思想-1" class="headerlink" title="🧵基本思想"></a>🧵基本思想</h3><p>分块查找，也叫<strong>索引顺序查找</strong>，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表。建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序。<br><strong>分块有序：</strong>指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。<br>先把查找表分为若干子表，要求每个子表的元素都要比他后面的子表的元素小，也就是保证块间是有序的（但是子表内不一定有序），把各子表中的最大关键字构成一张索引表，表中还包含各子表的起始地址。他的特点是：<strong>块间有序，块内无序，查找时块间进行索引查找，块内进行顺序查找</strong>。</p><h3 id="🧵算法原理"><a href="#🧵算法原理" class="headerlink" title="🧵算法原理"></a>🧵算法原理</h3><p>所有前期准备工作完成后，开始在此基础上进行分块查找。分块查找的过程分为两步进行：<br>1、确定要查找的关键字可能存在的具体块（子表）；<br>2、在具体的块中进行顺序查找。</p><h3 id="🧵性能分析"><a href="#🧵性能分析" class="headerlink" title="🧵性能分析"></a>🧵性能分析</h3><p>一个是关键字与索引表作比较，另一个是关键字逐个和块内元素作比较，所以查找效率为：<br>ASL &#x3D; Lb + Lw<br>Lb ：对索引表查找的 ASL——Lb &#x3D; log2(s&#x2F;n + 1)<br>Lw ：对块内查找的 ASL——Lw &#x3D; s &#x2F; 2<br>其中，s 为每块内部的记录个数，n&#x2F;s 即块的数目。<br>所以，分块查找的效率为，ASL ≈ log2(n&#x2F;2 + 1) + s&#x2F;2<br>分块查找的效率介于折半查找和顺序查找之间，但更加接近于折半查找。</p><h3 id="🧵特点-1"><a href="#🧵特点-1" class="headerlink" title="🧵特点"></a>🧵特点</h3><p>优点：插入和删除比较容易，无需进行大量的移动。<br>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算。<br>适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找。</p><h2 id="🎮折半查找法"><a href="#🎮折半查找法" class="headerlink" title="🎮折半查找法"></a><strong>🎮折半查找法</strong></h2><h3 id="🧵基本思想-2"><a href="#🧵基本思想-2" class="headerlink" title="🧵基本思想"></a>🧵基本思想</h3><p>要求查找表为<strong>顺序存储结构</strong>并且<strong>有序</strong>，若关键字在表中则返回关键字的位置，若关键字不在表中时停止查找的典型标志是：查找范围的上界&lt;&#x3D;查找范围的下界<br>折半查找的平均查找长度为：ASL &#x3D; log2(n+1) – 1。</p><h2 id="🎮查找对比"><a href="#🎮查找对比" class="headerlink" title="🎮查找对比"></a><strong>🎮查找对比</strong></h2><p><img src="https://i2.100024.xyz/2023/06/19/f4cgkv.webp#id=TCPpa&originHeight=249&originWidth=1099&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎮B树"><a href="#🎮B树" class="headerlink" title="🎮B树"></a><strong>🎮B树</strong></h2><h3 id="🧵基本思想-3"><a href="#🧵基本思想-3" class="headerlink" title="🧵基本思想"></a>🧵基本思想</h3><p>B树，又称多路平衡查找树， <strong>B树中所有结点的孩子个数的最大值称为B树的阶</strong>，通常用m表示。<br>一棵 m 阶 B 树或为空树,或为满足下列特性的m叉树：<br>1.若根结点不是终端节点，则至少有两棵子树，最多有m棵子树。<br>2.除根结点外的所有非叶结点至少有⌈m&#x2F;2⌉棵子树，最多有m棵子树。<br>3.所有的非叶结点都出现在同一层次上，并且不带信息（可视为失败结点）。<br>4.所有非叶结点的结构如下：<br><img src="https://i2.100024.xyz/2023/06/19/f6pkg8.webp#height=26&id=lfyl5&originHeight=51&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=470"><br>a)Pi-1 所指子树中所有结点的关键字均小于Ki<br>b)Pi 所指子树中所有结点的关键字均大于K<br>B 树是所有结点的<strong>平衡因子均等于0</strong> 的多路平衡查找树。(各子树高度差为0，绝对平衡)<br><img src="https://i2.100024.xyz/2023/06/19/f79y6d.webp#height=291&id=Tq42t&originHeight=388&originWidth=765&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574"><br>（终端节点，叶节点——也算是B树的结点）<br>有n个关键字的m阶B树，叶节点有n+1个</p><h3 id="🧵B树的查找"><a href="#🧵B树的查找" class="headerlink" title="🧵B树的查找"></a><strong>🧵B树的查找</strong></h3><p>B树的查找算法如下：</p><ol><li>在B树中找结点（磁盘上进行），当查找到叶结点时，查找失败</li><li>在结点内的多关键字有序表中查找关键字（内存中进行）：<ol><li>先在有序表中进行查找，若找到则查找成功。</li><li>否则，根据找到的指针信息到所指的子树，执行①</li></ol></li></ol><h3 id="🧵B树的插入"><a href="#🧵B树的插入" class="headerlink" title="🧵B树的插入"></a><strong>🧵B树的插入</strong></h3><p>B树的插入过程如下:</p><ol><li>查找：利用B树的查找算法，找出插入该关键字的最底层中某个非叶结点。</li><li>插入：当插入后的结点关键字个数小于 m，则可以直接插入；如果等于 m，则必须对结点进行分裂。</li></ol><p>（从中间位置⌈m&#x2F;2⌉将原节点关键字分为两个部分，中间位置⌈m&#x2F;2⌉的结点插入父节点）</p><h3 id="🧵B树的删除"><a href="#🧵B树的删除" class="headerlink" title="🧵B树的删除"></a><strong>🧵B树的删除</strong></h3><h4 id="🧶待删结点的关键字在终端结点中"><a href="#🧶待删结点的关键字在终端结点中" class="headerlink" title="🧶待删结点的关键字在终端结点中"></a>🧶待删结点的关键字在终端结点中</h4><ol><li>该节点的关键字个数&gt;⌈m&#x2F;2⌉ -1，则直接删除该关键字</li><li>该节点的关键字个数&#x3D;⌈m&#x2F;2⌉ -1，向左右兄弟结点借</li></ol><p><img src="https://i2.100024.xyz/2023/06/19/fgu9cx.webp#height=183&id=RP9gX&originHeight=244&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=633"><br>若左右兄弟结点不够借，合并它和兄弟和父结点<br><img src="https://i2.100024.xyz/2023/06/19/fi3otl.webp#height=202&id=drbFN&originHeight=269&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=607"></p><h4 id="🧶待删结点的关键字不在终端结点中"><a href="#🧶待删结点的关键字不在终端结点中" class="headerlink" title="🧶待删结点的关键字不在终端结点中"></a>🧶待删结点的关键字不在终端结点中</h4><ol><li>如果小于（大于）k 的子树中关键字个数 &gt; ⌈m&#x2F;2⌉ -1，则找出 k 的前驱(后继)值 k’, 并且用 k’来取代 k，再递归地按此方法删除 k’。</li><li>如果前后两个子树中关键字个数均为⌈m&#x2F;2⌉ -1，则将两个子结点合并，直接删除 k。</li></ol><p><img src="https://i2.100024.xyz/2023/06/19/gk9wic.webp#height=188&id=rSyPc&originHeight=251&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627"></p><ol start="3"><li>若该结点关键字个数 &#x3D; ⌈ m&#x2F;2⌉ -1，且与该结点相邻的左（右）兄弟结点的关键字个 数 &#x3D; ⌈ m&#x2F;2⌉ -1，则将该关键字删除后与左（右）兄弟结点及双亲结点中的关键字进行合并， 如下图所示。</li></ol><p><img src="https://i2.100024.xyz/2023/06/19/gks0xq.webp#height=192&id=TFdjS&originHeight=256&originWidth=787&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=590"></p><h2 id="🎮B-树"><a href="#🎮B-树" class="headerlink" title="🎮B+树"></a><strong>🎮B+树</strong></h2><h3 id="🧵基本思想-4"><a href="#🧵基本思想-4" class="headerlink" title="🧵基本思想"></a>🧵基本思想</h3><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。<br>一棵 m 阶的 B+树需满足下列条件:</p><ol><li>每个分支结点最多有 m 棵子树。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有⌈m&#x2F;2⌉ 棵子树。</li><li>结点的子树个数与关键字个数相等。</li><li>所有叶结点包含全部关键字及指向相应记录的指针，而且叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。</li><li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。</li></ol><p><img src="https://i2.100024.xyz/2023/06/19/gn70ck.webp#height=249&id=mtp9b&originHeight=536&originWidth=1057&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=491"></p><ul><li>通常在B+树中有两个头指针，一个是指向根结点，一个是指向关键字最小的叶子结点。</li><li>可以对B+树进行两种查找运算： 一种是从最小关键字开始的顺序查找，一种是从根结点开始，进行多路查找。</li><li>B+树在查找过程中，如果非叶子结点上的关键字值等于给定值时并不终止，而是继续向下查找直到叶结点上的该关键字为止。所以在B+ 树中的查找，无论查找成功与否，每次查找<strong>都是从根结点到叶结点的路径</strong>。</li></ul><h3 id="🧵B树与B-树的区别"><a href="#🧵B树与B-树的区别" class="headerlink" title="🧵B树与B+树的区别"></a>🧵B树与B+树的区别</h3><ol><li>在 B 树中，具有 n 个关键字的结点含有（n+1）棵子树；而在 B+树中，具有 n 个关键字的结点只含有 n 棵子树,即每个关键字对应一棵子树。</li><li>在 B 树中，根结点的关键字个数 n 的范围是 1 &lt;&#x3D; n &lt;&#x3D; m-1，非根结点的范围是⌈ m&#x2F;2⌉-1&lt;&#x3D;n &lt;&#x3D; m-1；而在 B+树中，根结点的关键字个数 n 的范围是 1 &lt;&#x3D; n &lt;&#x3D; m,非根结点的范围是⌈m&#x2F;2⌉ &lt;&#x3D;n &lt;&#x3D; m。</li><li>在 B+树中，所有<strong>非叶结点仅起到索引作用</strong>，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li><li>在 B 树中，<strong>叶结点包含的关键字和其他结点包含的关键字是不重复的</strong>；而在 B+树中，<strong>叶结点包含了全部关键字</strong>，即其他非叶结点中的关键字包含在叶结点中。</li></ol><h3 id="🧵MySQL用B-树做索引"><a href="#🧵MySQL用B-树做索引" class="headerlink" title="🧵MySQL用B+树做索引"></a>🧵MySQL用B+树做索引</h3><p>使用B+树的话，因为它只有叶子节点保存数据，所以<strong>可以将索引节点一次加载到内存当中，而消耗很少的内存量</strong>。<br>同样大小的空间 B+树可以比 B 树，<strong>加载更多的索引节点</strong>。而且 B+树由于其叶子节点存储数据的原因，它的查找每个元素所花费时间的方差也就更低，这样也更稳定可控。</p><h2 id="🎮散列（Hash表）"><a href="#🎮散列（Hash表）" class="headerlink" title="🎮散列（Hash表）"></a><strong>🎮散列（Hash表）</strong></h2><h3 id="🧵介绍"><a href="#🧵介绍" class="headerlink" title="🧵介绍"></a>🧵介绍</h3><p>哈希表（Hash table，也叫散列表）， 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过<strong>把关键码值映射到表中一个位置来访问记录</strong>，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong>。</p><h3 id="🧵特点-2"><a href="#🧵特点-2" class="headerlink" title="🧵特点"></a>🧵特点</h3><p>哈希表最大的优点，就是把<strong>数据的存储和查找消耗的时间大大降低</strong>，几乎可以看成是常数时间；而代价仅仅是<strong>消耗比较多的内存</strong>。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 </p><ul><li><strong>直接定址</strong>和<strong>解决冲突</strong>是哈希表的两大特点</li></ul><h3 id="🧵哈希函数构造方法"><a href="#🧵哈希函数构造方法" class="headerlink" title="🧵哈希函数构造方法"></a>🧵哈希函数构造方法</h3><h4 id="🧶直接定址法"><a href="#🧶直接定址法" class="headerlink" title="🧶直接定址法"></a>🧶直接定址法</h4><p>哈希函数为关键字的线性函数如 H（key）&#x3D; a*key + b</p><h4 id="🧶数字分析法"><a href="#🧶数字分析法" class="headerlink" title="🧶数字分析法"></a>🧶数字分析法</h4><p>当关键字的位数大于地址位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列的地址，适用于所有关键字都已知的情况<br>——假设关键字集合中的每个关键字 key 都是由 s 位数字组成 (k1, k2, k3, … kn)，分析 key 中的全体数据，并从中提取分布均匀的若干位或他们的组合构成全体</p><h4 id="🧶平方取中法"><a href="#🧶平方取中法" class="headerlink" title="🧶平方取中法"></a>🧶平方取中法</h4><p>如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。</p><h4 id="🧶除留余数法"><a href="#🧶除留余数法" class="headerlink" title="🧶除留余数法"></a>🧶除留余数法</h4><p>取关键字对p取余的值作为散列地址，其中p&lt;m，即H（key）&#x3D;key%p（p&lt;m，m为表长）</p><ul><li>p 应为不大于 m 的质数或是不含 20 以下的质因子的合数，这样可以减少地址的重复（冲突）</li></ul><h3 id="🧵处理哈希冲突的方法"><a href="#🧵处理哈希冲突的方法" class="headerlink" title="🧵处理哈希冲突的方法"></a>🧵处理哈希冲突的方法</h3><p>哈希冲突的解决方法包括：<strong>开放定址法</strong>和<strong>拉链法</strong>，当冲突发生时，使用某种探测技术形成一个探测序列，然后沿此序列逐个单单元查找，直到找到该关键字或者碰到一个开放的地址为止，探测到开放的地址表明该表中没有此关键字，若要插入，则探测到开放地址时可将新节点插入该地址单元。<br>其中<strong>开放定址法</strong>包括：线性探查法，二次探查法，双重散列法</p><h4 id="🧶线性探查法"><a href="#🧶线性探查法" class="headerlink" title="🧶线性探查法"></a>🧶线性探查法</h4><p>基本思想：探查时从地址d开始，首先探查T[d],在探查T[d+1]…直到查到T[m1]，此后循环到T[0],T[1]…直到探测到T[d-1]为止。</p><h4 id="🧶二次探查法（平方探测）"><a href="#🧶二次探查法（平方探测）" class="headerlink" title="🧶二次探查法（平方探测）"></a>🧶二次探查法（平方探测）</h4><p>基本思想：探查时从地址d开始，首先探查T[d]，再探T[d+12]，T[d-12]，T[d+22]，T[d-22]…等，直到探查到有空余地址或者探查到T[d-1]为止，缺点是无法探查到整个散列空间。</p><h4 id="🧶双重散列法（随即探测再散列）"><a href="#🧶双重散列法（随即探测再散列）" class="headerlink" title="🧶双重散列法（随即探测再散列）"></a>🧶双重散列法（随即探测再散列）</h4><p>基本思想：使用两个散列函数来确定地址，探查时从地址d开始，首先探查T[d]，再探查T[d+h1(d)]，T[d+2*h1(d)]…<br><strong>链接法</strong><br>将所有关键字为同义词的节点链接在同一个单链表中，若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组，凡是散列地址为i的节点均插入到头指针为i的单链表中。<br><img src="https://i2.100024.xyz/2023/06/19/h4wqqy.webp#height=385&id=KDGuF&originHeight=512&originWidth=358&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=269"></p><h2 id="🎮查找算法的分析及应用"><a href="#🎮查找算法的分析及应用" class="headerlink" title="🎮查找算法的分析及应用"></a><strong>🎮查找算法的分析及应用</strong></h2><h3 id="🧵内部查找"><a href="#🧵内部查找" class="headerlink" title="🧵内部查找"></a>🧵内部查找</h3><ul><li>顺序查找，时间复杂度 O(N)</li><li>分块查找，时间复杂度 O(logN+N&#x2F;m)</li><li>折半查找，时间复杂度 O(logN)</li><li>哈希查找，时间复杂度 O(1)</li></ul><h3 id="🧵外部查找"><a href="#🧵外部查找" class="headerlink" title="🧵外部查找"></a>🧵外部查找</h3><ul><li>B树</li><li>B+树</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课程总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——C++标注模板库（STL）介绍——vector、set、string、map</title>
      <link href="/2023/06/12/%E7%AC%AC%E5%85%AD%E7%AB%A0%20C++%E6%A0%87%E6%B3%A8%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94vector%E3%80%81set%E3%80%81string%E3%80%81map/"/>
      <url>/2023/06/12/%E7%AC%AC%E5%85%AD%E7%AB%A0%20C++%E6%A0%87%E6%B3%A8%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94vector%E3%80%81set%E3%80%81string%E3%80%81map/</url>
      
        <content type="html"><![CDATA[<h1 id="🍳vector的常见用法详解"><a href="#🍳vector的常见用法详解" class="headerlink" title="🍳vector的常见用法详解"></a>🍳vector的常见用法详解</h1><blockquote><p>头文件#include<vector><br>using namespace std;</p></blockquote><h2 id="🥞vector的定义"><a href="#🥞vector的定义" class="headerlink" title="🥞vector的定义"></a>🥞vector的定义</h2><p>单独定义一个vector：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">vector&lt;typename&gt; name;<span class="comment">//相当于定义一个一维数组name[SIZE]</span></span><br></pre></td></tr></table></figure><ul><li>如果typename也是一STL容器，定义的时候要记得在&gt; &gt;之间加上空格</li></ul><p>例子：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; name;</span><br><span class="line">vector&lt;double&gt; name;</span><br><span class="line">vector&lt;char&gt; name;</span><br><span class="line">vector&lt;node&gt; name;<span class="comment">//node是结构体的类型</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; name;</span><br></pre></td></tr></table></figure><p>定义vector数组的方法：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">vector&lt;typename&gt; Arrayname[arraySize];</span><br></pre></td></tr></table></figure><ul><li>与vector&lt;vector<int> &gt; name;的区别——vector<typename> Arrayname[arraySize]为一维长度已经固定为arraySize，而另一维是变长的</li></ul><h2 id="🥞vector容器内元素的访问"><a href="#🥞vector容器内元素的访问" class="headerlink" title="🥞vector容器内元素的访问"></a>🥞vector容器内元素的访问</h2><h3 id="🍞通过下标访问"><a href="#🍞通过下标访问" class="headerlink" title="🍞通过下标访问"></a>🍞通过下标访问</h3><p>定义为vector<typename> vi的vector容器来说，可以直接通过vi[index]来访问，index的范围0~vi.size()-1</p><h3 id="🍞通过迭代器访问"><a href="#🍞通过迭代器访问" class="headerlink" title="🍞通过迭代器访问"></a>🍞通过迭代器访问</h3><p>迭代器(iterator)可以理解为一种类似指针的东西，定义为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt;::iteratoe it;</span><br></pre></td></tr></table></figure><p>可以通过*it来访问vector里的元素<br>例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(it+i));<span class="comment">//输出vi[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vi[i]和*(vi.begin()+i)是等价的</p><ul><li><p>begin()函数的作用是取vi的首元素地址</p></li><li><p>end()函数的作用是取vi的尾元素地址的下一地址——迭代器末尾标志，不存储任何元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=vi.<span class="built_in">begin</span>();it!=vi.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector迭代器不支持it&lt;vi.end()写法，循环条件只能用it!=vi.end()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在常用STL容器中，只有在vector和string中，才允许使用vi.begin()+3这种迭代器加上整数的写法</strong></p></li></ul><h2 id="🥞vector常用函数示例解析"><a href="#🥞vector常用函数示例解析" class="headerlink" title="🥞vector常用函数示例解析"></a>🥞vector常用函数示例解析</h2><h3 id="🍞push-back"><a href="#🍞push-back" class="headerlink" title="🍞push_back()"></a>🍞push_back()</h3><p>push_back(n)就是在vector后面添加一个元素x，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);<span class="comment">//将0 1 2 3分别插入a末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍞pop-back"><a href="#🍞pop-back" class="headerlink" title="🍞pop_back()"></a>🍞pop_back()</h3><p>pop_back()为删除vector的尾元素，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);<span class="comment">//将0 1 2 3分别插入a末尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删去尾部元素——3</span></span><br></pre></td></tr></table></figure><h3 id="🍞size"><a href="#🍞size" class="headerlink" title="🍞size()"></a>🍞size()</h3><p>size()用来获得vector中元素的个数，时间复杂度为O(1)。size()返回的是unsigned类型，但%d也没问题</p><h3 id="🍞clear"><a href="#🍞clear" class="headerlink" title="🍞clear()"></a>🍞clear()</h3><p>clear()用来清空vector中的所有元素，时间复杂度为O(N)，其中N表示vector中元素的个数</p><h3 id="🍞insert-it，x"><a href="#🍞insert-it，x" class="headerlink" title="🍞insert(it，x)"></a>🍞insert(it，x)</h3><p>insert(it，x)用来向vector的任意迭代器it处插入一个元素x，时间复杂度为O(N)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);<span class="comment">//将0 1 2 3分别插入a末尾</span></span><br><span class="line">&#125;</span><br><span class="line">vi.<span class="built_in">insert</span>(vi.<span class="built_in">begin</span>()+<span class="number">2</span>,<span class="number">-1</span>);<span class="comment">//把-1插入到vi[2]的位置</span></span><br><span class="line"><span class="comment">//0 1 -1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="🍞erase"><a href="#🍞erase" class="headerlink" title="🍞erase()"></a>🍞erase()</h3><p>erase()有两种用法：删除单个元素、删除一个区间内的所有元素。时间复杂度均为O(N)</p><ol><li><strong>删除单个元素</strong></li></ol><p>erase(it)就是删除迭代器it处的元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>()+<span class="number">2</span>);<span class="comment">//删除vi[2]处的元素</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>删除一个区间内的所有元素</strong></li></ol><p>erase(first,last)就是删除[first,last)内的所有元素——要注意左闭右开</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">begin</span>()+<span class="number">3</span>);<span class="comment">//删除vi[0] vi[1] vi[2]处的元素</span></span><br></pre></td></tr></table></figure><h2 id="🥞vector的常见用途"><a href="#🥞vector的常见用途" class="headerlink" title="🥞vector的常见用途"></a>🥞vector的常见用途</h2><h3 id="🍞存储数据"><a href="#🍞存储数据" class="headerlink" title="🍞存储数据"></a>🍞存储数据</h3><h3 id="🍞用邻接表存储图"><a href="#🍞用邻接表存储图" class="headerlink" title="🍞用邻接表存储图"></a>🍞用邻接表存储图</h3><h1 id="🍳set的常见用法详解"><a href="#🍳set的常见用法详解" class="headerlink" title="🍳set的常见用法详解"></a>🍳set的常见用法详解</h1><p>set——集合，<strong>内部自动有序</strong>且<strong>不含重复元素</strong>的容器</p><blockquote><p>头文件#include<set><br>using namespace std;</p></blockquote><h2 id="🥞set的定义"><a href="#🥞set的定义" class="headerlink" title="🥞set的定义"></a>🥞set的定义</h2><p>单独定义一个set</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><ul><li>其定义写法和vector基本类似，且typename为STL容器所需要注意的点也相同</li></ul><h2 id="🥞set容器内元素的访问"><a href="#🥞set容器内元素的访问" class="headerlink" title="🥞set容器内元素的访问"></a>🥞set容器内元素的访问</h2><p>set只能通过迭代器（iterator）访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//可以通过*it来访问set里的元素</span></span><br></pre></td></tr></table></figure><ul><li><em><em>除vevtor和string之外的STL容器都不支持</em>(it+i)的访问方式</em>*<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>set内的元素自动递增排序，且自动去除了重复元素</li></ul><h2 id="🥞set常用函数示例解析"><a href="#🥞set常用函数示例解析" class="headerlink" title="🥞set常用函数示例解析"></a>🥞set常用函数示例解析</h2><h3 id="🍞insert"><a href="#🍞insert" class="headerlink" title="🍞insert()"></a>🍞insert()</h3><p>insert(x)可将x插入set容器中，并自动递增排序和去重，时间复杂度O(logN)，其中N为set内的元素个数</p><h3 id="🍞find"><a href="#🍞find" class="headerlink" title="🍞find()"></a>🍞find()</h3><p>find(value)返回set中对应值为value的迭代器，时间复杂度为O(logN)，N为set内的元素个数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">find</span>(<span class="number">2</span>);<span class="comment">//在set中查找2，返回其迭代器</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*it);</span><br><span class="line"><span class="comment">//也可以直接写成printf(&quot;%d\n&quot;,*(st.find(2)));</span></span><br></pre></td></tr></table></figure><h3 id="🍞erase-1"><a href="#🍞erase-1" class="headerlink" title="🍞erase()"></a>🍞erase()</h3><p>erase()有两种用法：删除单个元素、删除一个区间内的所有元素。</p><ol><li><strong>删除单个元素</strong><ol><li><p>erase(it)就是删除迭代器it处的元素。时间复杂度均为O(1)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(<span class="number">200</span>));<span class="comment">//删除set中的元素200</span></span><br></pre></td></tr></table></figure></li><li><p>st.erase(value)，value为所需要删除元素的值。时间复杂度均为O(logN)</p></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">erase</span>(<span class="number">100</span>);<span class="comment">//只会删除值为100的元素</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>删除一个区间内的所有元素</strong></li></ol><p>erase(first,last)就是删除[first,last)内的所有元素——要注意左闭右开。时间复杂度均为O(last-first)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sst&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line">st.<span class="built_in">erase</span>(it,st.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="🍞size-1"><a href="#🍞size-1" class="headerlink" title="🍞size()"></a>🍞size()</h3><p>size()用来获得set内元素的个数，时间复杂度为O(1)</p><h3 id="🍞clear-1"><a href="#🍞clear-1" class="headerlink" title="🍞clear()"></a>🍞clear()</h3><p>clear()用来清空set中的所有元素，复杂度为O(N)，其中N为set内元素的个数</p><h2 id="🥞set的常用用途"><a href="#🥞set的常用用途" class="headerlink" title="🥞set的常用用途"></a>🥞set的常用用途</h2><p>set的最主要作用是自动去重并按升序排序，因此遇到需要去重但是不方便直接开数组的情况，可以使用set尝试</p><h1 id="🍳string的常见用法详解"><a href="#🍳string的常见用法详解" class="headerlink" title="🍳string的常见用法详解"></a>🍳string的常见用法详解</h1><blockquote><p>头文件#include<string><br>using namespace std;</p></blockquote><h2 id="🥞string的定义"><a href="#🥞string的定义" class="headerlink" title="🥞string的定义"></a>🥞string的定义</h2><p>定义string的方式跟基本数据类型相同，只需要在string后跟上变量名即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str=<span class="string">&quot;abcd&quot;</span>;<span class="comment">//可以直接给string类型的变量赋值</span></span><br></pre></td></tr></table></figure><h2 id="🥞string中内容的访问"><a href="#🥞string中内容的访问" class="headerlink" title="🥞string中内容的访问"></a>🥞string中内容的访问</h2><h3 id="🍞通过下标访问-1"><a href="#🍞通过下标访问-1" class="headerlink" title="🍞通过下标访问"></a>🍞通过下标访问</h3><p>一般来说，可以直接像字符数组一样去访问string</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br></pre></td></tr></table></figure><p>如果要读入和输出整个字符串，只能用cin和cout</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);<span class="comment">//读取一行的字符串</span></span><br></pre></td></tr></table></figure><h3 id="🍞通过迭代器访问-1"><a href="#🍞通过迭代器访问-1" class="headerlink" title="🍞通过迭代器访问"></a>🍞通过迭代器访问</h3><p>string不像其他STL容器那样需要参数，可以直接如下定义：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string::iterator it;<span class="comment">//可以通过*it来访问string里的每一位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(string::iterator it=str.<span class="built_in">begin</span>();it!=str.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>string和vector一样，支持直接对迭代器进行加减某个数字，如str.begin()+2</li></ul><h2 id="🥞string常用函数实例解析"><a href="#🥞string常用函数实例解析" class="headerlink" title="🥞string常用函数实例解析"></a>🥞string常用函数实例解析</h2><h3 id="🍞operator-x3D"><a href="#🍞operator-x3D" class="headerlink" title="🍞operator+&#x3D;"></a>🍞operator+&#x3D;</h3><p>这是string的加法，可以将两个string直接拼接起来</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str1=<span class="string">&quot;abc&quot;</span>,str2=<span class="string">&quot;xyz&quot;</span>,str3;</span><br><span class="line">str3 = str1 + str2;<span class="comment">//将str1和str2拼接，赋值给str3</span></span><br><span class="line">str1 += str2;<span class="comment">//将str2直接拼接到str1上</span></span><br></pre></td></tr></table></figure><h3 id="🍞compare-operator"><a href="#🍞compare-operator" class="headerlink" title="🍞compare operator"></a>🍞compare operator</h3><p>两个string类型可以直接用&#x3D;&#x3D;,!&#x3D;,&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;比较大小，比较规则是字典序</p><h3 id="🍞length-x2F-size"><a href="#🍞length-x2F-size" class="headerlink" title="🍞length()&#x2F;size()"></a>🍞length()&#x2F;size()</h3><p>length()返回string的长度，即存放的字符数，时间复杂度为O(1)。size()与length()基本相同</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcdhs&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,str.<span class="built_in">length</span>(),str.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><h3 id="🍞insert-1"><a href="#🍞insert-1" class="headerlink" title="🍞insert()"></a>🍞insert()</h3><ol><li><p>insert(pos,string)，在pos号位置插入字符串string</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcxyz&quot;</span>,str2 = <span class="string">&quot;opq&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">3</span>,str2);<span class="comment">//往str[3]处插入opq，这里的str2直接写成opq也可以</span></span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;<span class="comment">//abcopqxyz</span></span><br></pre></td></tr></table></figure></li><li><p>insert(it,it2,it3)，it为原字符串的欲插入位置，it2和it3为待插入字符串的首位迭代器，用来表示串[it2,it3)将被插在it的位置上</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcxyz&quot;</span>,str2 = <span class="string">&quot;opq&quot;</span>;</span><br><span class="line"><span class="comment">//在str的3号位(c和x之间)插入str2</span></span><br><span class="line">str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str2.<span class="built_in">begin</span>(),str2.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;<span class="comment">//abcopqxyz</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="🍞erase-2"><a href="#🍞erase-2" class="headerlink" title="🍞erase()"></a>🍞erase()</h3><ol><li>删除单个元素</li></ol><p>str.erase(it)用于删除单个元素，it为需要删除的元素的迭代器</p><ol start="2"><li>删除一个区间内的所有元素</li></ol><p>str.erase(first,last)<br>str.erase(pos,length),其中pos为需要开始删除的起始位置，length为删除的字符个数</p><h3 id="🍞clear-2"><a href="#🍞clear-2" class="headerlink" title="🍞clear()"></a>🍞clear()</h3><p>clear()用以清空string中的数据，时间复杂度一般为O(1)</p><h3 id="🍞substr"><a href="#🍞substr" class="headerlink" title="🍞substr()"></a>🍞substr()</h3><p>substr(pos,len)返回从pos号开始，长度为len的字串，时间复杂度为O(len)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;thank you for your smile&quot;</span>;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//thank</span></span><br></pre></td></tr></table></figure><h3 id="🍞string-npos"><a href="#🍞string-npos" class="headerlink" title="🍞string::npos"></a>🍞string::npos</h3><p>string::npos是一个常数，其本身的值为-1，但由于是unsigned_int类型，因此实际上也可以认为是unsigned——int类型的最大值。string::npos用以作为find函数失配时的返回值</p><h3 id="🍞find-1"><a href="#🍞find-1" class="headerlink" title="🍞find()"></a>🍞find()</h3><ol><li>**str.find(str2)**，当str2是str的子串时，返回其在str中第一次出现的位置；如果str2不是str的子串，则返回string::npos</li><li>**str.find(str2,pos)**，从str的pos号位开始匹配str2，返回值与上相同</li></ol><p>时间复杂度为O(mn)，mn分别为str和str2的函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.<span class="built_in">find</span>(str2)!=string::npos)&#123;</span><br><span class="line">    cout&lt;&lt;str.<span class="built_in">find</span>(str2)&lt;&lt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍞replace"><a href="#🍞replace" class="headerlink" title="🍞replace()"></a>🍞replace()</h3><ol><li>**str.replace(pos,len,str2)**把str从pos号位开始、长度为len的子串替换为str2</li><li>**str.replace(it1,it2,str2)**把str的迭代器[it1,str2)范围的子串替换为str2</li></ol><p>时间复杂度为O(str.length())</p><h1 id="🍳map的常见用法详解"><a href="#🍳map的常见用法详解" class="headerlink" title="🍳map的常见用法详解"></a>🍳map的常见用法详解</h1><p>map为映射——map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）</p><blockquote><p>头文件#include<map><br>using namespace std;</p></blockquote><h2 id="🥞map的定义"><a href="#🥞map的定义" class="headerlink" title="🥞map的定义"></a>🥞map的定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;mp;</span><br></pre></td></tr></table></figure><p>map需要确定映射前（key键）类型和映射后（value值）类型，所以需要在&lt;&gt;内填写两个类型，其中一个是键的类型，第二个是值的类型</p><ul><li>如果是字符串到整型的映射，必须<strong>使用string而不能用char数组</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;,string&gt; mp;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🥞map容器内元素的访问"><a href="#🥞map容器内元素的访问" class="headerlink" title="🥞map容器内元素的访问"></a>🥞map容器内元素的访问</h2><h3 id="🍞通过下标访问-2"><a href="#🍞通过下标访问-2" class="headerlink" title="🍞通过下标访问"></a>🍞通过下标访问</h3><p>和访问普通数组一样，对一个定义为map&lt;char,int&gt;mp的map来说，可以直接使用mp[‘c’]的方式来访问它对应的整数——mp[‘c’]&#x3D;20</p><ul><li>map中的键是唯一的mp[‘c’]&#x3D;20;mp[‘c’]&#x3D;30;&#x2F;&#x2F;20会被覆盖</li></ul><h3 id="🍞通过迭代器访问-2"><a href="#🍞通过迭代器访问-2" class="headerlink" title="🍞通过迭代器访问"></a>🍞通过迭代器访问</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map会以键从小到大的顺序自动排序</strong></p><h2 id="🥞map常用函数实例解析"><a href="#🥞map常用函数实例解析" class="headerlink" title="🥞map常用函数实例解析"></a>🥞map常用函数实例解析</h2><h3 id="🍞find-2"><a href="#🍞find-2" class="headerlink" title="🍞find()"></a>🍞find()</h3><p>find(key)返回键为key的映射的迭代器，时间复杂度为O(logN),N为map中映射的个数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>]=<span class="number">2</span>;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">//it-&gt;first=b it-&gt;second=2</span></span><br></pre></td></tr></table></figure><h3 id="🍞erase-3"><a href="#🍞erase-3" class="headerlink" title="🍞erase()"></a>🍞erase()</h3><ol><li>删除单个元素</li></ol><p>**mp.erase(it)**，it为需要删除的元素的迭代器。时间复杂度为O(1)<br>**mp.erase(key)**，key为欲删除的映射的键。时间复杂度为O(logN)，N为map内元素的个数</p><ol start="2"><li>删除一个区间内的所有元素</li></ol><p>mp.erase(first,last)</p><h3 id="🍞size-2"><a href="#🍞size-2" class="headerlink" title="🍞size()"></a>🍞size()</h3><p>size()用来获得map中映射的对数，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//mp.size()——2</span></span><br></pre></td></tr></table></figure><h3 id="🍞clear-3"><a href="#🍞clear-3" class="headerlink" title="🍞clear()"></a>🍞clear()</h3><p>clear()用来清空map中的所有元素，复杂度为O(N)，其中N为map中元素的个数</p><h2 id="🥞map的常见用途"><a href="#🥞map的常见用途" class="headerlink" title="🥞map的常见用途"></a>🥞map的常见用途</h2><ol><li>需要建立字符与整数之间映射</li><li>字符串和字符串之间的映射</li></ol><p>——map中键和值是唯一的，一个键对应多个值multimap</p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——绪论</title>
      <link href="/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/"/>
      <url>/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="🍍定义"><a href="#🍍定义" class="headerlink" title="🍍定义"></a>🍍定义</h1><p>将若干台具有<strong>独立</strong>功能的计算机系统，用某种或多种通信介质连接起来，通过完善的网络协议，在<strong>数据交换</strong>的基础上，实现网络<strong>资源共享</strong>的系统称为计算机网络。</p><h1 id="🍍分类"><a href="#🍍分类" class="headerlink" title="🍍分类"></a>🍍分类</h1><h2 id="🍅按地理范围分类"><a href="#🍅按地理范围分类" class="headerlink" title="🍅按地理范围分类"></a>🍅按地理范围分类</h2><ol><li><strong>局域网LAN(Local Area Network)</strong></li></ol><p>其覆盖范围一般不超过数公里。通常安装在一幢大楼内，大学校园内或厂区内</p><ol start="2"><li><strong>城域网MAN (Metropolitan Area Network)</strong></li></ol><p>覆盖范围通常是一个大城市，大约数十公里到上百公里</p><ol start="3"><li><strong>广域网WAN (Wide Area Network)</strong></li></ol><p>覆盖范围一般在数百公里以上，Internet就是目前最大的广域网<br><img src="https://s2.loli.net/2023/06/11/nPSeb8gyr5fHOTp.png#height=326&id=e5hsF&originHeight=652&originWidth=1400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=700"></p><h2 id="🍅按拓扑结构分类"><a href="#🍅按拓扑结构分类" class="headerlink" title="🍅按拓扑结构分类"></a>🍅按拓扑结构分类</h2><p>计算机网络拓扑是指通信子网节点间连接结构的拓扑形式，通过结点与线段间的几何关系表示网络结构，反映网络中各实体的结构关系。</p><ol><li><strong>星型网</strong></li></ol><p>转输介质从一个中央结点向外辐射连接其他节点。<br>任何两个结点之间的信息交换必须经过中央结点转发。<br>中央结点的可靠性十分重要，一旦中央结点发生故障，会引起整个网络瘫痪。</p><ol start="2"><li><strong>环形网</strong></li></ol><p>网络上所有的结点通过传输介质连接成一个闭环，任何两个结点的数据交换必须沿环进行<br>可靠性：一旦结点或链路发生故障，则环路断开，导致网络瘫痪 </p><ol start="3"><li><strong>总线网络</strong></li></ol><p>一条总线连接所有的结点，任何一个结点发送数据，其他节点都能收到。<br>特点：共享信道<br>可靠性：任何结点故障都不会影响整个网络正常运行。</p><ol start="4"><li><strong>不规则型网</strong></li></ol><p>每个结点至少要和其他两个结点连接<br>可靠性好：任何一个结点或一条链路发生故障都不会影响网络的连通性<br>布线灵活，几乎不受任何拓扑结构的约束。 </p><h2 id="🍅小结"><a href="#🍅小结" class="headerlink" title="🍅小结"></a>🍅小结</h2><p>局域网——总线型，星型，环型<br>广域网——不规则型<br>点—点通信：独占信道——星型、不规则型<br>多点通信：共享信道——总线型、环型</p><h1 id="🍍计算机网络运行过程"><a href="#🍍计算机网络运行过程" class="headerlink" title="🍍计算机网络运行过程"></a>🍍计算机网络运行过程</h1><p>在计算机网络运行过程中，<strong>网络边缘的主机系统</strong>和<strong>网络核心的路由器</strong>各自发挥着完全不同的作用。<br>两个计算机系统进行通信实际上是指两个分别位于不同计算机系统中的程序之间进行通信。<br>在网络边缘的端系统（End System）中运行的程序之间的通信方式通常可划分为两大类：</p><ul><li>客户服务器方式：通常称为C&#x2F;S方式</li><li>对等方式：通常称为P2P模式</li></ul><h2 id="网络边缘的主机系统"><a href="#网络边缘的主机系统" class="headerlink" title="网络边缘的主机系统"></a>网络边缘的主机系统</h2><h2 id="🍅Client-x2F-Server方式"><a href="#🍅Client-x2F-Server方式" class="headerlink" title="🍅Client&#x2F;Server方式"></a>🍅Client&#x2F;Server方式</h2><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。<br>客户服务器方式所描述的是进程之间服务和被服务的关系。<br>客户是服务的请求方，服务器是服务的提供方。</p><h3 id="🍏客户软件的特点"><a href="#🍏客户软件的特点" class="headerlink" title="🍏客户软件的特点"></a>🍏客户软件的特点</h3><p>被用户调用后运行，在打算通信时主动向远地服务器发起通信（服务请求）。因此，<strong>客户程序必须知道服务器程序的地址</strong>。<br>不需要特殊的硬件和很复杂的操作系统。 </p><h3 id="🍏服务器软件的特点"><a href="#🍏服务器软件的特点" class="headerlink" title="🍏服务器软件的特点"></a>🍏服务器软件的特点</h3><p>一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。<br>系统启动后即自动调用并一直不断地运行着，<strong>被动地等待并接受来自各地的客户的通信请求</strong>。因此，服务器程序不需要知道客户程序的地址。<br>一般需要强大的硬件和高级的操作系统支持。</p><h2 id="🍅对等连接方式P2P"><a href="#🍅对等连接方式P2P" class="headerlink" title="🍅对等连接方式P2P"></a>🍅对等连接方式P2P</h2><p>对等连接(peer-to-peer，简写为P2P)是指两个主机在通信时<strong>并不区分哪一个是服务请求方还是服务提供方</strong>。<br>只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。<br>双方都可以下载对方已经存储在硬盘中的共享文档。</p><h2 id="网络核心中的路由器"><a href="#网络核心中的路由器" class="headerlink" title="网络核心中的路由器"></a>网络核心中的路由器</h2><p>网络核心是计算机网络（特别是因特网）中最复杂的部分。<br>网络核心要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够与其他主机通信。<br><strong>路由器(Router)<strong>是网络核心中最主要的设备，其主要功能是</strong>数据交换</strong>，即接收来自源主机系统的数据，并向目的主机系统转发。<br>在计算机网络中，路由器转发的数据称为<strong>数据分组</strong>（Packet Switching）。</p><h2 id="🍅电路交换"><a href="#🍅电路交换" class="headerlink" title="🍅电路交换"></a>🍅电路交换</h2><p><strong>“交换”(switching)<strong>的含义就是转接——把一条电话线转接到另一条电话线，使它们连通起来。<br>从通信资源的分配角度来看，</strong>“交换”就是按照某种方式动态地分配传输线路的资源</strong>。 </p><h3 id="🍏电路交换的特点"><a href="#🍏电路交换的特点" class="headerlink" title="🍏电路交换的特点"></a>🍏电路交换的特点</h3><p>电路交换必定是面向连接的。<br>电路交换的三个阶段：</p><ol><li>建立连接</li><li>通信</li><li>释放连接</li></ol><p>特征：信道资源独占<br>特点：</p><ol><li>通信线路的利用率很低</li><li>实时性好</li></ol><h2 id="🍅分组交换"><a href="#🍅分组交换" class="headerlink" title="🍅分组交换"></a>🍅分组交换</h2><p>在发送端，先<strong>把较长的报文划分成较短的、固定长度的数据段</strong>。 </p><ol><li>每一个数据段前面（左边）添加上首部构成分组。</li><li>分组交换网以“分组”作为数据传输单元。依次把各分组发送到接收端。</li><li>接收端收到分组后剥去首部还原成报文。</li><li>最后，在接收端把收到的数据恢复成为原来的报文。这里我们假定分组在传输过程中没有出现差错，在转发时也没有被丢弃。</li></ol><h3 id="🍏分组首部的重要性"><a href="#🍏分组首部的重要性" class="headerlink" title="🍏分组首部的重要性"></a>🍏分组首部的重要性</h3><p>每一个分组的首部都含有<strong>地址</strong>等控制信息。<br>分组交换网中的结点交换机根据收到的分组的首部中的<strong>地址信息</strong>，把分组<strong>转发</strong>到下一个结点交换机。<br>用这样的<strong>存储转发</strong>方式，最后分组就能到达<strong>最终目的地</strong>。</p><h3 id="🍏主机和路由器的作用"><a href="#🍏主机和路由器的作用" class="headerlink" title="🍏主机和路由器的作用"></a>🍏主机和路由器的作用</h3><p>主机是<strong>为用户进行信息处理</strong>的，并向网络发送分组，从网络接收分组。<br>路由器对分组进行<strong>存储转发</strong>，最后把分组交付目的主机。<br>在路由器中的输入和输出端口之间没有直接连线。<br>路由器处理分组的过程是：</p><ol><li>把收到的分组先放入<strong>缓存（暂时存储）</strong>；</li><li>查找<strong>路由表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的<strong>端口</strong>转发出去。</li></ol><h3 id="🍏分组交换的优点"><a href="#🍏分组交换的优点" class="headerlink" title="🍏分组交换的优点"></a>🍏分组交换的优点</h3><ul><li>高效——动态分配传输带宽，对通信链路是<strong>逐段占用</strong>。 </li><li>灵活——以分组为传送单位和查找路由。</li><li>迅速——<strong>不必先建立连接</strong>就能向其他主机发送分组。</li><li>可靠——保证<strong>可靠性的网络协议</strong>；分布式的路由选择协议使网络有很好的生存性。</li></ul><h3 id="🍏分组交换的优点-1"><a href="#🍏分组交换的优点-1" class="headerlink" title="🍏分组交换的优点"></a>🍏分组交换的优点</h3><p>分组在各结点存储转发<strong>时需要排队</strong>，这就会造成一定的<strong>时延</strong>。<br>分组<strong>必须携带的首部</strong>（里面有必不可少的控制信息）也造成了一定的<strong>开销</strong>。 </p><h2 id="🍅三种交换的比较"><a href="#🍅三种交换的比较" class="headerlink" title="🍅三种交换的比较"></a>🍅三种交换的比较</h2><p><img src="https://s2.loli.net/2023/06/11/wWpLSas9Nc1ndox.png#height=764&id=J3Qex&originHeight=1018&originWidth=1478&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1109"></p><h2 id="🍅计算机网络的性能指标"><a href="#🍅计算机网络的性能指标" class="headerlink" title="🍅计算机网络的性能指标"></a>🍅计算机网络的性能指标</h2><h3 id="🍏速率"><a href="#🍏速率" class="headerlink" title="🍏速率"></a>🍏速率</h3><p><strong>比特（bit）</strong>是计算机中数据量的单位，也是信息论中使用的信息量的单位。<br>Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。<br>速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b&#x2F;s，或kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s 等<br>速率往往是指额定速率或标称速率。  </p><h3 id="🍏带宽"><a href="#🍏带宽" class="headerlink" title="🍏带宽"></a>🍏带宽</h3><p><strong>“带宽”(bandwidth)<strong>本来是指信号具有的</strong>频带宽度</strong>，单位是赫（或千赫、兆赫、吉赫等）。<br>现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b&#x2F;s (bit&#x2F;s)。    </p><ul><li>在时间轴上信号的宽度随带宽的增大而变窄。</li></ul><h3 id="🍏吞吐量"><a href="#🍏吞吐量" class="headerlink" title="🍏吞吐量"></a>🍏吞吐量</h3><p>吞吐量(throughput)表示在单位时间内<strong>通过某个网络（或信道、接口）的数据量</strong>。<br>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或网络的额定速率的限制。  </p><h3 id="🍏时延-delay-或-latency"><a href="#🍏时延-delay-或-latency" class="headerlink" title="🍏时延(delay 或 latency)"></a>🍏时延(delay 或 latency)</h3><ul><li><strong>传输时延</strong>（发送时延 ）是发送数据时，<strong>数据块从结点进入到传输介质所需要的时间</strong>。</li></ul><p>也就是从发送数据块的第一个比特算起，到该块的最后一个比特发送完毕所需的时间。<br><img src="https://s2.loli.net/2023/06/11/oVB239ji1KfnbtX.png#height=54&id=JjuYm&originHeight=214&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=217"></p><ul><li><strong>传播时延</strong>是电磁波<strong>在信道中需要传播一定的距离而花费的时间</strong>。</li></ul><p>信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。<br><img src="https://s2.loli.net/2023/06/11/TmtXGDbKMyxQLis.png#height=53&id=ymi3E&originHeight=214&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=284"></p><ul><li><strong>处理时延</strong>是<strong>交换结点为存储转发而进行一些必要的处理所花费的时间</strong>。 </li><li><strong>排队时延</strong>是<strong>结点缓存队列中分组排队所经历的时延</strong>。</li></ul><p>排队时延的长短往往取决于网络中当时通信量。</p><ul><li>数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和<br>:::success<br>总时延 &#x3D; 发送时延+传播时延+处理时延+排队时延<br>:::<br><img src="https://s2.loli.net/2023/06/11/4cg9YebKNETJlRv.png#height=328&id=BN8Cz&originHeight=655&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=727"><blockquote><p>对于高速网络链路，我们提高的仅仅是<strong>数据的发送速率</strong>而不是比特在链路上的传播速率。<br>提高链路<strong>带宽</strong>减小了数据<strong>的发送时延</strong>。</p></blockquote></li></ul><h3 id="🍏利用率"><a href="#🍏利用率" class="headerlink" title="🍏利用率"></a>🍏利用率</h3><p><strong>信道利用率</strong>指出某信道有百分之几的时间是被利用的（<strong>有数据通过</strong>）。完全空闲的信道的利用率是零。<br><strong>网络利用率</strong>则是全网络的信道利用率的加权平均值。<br>信道利用率并非越高越好。 </p><ul><li><strong>时延与信道利用率的关系</strong></li></ul><p>根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。<br>若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0之间的关系：<br>$𝐷&#x3D;𝐷_0&#x2F;(1−𝑈)$<br>U 是信道利用率，数值在 0 到 1 之间。 </p><h1 id="🍍因特网概述"><a href="#🍍因特网概述" class="headerlink" title="🍍因特网概述"></a>🍍因特网概述</h1><p>**网络(network)<strong>由若干</strong>结点(node)<strong>和连接这些结点的</strong>链路(link)<strong>组成。<br>互联网是“网络的网络”(network of networks)。<br>连接在因特网上的计算机都称为</strong>主机(host)**。<br>网络把许多计算机连接在一起。因特网则把许多网络连接在一起。 </p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——图</title>
      <link href="/2023/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/"/>
      <url>/2023/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="🎰图"><a href="#🎰图" class="headerlink" title="🎰图"></a>🎰图</h1><p><img src="https://s2.loli.net/2023/06/11/A7t5d6ZGMoFf9Qi.png#height=744&id=zaYeT&originHeight=992&originWidth=1503&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1127"></p><h2 id="🎮图的基本概念"><a href="#🎮图的基本概念" class="headerlink" title="🎮图的基本概念"></a>🎮图的基本概念</h2><h3 id="🧵有向-x2F-无向图"><a href="#🧵有向-x2F-无向图" class="headerlink" title="🧵有向&#x2F;无向图"></a>🧵有向&#x2F;无向图</h3><p>最基本的图通常被定义为“无向图”，与之对应的则被称为“有向图”</p><ul><li>区别：有向图的边是有方向性的</li></ul><h3 id="🧵连通图-x2F-连通分量"><a href="#🧵连通图-x2F-连通分量" class="headerlink" title="🧵连通图&#x2F;连通分量"></a>🧵连通图&#x2F;连通分量</h3><p>在图G中，<strong>任意2个顶点</strong>之间都存在路径，那么称图G为连通图<br>把一个图的最大连通子图称为它的连通分量，连通分量的特点如下：</p><ol><li>是子图</li><li>子图是连通的</li><li>子图含有最大顶点数</li></ol><p>——最大连通子图，不能包含更多顶点和边的子图，无法再扩展<br>对于连通图来说，它的最大连通子图就是其本身，连通分量也是其本身</p><h3 id="🧵有向图-x2F-无向图的度数"><a href="#🧵有向图-x2F-无向图的度数" class="headerlink" title="🧵有向图&#x2F;无向图的度数"></a>🧵有向图&#x2F;无向图的度数</h3><ul><li>无向图</li></ul><p>每个顶点的度数就是它连续边的度数</p><ul><li>无向图</li></ul><p>入度——有向图的某个顶点作为终点的次数<br>出度——有向图的某个顶点作为起点的次数</p><h3 id="🧵完全图"><a href="#🧵完全图" class="headerlink" title="🧵完全图"></a>🧵完全图</h3><ul><li>对于无向图</li></ul><p>边的个数的取值范围是<strong>0～n(n-1)&#x2F;2</strong>，有n(n-1)&#x2F;2条边的无向图称为完全图，在完全图中任意两个顶点之前都存在边</p><ul><li>对于有向图</li></ul><p>弧的个数的取值范围是**0～n(n-1)**，有n(n-1)&#x2F;2条弧的有向图称为完全图，在有向完全图中任意两个顶点之前都存在方向相反的两条弧</p><h3 id="🧵强连通图-x2F-强连通分量"><a href="#🧵强连通图-x2F-强连通分量" class="headerlink" title="🧵强连通图&#x2F;强连通分量"></a>🧵强连通图&#x2F;强连通分量</h3><p>在有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径 则称这两个顶点是强连通的。<br>若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图的极大强连通子图称为有向图的强连通分量。</p><ul><li>只针对<strong>有向图</strong>而言</li></ul><h2 id="🎮图的存储结构"><a href="#🎮图的存储结构" class="headerlink" title="🎮图的存储结构"></a>🎮图的存储结构</h2><h3 id="🧵邻接矩阵法"><a href="#🧵邻接矩阵法" class="headerlink" title="🧵邻接矩阵法"></a>🧵邻接矩阵法</h3><p>用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边或弧的信息（各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵</p><ul><li>无向图</li></ul><p>无向图的边数组是一个对称矩阵。所谓对称矩阵就是n阶矩阵的元满足aij&#x3D;aji。即从矩阵的左上角到右下角的主对角线有轴 右上角的元和左下角相对应的元都是相等的<br>——要想知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素只和</p><ul><li>有向图</li></ul><p>顶点vi的入度是第i列各数之和（从别的顶点到vi）<br>顶点vi的出度是第i行的各数之和<br><img src="https://i2.100024.xyz/2023/06/11/qrd4hy.webp#height=332&id=bUVxh&originHeight=664&originWidth=1435&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=718"></p><blockquote><p>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是要确定图中有多少条边，必须按行，按列对每个元素进行检测，花费的时间代价很大。<br><strong>稠密图适合用邻接矩阵</strong>表示。<br><strong>设图G的邻接矩阵为A，An的元素An[i][j]等于由顶点i到顶点j的长度为n的路径的数目。</strong></p></blockquote><h3 id="🧵邻接表法"><a href="#🧵邻接表法" class="headerlink" title="🧵邻接表法"></a>🧵邻接表法</h3><p>当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种没有必要的浪费<br><strong>邻接表</strong>——对图G中的每个顶点V建立一个单链表，第i个单链表中的节点表示依附于顶点Vi的边（对于有向图则是以顶点Vi为尾的弧），这个单链表就称为顶点Vi的边表（对于有向图则称为出边表）<br>边表的头指针和顶点的数据信息采用顺序存储——顶点表，在邻接表中存在两种节点——顶点表节点和边表节点<br><img src="https://i2.100024.xyz/2023/06/11/qrm8fz.webp#height=207&id=hEXlY&originHeight=413&originWidth=1343&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=672"></p><h3 id="🧵十字链表法"><a href="#🧵十字链表法" class="headerlink" title="🧵十字链表法"></a>🧵十字链表法</h3><p>十字链表法是<strong>有向图</strong>的一种链式存储结构<br>在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点<br><strong>顶点表结构</strong>——firstin表示入边表头指针，指向该顶点的入边表中的第一个结点；firstout表示出边表头指针，指向该顶点的出边表的第一个结点<br><strong>边表结点结构</strong>——tailvex表示弧起点在顶点表的下标；headvex表示弧终点在顶点表中的下标；headlink表示入边表指针域，指向终点相同的下一条边；taillink表示出边表指针域，指向起点相同的下一条边<br><img src="https://i2.100024.xyz/2023/06/11/qwxqoq.webp#height=384&id=lHkWg&originHeight=767&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=750"></p><blockquote><ol><li>表头结点即是顶点结点，与邻接表一样是顺序存储</li><li>对于每个顶点结点之后是与之相关联的弧结点（该弧结点中存有弧头、弧尾），而邻接表则是一些与顶点结点相连接的点</li><li>从每个顶点结点开始有<strong>两条链表</strong>，<strong>一条是以该顶点结点为弧头的链表，一条是以该顶点结点为弧尾的链表</strong></li><li>对于其中的每一条链表必然是从顶点结点开始，直到与之相关的弧结点链域headlink和taillink为空是结束，构成一条完整的链表</li></ol></blockquote><h3 id="🧵邻接多重表"><a href="#🧵邻接多重表" class="headerlink" title="🧵邻接多重表"></a>🧵邻接多重表</h3><p>邻接多重表是<strong>无向图</strong>的另一种链式存储结构<br>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求<strong>两个顶点之间是否存在边</strong>而<strong>对边执行删除</strong>等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示。<br><strong>顶点表</strong>——data存储该顶点相关信息；firstedge指示第一条依附于该顶点的边<br><img src="https://i2.100024.xyz/2023/06/11/r10cbf.webp#height=54&id=oN31g&originHeight=107&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=293"><br><strong>边表结点</strong>——mark标记域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info指向和边相关的各种信息的指针域<br><img src="https://i2.100024.xyz/2023/06/11/r2u1mw.webp#height=62&id=Q1gn5&originHeight=124&originWidth=1048&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=524"><br><img src="https://i2.100024.xyz/2023/06/11/r4rmv6.webp#height=219&id=tZSez&originHeight=437&originWidth=1410&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=705"></p><blockquote><p>无向图而言，其邻接多重表和邻接表的差别，仅仅在于<strong>同一条边在邻接表中用两个结点表示</strong>，而<strong>在邻接多重表中只有一个结点</strong>。<br>因此，除了在边结点中增加一个标志域外，邻接多重表所需的存储量和邻接表相同。在邻接多重表上，各种基本操作的实现亦和邻接表相似</p></blockquote><h2 id="🎮图的遍历"><a href="#🎮图的遍历" class="headerlink" title="🎮图的遍历"></a>🎮图的遍历</h2><h3 id="🧵深度优先搜索"><a href="#🧵深度优先搜索" class="headerlink" title="🧵深度优先搜索"></a>🧵深度优先搜索</h3><h4 id="🧶主要思想"><a href="#🧶主要思想" class="headerlink" title="🧶主要思想"></a>🧶主要思想</h4><ol><li>首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点</li><li>当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过</li></ol><p><strong>“不撞南墙不回头”</strong></p><h4 id="🧶无向图深度优先图解"><a href="#🧶无向图深度优先图解" class="headerlink" title="🧶无向图深度优先图解"></a><strong>🧶无向图深度优先图解</strong></h4><p><img src="https://i2.100024.xyz/2023/06/11/r7zlhq.webp#height=117&id=XDd4C&originHeight=467&originWidth=462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=116"><br>对上无向图进行深度优先遍历，从A开始——访问顺序是：A -&gt; B -&gt; G -&gt; E -&gt; C -&gt; D -&gt; H -&gt; F</p><h4 id="🧶有向图深度优先图解"><a href="#🧶有向图深度优先图解" class="headerlink" title="🧶有向图深度优先图解"></a><strong>🧶有向图深度优先图解</strong></h4><p><img src="https://i2.100024.xyz/2023/06/11/rcwq3v.webp#height=117&id=NI6I0&originHeight=469&originWidth=499&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=125"><br>对上有向图进行深度优先遍历，从A开始<br>因此访问顺序是：A -&gt; B -&gt; F -&gt; H -&gt; G -&gt; C -&gt; D -&gt; E</p><h3 id="🧵广度优先搜索"><a href="#🧵广度优先搜索" class="headerlink" title="🧵广度优先搜索"></a>🧵广度优先搜索</h3><p>广度优先遍历(Breadth First Search)的主要思想是：类似于树的层序遍历</p><h4 id="🧶无向图广度优先图解"><a href="#🧶无向图广度优先图解" class="headerlink" title="🧶无向图广度优先图解"></a><strong>🧶无向图广度优先图解</strong></h4><p><img src="https://i2.100024.xyz/2023/06/11/retsve.webp#height=113&id=SgYo0&originHeight=451&originWidth=466&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=117"><br>从A开始，有4个邻接点，“B，C，D，F”，这是第二层<br>在分别从B，C，D，F开始找他们的邻接点，为第三层。以此类推<br>因此访问顺序是：A -&gt; B -&gt; C -&gt; D -&gt; F -&gt; G -&gt; E -&gt; H</p><h4 id="🧶有向图广度优先图解"><a href="#🧶有向图广度优先图解" class="headerlink" title="🧶有向图广度优先图解"></a><strong>🧶有向图广度优先图解</strong></h4><p><img src="https://i2.100024.xyz/2023/06/11/rfy8a6.webp#height=110&id=prJ4U&originHeight=442&originWidth=429&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=107"><br>因此访问顺序是：A -&gt; B -&gt; C -&gt; F -&gt; D -&gt; H -&gt; G -&gt; E</p><h2 id="🎮图的基本应用"><a href="#🎮图的基本应用" class="headerlink" title="🎮图的基本应用"></a>🎮图的基本应用</h2><h3 id="🧵几个基本概念"><a href="#🧵几个基本概念" class="headerlink" title="🧵几个基本概念"></a>🧵几个基本概念</h3><ul><li><strong>连通图</strong></li></ul><p>在<strong>无向图</strong>中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该无向图为连通图。</p><ul><li><strong>强连通图</strong></li></ul><p>在<strong>有向图</strong>中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该有向图为强连通图。</p><ul><li><strong>联通网</strong></li></ul><p>在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为<strong>权</strong>；<strong>权代表着连接连个顶点的代价</strong>，称这种连通图叫做连通网。</p><ul><li><strong>生成树</strong></li></ul><p>一个连通图的生成树是指一个连通子图，它<strong>含有图中全部 n 个顶点</strong>，但<strong>只有足以构成一棵树的 n-1 条边</strong>。一颗有 n 个顶点的生成树有且仅有 n-1 条边，<strong>如果生成树中再添加一条边，则必定成环</strong>。</p><ul><li><strong>最小生成树</strong></li></ul><p>在连通网的所有生成树中，所有<strong>边的代价和最小</strong>的生成树，称为最小生成树。<br><img src="https://i2.100024.xyz/2023/06/11/s7ac36.webp#height=202&id=T1PAq&originHeight=404&originWidth=859&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=430"></p><h3 id="🧵最小生成树"><a href="#🧵最小生成树" class="headerlink" title="🧵最小生成树"></a>🧵最小生成树</h3><h4 id="🧶Kruskal算法（克鲁斯卡尔算法）"><a href="#🧶Kruskal算法（克鲁斯卡尔算法）" class="headerlink" title="🧶Kruskal算法（克鲁斯卡尔算法）"></a><strong>🧶Kruskal算法（克鲁斯卡尔算法）</strong></h4><p>此算法可以称为<strong>“加边法”</strong>，初始最小生成树边数为 0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里</p><ol><li>把图中的所有边按代价从小到大排序；</li><li>把图中的 n 个顶点看成独立的 n 棵树组成的森林；</li><li>按权值从小到大选择边，所选的边连接的两个顶点 ui,vi,应属于两颗不同的树，则成为<br>最小生成树的一条边，并将这两颗树合并作为一颗树。</li><li>重复(3),直到所有顶点都在一颗树内或者有 n-1 条边为止</li></ol><p><strong>”先有点后有边“</strong><br><img src="https://i2.100024.xyz/2023/06/11/safiae.webp#height=385&id=krBBM&originHeight=770&originWidth=1306&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=653"></p><h4 id="🧶Prim算法（普利姆算法）"><a href="#🧶Prim算法（普利姆算法）" class="headerlink" title="🧶Prim算法（普利姆算法）"></a><strong>🧶Prim算法（普利姆算法）</strong></h4><p>此算法可以称为<strong>“加点法”</strong>，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。</p><ol><li>图的所有顶点集合为 V；初始令集合 u&#x3D;{s},v&#x3D;V−u；</li><li>在两个集合 u,v 能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把 v0 并入到集合 u 中。</li><li>重复上述步骤，直到最小生成树有 n-1 条边或者 n 个顶点为止。</li><li>由于不断向集合 u 中加点，所以最小代价边必须同步更新；需要建立一个辅助数组 dist，用来维护集合</li></ol><p><img src="https://s2.loli.net/2023/06/11/M4jdmI3Qiw1BbzJ.png#height=409&id=GBwGE&originHeight=817&originWidth=1303&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=652"></p><h4 id="🧶小结"><a href="#🧶小结" class="headerlink" title="🧶小结"></a><strong>🧶小结</strong></h4><p><strong>kruskal 算法</strong>的时间复杂度是 O（|E|log|E|），适用于<strong>稀疏图</strong>，即边比较少点比较多的图<br><strong>prim 算法</strong>的时间复杂度是 O（|V|2），适用于<strong>稠密图</strong>，即边比较多点比较少的图</p><h3 id="🧵最短路径"><a href="#🧵最短路径" class="headerlink" title="🧵最短路径"></a>🧵最短路径</h3><h4 id="🧶Dijkstra算法"><a href="#🧶Dijkstra算法" class="headerlink" title="🧶Dijkstra算法"></a><strong>🧶Dijkstra算法</strong></h4><p><img src="https://s2.loli.net/2023/06/11/cme1ywJWbtNd3Cu.png#height=136&id=edYsK&originHeight=271&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=216"><br>Dijkstra算法可以<strong>计算任意节点到其他节点的最短路径</strong></p><ul><li>算法思路</li></ul><ol><li>指定一个节点，例如我们要计算 ‘A’ 到其他节点的最短路径</li><li>引入两个集合（S、U），S 集合包含已求出的最短路径的点（以及相应的最短长度），U 集合包含未求出最短路径的点（以及 A 到该点的路径，注意如上图所示，A-&gt;C 由于没有直接相连，初始时为∞）</li><li>初始化两个集合，S 集合初始时 只有当前要计算的节点，A-&gt;A &#x3D; 0，U 集合初始时为 A-&gt;B &#x3D; 4, A-&gt;C &#x3D; ∞, A-&gt;D &#x3D; 2, A-&gt;E &#x3D; ∞，接下来要进行核心两步骤了</li><li>从U集合中找出路径最短的点，加入S集合，例如A-&gt;D &#x3D; 2</li><li><strong>更新U集合路径</strong>，if ( ‘D 到 B,C,E 的距离’ + ‘AD 距离’ &lt; ‘A 到 B,C,E 的距离’ ) 则更新 U</li><li>循环执行4、5两步骤，直至遍历结束，得到A</li></ol><p>——每选择一个顶点和路径，都要更新剩余的距离</p><h4 id="🧶Floyd算法"><a href="#🧶Floyd算法" class="headerlink" title="🧶Floyd算法"></a><strong>🧶Floyd算法</strong></h4><p>通过Floyd计算图 G&#x3D;(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵 D 中的元素d[i][j]表示顶点 i(第 i 个顶点)到顶点 j(第 j 个顶点)的距离。矩阵 P 中的元素 p[i][j]，表示顶点 i 到顶点 j 经过了 p[i][j]记录的值所表示的顶点。<br>在初始的矩阵中逐步加入一个新的顶点，更新最短路径</p><h4 id="🧶小结-1"><a href="#🧶小结-1" class="headerlink" title="🧶小结"></a><strong>🧶小结</strong></h4><p>最短路径算法是在图中求两点（或多点）之间的最短路径，我们最常见的最短路径算法有三种：Bellman-ford、Dijkstra、Floyd<br>Bellman-ford 算法可以用于有负边权的图，如果途图中有负环，算法也可以检验出来，时间复杂度为 O(VE)<br>Dijkstra 算法<strong>只能用于边权为正的图</strong>中，时间复杂度为 O（n^2）<br>Floyd <strong>可以用于有负权的图</strong>中，即使有负环，算法也可以检测出来，可以求任意点的最短路径，有向图和无向图的最小环和最大环。时间复杂度 O（n^3）</p><h2 id="🎮拓扑排序"><a href="#🎮拓扑排序" class="headerlink" title="🎮拓扑排序"></a>🎮拓扑排序</h2><h3 id="🧵有向无环图（DAG）"><a href="#🧵有向无环图（DAG）" class="headerlink" title="🧵有向无环图（DAG）"></a>🧵有向无环图（DAG）</h3><p>如果一个有向图不存在环，也就是任意结点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图。</p><h3 id="🧵AOV网——拓扑排序"><a href="#🧵AOV网——拓扑排序" class="headerlink" title="🧵AOV网——拓扑排序"></a>🧵AOV网——拓扑排序</h3><p> 一个有向图表示一个工程的各子工程及其相真制约的关系，其中<strong>以顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为顶点表示活动的网，简称AOV网(Activity On Vertexnetwork)。</p><ul><li>在有向图中，用顶点表示活动，用有向边&lt;Vi,Vj&gt;表示活动i是活动j的必须条件。</li><li>若从i到j有一条有向路径，则i是j的前趋，j是i的后继</li><li>在AOV网络中，如果活动Vi必须在Vj之前进行，则存在有向边&lt;Vi,Vj&gt;，并称Vi是Vj的直接前驱，Vj是Vi的直接后继。</li><li>这种前驱与后继的关系具有传递性和反自反性，这要求AOV网络中<strong>不能出现回路</strong>，即有向环。</li></ul><h3 id="🧵AOE网——关键路径"><a href="#🧵AOE网——关键路径" class="headerlink" title="🧵AOE网——关键路径"></a><strong>🧵AOE网——关键路径</strong></h3><p>用一个有向图表示一个工程的各子工程及其相互制约的关系，<strong>以弧表示活动</strong>，<strong>以顶点表示活动的开始或结束事件</strong>，称这种有向图为边表示活动的网，简称为AOE网(Activity On Edge)。</p><h3 id="🧵拓扑排序"><a href="#🧵拓扑排序" class="headerlink" title="🧵拓扑排序"></a>🧵拓扑排序</h3><p>在AOV网没有回路的前提下，我们将全部活动排列成一个线性序)列，使得若AOV网中有弧&lt;i,j&gt;存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序</strong>。</p><ol><li>在有向图中选一个没有前趋的顶点输出</li><li>从图中删除该顶点和所有以它为尾的弧</li><li>重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止</li></ol><p>——若最后不存在入度为0的节点，说明有环，无解</p><ul><li>一个AOV网的拓扑序列不唯一</li></ul><h4 id="🧶检测AOV网中是否存在环的方法"><a href="#🧶检测AOV网中是否存在环的方法" class="headerlink" title="🧶检测AOV网中是否存在环的方法"></a><strong>🧶检测AOV网中是否存在环的方法</strong></h4><p>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV 网必定不存在环。<br><img src="https://s2.loli.net/2023/06/11/xgs3rvw6pfuhGP2.png#height=325&id=ah9VX&originHeight=649&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=404"></p><h4 id="🧶时间复杂度"><a href="#🧶时间复杂度" class="headerlink" title="🧶时间复杂度"></a><strong>🧶时间复杂度</strong></h4><p>如果AOV网络有<strong>n个顶点</strong>，<strong>e条边</strong>，在拓扑排序的过程中，搜索入度为零的顶点所需的时间是O(n)。在正常情况下，每个顶点进一次栈，出一次栈，所需时间O(n)。每个顶点入度减1的运算共执行了e次。所以总的时间复杂为<strong>O(n+e)</strong></p><h2 id="🎮关键路径"><a href="#🎮关键路径" class="headerlink" title="🎮关键路径"></a><strong>🎮关键路径</strong></h2><h3 id="🧵AOE网"><a href="#🧵AOE网" class="headerlink" title="🧵AOE网"></a><strong>🧵AOE网</strong></h3><p>把工程计划表示为<strong>边表示活动</strong>的网络，即<strong>AOE网</strong>，用顶点表示<strong>事件</strong>，弧表示<strong>活动</strong>，弧的权表示<strong>活动持续时间</strong>。<br><strong>事件</strong>表示在它之前的活动已经完成，在它之后的活动可以开始。</p><h3 id="🧵关键路径"><a href="#🧵关键路径" class="headerlink" title="**🧵关键路径 **"></a>**🧵关键路径 **</h3><p>AOE一般用来估算工程的完成时间。AOE表示工程的流程，把没有入边的称<strong>为始点或者源点</strong>，没有出边的顶点称为<strong>终点或者汇点</strong>。<br>关键路径：从源点到汇点具有<strong>最长路径</strong>（强调：就是AOE网中权值和最大的路径），在关键路径上的活动叫<strong>关键活动</strong>。<br>只有缩短关键路径上的关键活动才可以减少整个项目的时间。</p><h4 id="🧶四个定义"><a href="#🧶四个定义" class="headerlink" title="🧶四个定义"></a><strong>🧶四个定义</strong></h4><p>来看四个定义（<strong>活动是一个过程</strong>，用“开始”，<strong>事件是一个时间点</strong>，用“发生”）：</p><ul><li>e(i)——活动的最早开始时间 ETE(earliest time of edge)：所有前导活动都完成，可以开始的时间。</li><li>l(i)——活动的最晚开始时间 LTE(latest time of edge)：不推迟工期的最晚开工时间。</li><li>ve(vj)——事件的最早发生时间 ETV(earliest time of vertex)：可以等价理解为旧活动的最早结束时间或新活动的最早开始时间</li><li>vl(vj)——事件的最晚发生时间 LTV(latest time of vertex)：可以等价理解为就活动的最晚结束时间或新活动的最晚开始时间</li><li>l(i)-e(i)——表示完成活动ai的时间余量</li></ul><p><strong>关键活动</strong>——l(i)-e(i)&#x3D;0</p><h4 id="🧶如何求"><a href="#🧶如何求" class="headerlink" title="🧶如何求"></a><strong>🧶如何求</strong></h4><p><img src="https://s2.loli.net/2023/06/11/5J34nDYAsCEPfbI.png#height=56&id=sYiCg&originHeight=112&originWidth=386&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=193"><br>设活动ai用弧&lt;j,k&gt;表示，其持续时间为Wj,k，则有：</p><ol><li>e(i)&#x3D;ve(j)</li><li>l(i)&#x3D;vl(k)-Wj,k</li></ol><ul><li><strong>求ve(j)和vl(j)</strong></li></ul><ol><li>从ve(1)&#x3D;0开始向前递推，ve(j) &#x3D; Max{ve(i) + Wij}，&lt; i, j &gt;∈ T, 2≤ j≤n，其中T是所有以j为头的弧的集合</li><li>从vl(n)&#x3D; ve(n)开始向后递推，vl(i)&#x3D;Min{vl(j) - Wi,j}，&lt;i, j &gt;∈S,1 ≤ i ≤ n -1，其中S是所有以i为尾的弧的集合。</li></ol><p><img src="https://s2.loli.net/2023/06/11/QHBuJPhe15ZsFUG.png#height=627&id=rTMa7&originHeight=1253&originWidth=2456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1228"></p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课程总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——C++标注模板库（STL）介绍——queue、priority_queue、stack、pair</title>
      <link href="/2023/06/05/%E7%AC%AC%E5%85%AD%E7%AB%A0%20C++%E6%A0%87%E6%B3%A8%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94queue%E3%80%81priority_queue%E3%80%81stack%E3%80%81pair/"/>
      <url>/2023/06/05/%E7%AC%AC%E5%85%AD%E7%AB%A0%20C++%E6%A0%87%E6%B3%A8%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94queue%E3%80%81priority_queue%E3%80%81stack%E3%80%81pair/</url>
      
        <content type="html"><![CDATA[<h1 id="📌queue的常见用法详解"><a href="#📌queue的常见用法详解" class="headerlink" title="📌queue的常见用法详解"></a>📌queue的常见用法详解</h1><h2 id="📎queue的定义"><a href="#📎queue的定义" class="headerlink" title="📎queue的定义"></a>📎queue的定义</h2><blockquote><p>头文件#include<queue><br>using namespace std;</p></blockquote><p>定义写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h2 id="📎queue容器内元素的访问"><a href="#📎queue容器内元素的访问" class="headerlink" title="📎queue容器内元素的访问"></a>📎queue容器内元素的访问</h2><p>队列(queue)是一种先进先出的限制性数据结构，在STL中只能<strong>通过front()来访问队首元素</strong>，<strong>back()来访问队尾元素</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br></pre></td></tr></table></figure><h2 id="📎queue常用函数实例解析"><a href="#📎queue常用函数实例解析" class="headerlink" title="📎queue常用函数实例解析"></a>📎queue常用函数实例解析</h2><ol><li><strong>push()</strong></li></ol><p>push(x)将x进行入队，时间复杂度为O(1)</p><ol start="2"><li><strong>front()、back()</strong></li></ol><p>front()和back()可以分别获得队首元素和队尾元素，时间复杂度为O(1)</p><ol start="3"><li><strong>pop()</strong></li></ol><p>pop()令队首元素出队，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(i);<span class="comment">//入队1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    q.<span class="built_in">pop</span>();<span class="comment">//出队1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,q.<span class="built_in">front</span>());<span class="comment">//4</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>empty()</strong></li></ol><p>empty()检测queue是否为空，返回true则空，返回false则非空。时间复杂度为O(1)</p><ol start="5"><li><strong>size()</strong></li></ol><p>size()返回queue内元素的个数，时间复杂度为O(1)</p><h2 id="📎queue的常见用途"><a href="#📎queue的常见用途" class="headerlink" title="📎queue的常见用途"></a>📎queue的常见用途</h2><p>当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue作为代替，以提高程序的准确性</p><ul><li>注意：使用front()和back()函数前，必须使用empty()判断队列是否为空，否则可能因为队空而出现错误</li></ul><h1 id="📌priority-queue的常见用法详解"><a href="#📌priority-queue的常见用法详解" class="headerlink" title="📌priority_queue的常见用法详解"></a>📌priority_queue的常见用法详解</h1><p>priority_queue又称为优先队列，其底层是用<strong>堆</strong>来进行实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。例如在队列中有元素，且已定义好了优先级：桃子（优先级3）、梨（优先级4）、苹果（优先级1）——那么出队的顺序梨—桃子—苹果<br>可以在任何时候往优先队列里面加入(push)元素，而优先队列底层的数据结构堆会随时调整结构，使得<strong>每次的队首元素都是优先级最大的</strong></p><h2 id="📎priority-queue的定义"><a href="#📎priority-queue的定义" class="headerlink" title="📎priority_queue的定义"></a>📎priority_queue的定义</h2><blockquote><p>头文件#include<queue><br>using namespace std;</p></blockquote><p>定义写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h2 id="📎priority-queue容器内元素的访问"><a href="#📎priority-queue容器内元素的访问" class="headerlink" title="📎priority_queue容器内元素的访问"></a>📎priority_queue容器内元素的访问</h2><p>和队列不一样，优先队列没有front()和back()函数，它<strong>通过top()函数来访问队首元素</strong>，也就是优先级最高的元素</p><h2 id="📎priority-queue常用函数实例解析"><a href="#📎priority-queue常用函数实例解析" class="headerlink" title="📎priority_queue常用函数实例解析"></a>📎priority_queue常用函数实例解析</h2><ol><li><strong>push()</strong></li></ol><p>push(x)将令x入队，时间复杂度为O(logN)，其中N为当前优先队列中的元素个数</p><ol start="2"><li><strong>top()</strong></li></ol><p>top()可以获得队首元素（即堆顶元素），时间复杂度为O(1)</p><ol start="3"><li><strong>pop()</strong></li></ol><p>pop()令队首元素出队，时间复杂度为O(logN)，其中N为当前优先队列中的元素个数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());<span class="comment">//4</span></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>());<span class="comment">//3</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>empty()</strong></li></ol><p>empty()检测优先队列是否为空，返回true则为空，返回false则非空，时间复杂度为O(1)</p><ol start="5"><li><strong>size()</strong></li></ol><p>size()返回优先队列内元素的个数，时间复杂度为O(1)</p><h2 id="📎priority-queue内元素优先级的设置"><a href="#📎priority-queue内元素优先级的设置" class="headerlink" title="📎priority_queue内元素优先级的设置"></a>📎priority_queue内元素优先级的设置</h2><h3 id="📜基本数据类型的优先级设置"><a href="#📜基本数据类型的优先级设置" class="headerlink" title="📜基本数据类型的优先级设置"></a>📜基本数据类型的优先级设置</h3><p>基本数据类型——int、double、char等，优先级队列对它们的优先级设置一般是数字大的优先级越高，因此队首元素就是优先队列内元素最大的那个（char型则为字典序最大的）<br>以int型为例：（两种写法等价）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><p>less<int>表示数字大的优先级越大，greater<int>表示数字小的优先级越大<br>若想让优先队列总是把优先级小的元素放在队首</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><h3 id="📜结构体的优先级设置"><a href="#📜结构体的优先级设置" class="headerlink" title="📜结构体的优先级设置"></a>📜结构体的优先级设置</h3><p>对水果的名称和价格建立一个结构体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>希望按水果的价格高的为优先级，重载小于号”&lt;”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&lt;f2.price;<span class="comment">//若需要价格低的为优先级 改成&gt;即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义优先队列如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;friut&gt; q;</span><br><span class="line"><span class="comment">//以价格高的水果为优先级</span></span><br></pre></td></tr></table></figure><ul><li><strong>优先队列的函数与sort中的cmp函数的效果是相反的</strong></li></ul><p>也可以的写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&lt;f2.price;<span class="comment">//若需要价格低的为优先级 改成&gt;即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; q;</span><br></pre></td></tr></table></figure><p>如果结构体内数据庞大，可以使用引用来提高效率</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> fruit &amp;f1,<span class="type">const</span> fruit &amp;f2)&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&lt;f2.price;<span class="comment">//若需要价格低的为优先级 改成&gt;即可</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结构体的push方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fruit</span>(string _name, <span class="type">int</span> _price) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;m;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">fruit</span>(a,m));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="📎priority-queue的常见用途"><a href="#📎priority-queue的常见用途" class="headerlink" title="📎priority_queue的常见用途"></a>📎priority_queue的常见用途</h2><p>可以解决贪心问题和对Dijkstra算法进行优化</p><ul><li>注意：使用top()函数前，必须使用empty()判断队列是否为空，否则可能因为队空而出现错误</li></ul><h1 id="📌stack的常见用法详解"><a href="#📌stack的常见用法详解" class="headerlink" title="📌stack的常见用法详解"></a>📌stack的常见用法详解</h1><p>stack——栈，后进先出</p><h2 id="📎stack的定义"><a href="#📎stack的定义" class="headerlink" title="📎stack的定义"></a>📎stack的定义</h2><blockquote><p>头文件#include<stack><br>using namespace std;</p></blockquote><p>定义写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h2 id="📎stack容器内元素的访问"><a href="#📎stack容器内元素的访问" class="headerlink" title="📎stack容器内元素的访问"></a>📎stack容器内元素的访问</h2><p>stack中只能通过<strong>top()来访问栈顶元素</strong></p><h2 id="📎stack常用函数实例解析"><a href="#📎stack常用函数实例解析" class="headerlink" title="📎stack常用函数实例解析"></a>📎stack常用函数实例解析</h2><ol><li><strong>push()</strong></li></ol><p>push(x)将x入栈，时间复杂度为O(1)</p><ol start="2"><li><strong>top()</strong></li></ol><p>top()获得栈顶元素，时间复杂度为O(1)——不是出栈！</p><ol start="3"><li><strong>pop()</strong></li></ol><p>pop()用以弹出栈顶元素，时间复杂度为O(1)</p><ol start="4"><li><strong>empty()</strong></li></ol><p>empty()检测stack内是否为空，返回true为空，false为非空</p><ol start="5"><li><strong>size()</strong></li></ol><p>size()返回栈内元素的个数，时间复杂度为O(1)</p><h1 id="📌pair的常见用法详解"><a href="#📌pair的常见用法详解" class="headerlink" title="📌pair的常见用法详解"></a>📌pair的常见用法详解</h1><p>pair实际上可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">typeName1 first;</span><br><span class="line">typeName2 second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="📎pair的定义"><a href="#📎pair的定义" class="headerlink" title="📎pair的定义"></a>📎pair的定义</h2><blockquote><p>头文件#include<utility>&#x2F;&#x2F;可以偷懒用#include<map><br>using namespace std;</p></blockquote><p>定义写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;typeName1,typeName2&gt; name;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span></span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><p>若想在代码中临时构建一个pair：</p><ol><li><p>类型定义写在前面，后面用小括号内两个元素的方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;haha&quot;</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>是用自带的make_pair函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; p=<span class="built_in">make_pair</span>(a,m);</span><br><span class="line">cout&lt;&lt;p.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p.second;</span><br></pre></td></tr></table></figure></li></ol><h2 id="📎pair中元素的访问"><a href="#📎pair中元素的访问" class="headerlink" title="📎pair中元素的访问"></a>📎pair中元素的访问</h2><p>pair中只有两个元素，first和second，只需要按正常结构体的方式去访问即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;string,<span class="type">int</span>&gt; p;</span><br><span class="line">p.first=<span class="string">&quot;first&quot;</span>;</span><br><span class="line">p.second=<span class="string">&quot;5&quot;</span>;</span><br><span class="line">p=<span class="built_in">make_pair</span>(<span class="string">&quot;second&quot;</span>,<span class="number">55</span>);</span><br><span class="line">p=<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;third&quot;</span>,<span class="number">555</span>);</span><br></pre></td></tr></table></figure><h2 id="📎pair常用函数实例解析"><a href="#📎pair常用函数实例解析" class="headerlink" title="📎pair常用函数实例解析"></a>📎pair常用函数实例解析</h2><ol><li><strong>比较操作数</strong></li></ol><p>两个pair类型数据可以直接使用&#x3D;&#x3D;、！&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;来比较大小，比较规则：<br><strong>先以first的大小作为标准，只有当first相等时才去判别second的大小</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">5</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">6</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(p1&gt;p2)...</span><br></pre></td></tr></table></figure><h2 id="📎pair的常见用途"><a href="#📎pair的常见用途" class="headerlink" title="📎pair的常见用途"></a>📎pair的常见用途</h2><ol><li>代替二元结构体构造函数</li><li>作为map的键值进行插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;haaha&quot;</span>,<span class="number">3</span>));</span><br><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——树和二叉树</title>
      <link href="/2023/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="🎰树和二叉树"><a href="#🎰树和二叉树" class="headerlink" title="🎰树和二叉树"></a>🎰树和二叉树</h1><p><img src="https://i2.100024.xyz/2023/06/08/zk36pl.webp#id=hC0TD&originHeight=762&originWidth=1672&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎮树和二叉树的相关概念"><a href="#🎮树和二叉树的相关概念" class="headerlink" title="🎮树和二叉树的相关概念"></a>🎮树和二叉树的相关概念</h2><h3 id="🧵树"><a href="#🧵树" class="headerlink" title="🧵树"></a>🧵树</h3><p>树是非线性结构，其元素之间有明显的层次关系。在树的结构中，每个节点都只有一个前件称为父节点，没有前件的节点称为树的根节点，简称为树的根，每个节点可以有多个后件成为节点的子节点，没有后件的节点称为叶子节点。<br>节点的度——一个节点所拥有的子节点的个数<br>树的度——树中最大的节点的度<br>树的深度——树的最大层次</p><h3 id="🧵二叉树"><a href="#🧵二叉树" class="headerlink" title="🧵二叉树"></a>🧵二叉树</h3><p>二叉树的每个节点至多只有两棵子树，且二叉树的子树有左右之分，其次序不能任意颠倒。<br>二叉树以递归的形式定义。二叉树是n个节点的有限集合。</p><ul><li>空二叉树——n为0</li><li>由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树</li></ul><p>二叉树是有序树，若将其左、右子树颠倒，则会成为一颗不同的二叉树。即使树中节点只有一棵子树，也要区分是左子树还是右子树。</p><h3 id="🧵满二叉树"><a href="#🧵满二叉树" class="headerlink" title="🧵满二叉树"></a>🧵满二叉树</h3><p>除了最后一层外，其它节点均为两棵子树</p><h3 id="🧵完全二叉树"><a href="#🧵完全二叉树" class="headerlink" title="🧵完全二叉树"></a>🧵完全二叉树</h3><p>除了最后一层外，其它任何一层的节点数均达到最大值，且最后一层也只是在最右侧缺少节点</p><h3 id="🧵二叉树的存储"><a href="#🧵二叉树的存储" class="headerlink" title="🧵二叉树的存储"></a>🧵二叉树的存储</h3><p>二叉树可以用链式存储结构来存储，满二叉树和完全二叉树可以用顺序存储结构来存储</p><h3 id="🧵二叉树的遍历"><a href="#🧵二叉树的遍历" class="headerlink" title="🧵二叉树的遍历"></a>🧵二叉树的遍历</h3><p>二叉树有先序遍历（根左右）、中序遍历（左根右）和后续遍历（左右根），还有层次遍历，需要借助一个队列<br>在三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根节点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，**时间复杂度都为O(n)**。在递归遍历中，递归工作栈的栈深恰好为树的深度，在最坏的情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)</p><h2 id="🎮由遍历序列构造一棵二叉树"><a href="#🎮由遍历序列构造一棵二叉树" class="headerlink" title="🎮由遍历序列构造一棵二叉树"></a>🎮由遍历序列构造一棵二叉树</h2><h3 id="🧵先序序列和中序序列"><a href="#🧵先序序列和中序序列" class="headerlink" title="🧵先序序列和中序序列"></a>🧵先序序列和中序序列</h3><ul><li><strong>由先序序列和中序序列可以唯一地确定一棵二叉树</strong></li></ul><p>在先序遍历序列中，第一个结点一定是二叉树地根节点；在中序遍历中，根节点必然将中序序列分割成两个子序列，前一个子序列是根节点地左子树地中序序列，后一个子序列是根节点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在左子序列的第一个结点是左子树的根节点，右子序列的第一个结点是右子树的根节点。</p><h3 id="🧵后序序列和中序序列"><a href="#🧵后序序列和中序序列" class="headerlink" title="🧵后序序列和中序序列"></a>🧵后序序列和中序序列</h3><ul><li><strong>由后序序列和中序序列可以唯一地确定一棵二叉树</strong></li></ul><p>与先序和中序的思路相同，后序序列的最后一个节点为根节点，可以分割将中序序列分割成两个子序列</p><h3 id="🧵其他"><a href="#🧵其他" class="headerlink" title="🧵其他"></a>🧵其他</h3><ul><li><strong>由层次序列和中序序列可以唯一地确定一棵二叉树</strong></li><li><strong>由先序序列和后序序列无法确定一棵二叉树</strong></li></ul><h2 id="🎮线索二叉树"><a href="#🎮线索二叉树" class="headerlink" title="🎮线索二叉树"></a>🎮线索二叉树</h2><h3 id="🧵二叉树的链式存储"><a href="#🧵二叉树的链式存储" class="headerlink" title="🧵二叉树的链式存储"></a>🧵二叉树的链式存储</h3><p>在链式存储中，每个结点的结构如下：<br><img src="https://i2.100024.xyz/2023/06/08/x4vrnn.webp#height=127&id=Ssz4u&originHeight=253&originWidth=438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=219"><br>结构描述：一个存储数据的变量与两个指向孩子的指针域</p><h3 id="🧵线索二叉树"><a href="#🧵线索二叉树" class="headerlink" title="🧵线索二叉树"></a>🧵线索二叉树</h3><p>对于有n个结点的二叉树，采用二叉链表的形式村塾，有n-1条有效分支路径，有n+1个空链域，利用这些空链域存放在某种遍历次序下该节点的前驱节点和后继结点的指针，这些指针称为线索，加上这些线索的二叉树称为<strong>线索二叉树</strong>。<br>根据线索性质的不同，线索二叉树可以分为前序搜索二叉树、中序搜索二叉树和后续搜索二叉树</p><ul><li>线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题<blockquote><p>二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继(第一个结点无前驱，最后一个结点无后继)。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是<strong>利用二叉树的空链指针</strong>。</p></blockquote></li></ul><h2 id="🎮树的存储结构"><a href="#🎮树的存储结构" class="headerlink" title="🎮树的存储结构"></a>🎮树的存储结构</h2><h3 id="🧵双亲表示法"><a href="#🧵双亲表示法" class="headerlink" title="🧵双亲表示法"></a>🧵双亲表示法</h3><p>以双亲作为索引的关键词的一种存储方式，每个结点只有一个双亲，因此<strong>顺序存储</strong>占主要<br>这种存储方式采用一组连续空间来存储每个结点，同时在每个节点中增设一个伪指针，指示其双亲结点在数组中的位置<br><img src="https://i2.100024.xyz/2023/06/08/xczkgk.webp#height=330&id=B3gB9&originHeight=660&originWidth=1582&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=791"><br>该存储结构利用了每个结点（根节点除外）都只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但<strong>求结点的孩子时需要遍历整个结构</strong>（从上往下找慢，从下往上找快）</p><h3 id="🧵孩子表示法"><a href="#🧵孩子表示法" class="headerlink" title="🧵孩子表示法"></a><strong>🧵孩子表示法</strong></h3><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表（叶子结点的孩子链表为空表）<br><img src="https://i2.100024.xyz/2023/06/08/xexod3.webp#height=356&id=JPJZV&originHeight=711&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=529"><br>这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</p><h3 id="🧵孩子兄弟表示法"><a href="#🧵孩子兄弟表示法" class="headerlink" title="🧵孩子兄弟表示法"></a><strong>🧵孩子兄弟表示法</strong></h3><p>孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：节点值、指向结点第一个孩子结点的指针、指向结点下一个兄弟结点的指针（沿此域可以找到所有节点的兄弟节点）<br><img src="https://i2.100024.xyz/2023/06/08/xjg2oo.webp#height=324&id=HrWyw&originHeight=647&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=433"><br>这种存储表示法比较灵活，其最大的优点是可以方便地实现<strong>树转换为二叉树</strong>的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。</p><h2 id="🎮森林和二叉树的转换"><a href="#🎮森林和二叉树的转换" class="headerlink" title="🎮森林和二叉树的转换"></a>🎮森林和二叉树的转换</h2><h3 id="🧵树转换为二叉树"><a href="#🧵树转换为二叉树" class="headerlink" title="🧵树转换为二叉树"></a>🧵树转换为二叉树</h3><ol><li>加线。在所有兄弟节点之间加一条线</li><li>曲线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li><li>层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。</li></ol><p><img src="https://i2.100024.xyz/2023/06/08/xmjevd.webp#height=389&id=oYQic&originHeight=777&originWidth=1063&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=532"></p><h3 id="🧵森林转换为二叉树"><a href="#🧵森林转换为二叉树" class="headerlink" title="🧵森林转换为二叉树"></a>🧵森林转换为二叉树</h3><ol><li>把每棵树都转转换为二叉树</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的结点作为前一棵二叉树的根节点的右孩子，用线连接起来</li></ol><p><img src="https://i2.100024.xyz/2023/06/08/xnt8kq.webp#height=372&id=pQBiQ&originHeight=744&originWidth=1082&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=541"></p><h3 id="🧵二叉树转换为树"><a href="#🧵二叉树转换为树" class="headerlink" title="🧵二叉树转换为树"></a>🧵二叉树转换为树</h3><ol><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来</li><li>去线。删除原二叉树中所有节点与其右孩子结点的连线</li><li>层次调整</li></ol><p><img src="https://i2.100024.xyz/2023/06/08/xphqat.webp#height=291&id=ffJjJ&originHeight=582&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=581"></p><h3 id="🧵二叉树转换为森林"><a href="#🧵二叉树转换为森林" class="headerlink" title="🧵二叉树转换为森林"></a>🧵二叉树转换为森林</h3><p>假设一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树</p><ol><li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…直到所有这些根节点与右孩子的连线都删除为止</li><li>将每棵分离后的二叉树转换为树</li></ol><p><img src="https://i2.100024.xyz/2023/06/08/xs3bvt.webp#height=387&id=dSYTS&originHeight=774&originWidth=1146&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=573"></p><h2 id="🎮二叉排序树"><a href="#🎮二叉排序树" class="headerlink" title="🎮二叉排序树"></a>🎮二叉排序树</h2><h3 id="🧵定义"><a href="#🧵定义" class="headerlink" title="🧵定义"></a>🧵定义</h3><p>二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特征的二叉树：</p><ol><li>若左子树非空，则左子树上所有结点的值均小于根节点的值</li><li>若右子树非空，则右子树上所有结点的值均大于根节点的值</li><li>左、右子树也分别是一棵二叉排序树</li></ol><p>根据二叉排序树的定义，左子树结点&lt;根节点值&lt;右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列</p><h3 id="🧵查找"><a href="#🧵查找" class="headerlink" title="🧵查找"></a>🧵查找</h3><p>二叉排序树的查找是从根节点开始的，沿某个分支逐层向下的过程。若二叉树非空，先将给定值与根节点的关键字比较，若相等，则查找成功；若不等，如果小于根节点的关键字，则在根节点的左子树上查找，否则在右子树上查找。<strong>递归的过程</strong></p><h3 id="🧵插入"><a href="#🧵插入" class="headerlink" title="🧵插入"></a><strong>🧵插入</strong></h3><p>二叉树的插入是建立在查找之上的，插入一个结点就是通过查找发现该节点合适的插入位置，把结点直接放进去</p><ol><li>若查找的key已经在树中，则p指向该数据节点</li><li>若查找的key没有在树中，则p指向查找路径上的最后一个结点</li></ol><h3 id="🧵删除"><a href="#🧵删除" class="headerlink" title="🧵删除"></a><strong>🧵删除</strong></h3><p>删除的时候需要考虑以下几种情况：</p><ol><li>删除结点为叶子节点</li><li>删除的结点只有左子树</li><li>删除的结点只有右子树</li><li>删除的结点既有左子树又有右子树</li></ol><p>情况1：直接删除该节点即可<br>情况2&#x2F;3：删除该节点并将左&#x2F;右子树结点替代即可<br>情况4：在剩余的序列中找到最接近的结点来替代删除结点——可以采用中序遍历的方法来得到删除结点的前驱和后继</p><h2 id="🎮平衡二叉树"><a href="#🎮平衡二叉树" class="headerlink" title="🎮平衡二叉树"></a><strong>🎮平衡二叉树</strong></h2><p>避免树的高度增长过快，降低二叉树的性能，规定在插入和删除二叉树结点时，要保证<strong>任意结点的左、右子树的高度之差的绝对值不超过1</strong>，这样的二叉树称为<strong>平衡二叉树（AVL树）</strong>。<br>定义结点左子树与右子树的高度差为该节点的<strong>平衡因子</strong>。平衡二叉树的平衡因子的值只可能是-1，0，1。<br>平衡二叉树具体定义：平衡二叉树可定义为或者是一棵空树，或者是具有以下性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1</p><h3 id="🧵平衡二叉树的维系"><a href="#🧵平衡二叉树的维系" class="headerlink" title="🧵平衡二叉树的维系"></a><strong>🧵平衡二叉树的维系</strong></h3><p>对于平衡二叉树而言，当导入的新值导致它不是平衡二叉树</p><ul><li>麻烦节点：新插入结点而导致平衡性被破坏的结点</li><li>被破坏结点：被其破坏平衡的结点</li></ul><ol><li>LL型——以被破坏节点为基础进行右旋</li><li>RR型——左旋</li><li>LR型——先左旋后右旋</li><li>RL型——先右旋后左旋<blockquote><p>处理方式分类两大类:</p><ol><li>RR型和LL型，以被破坏节点为基础进行其反向的旋转即可，即 RR型进行左旋，LL型进行右旋。</li><li>RL型和LR 型，先以被破坏节点的LR或RL首字母的节点进行LR或RL首字母旋转，再以被破坏节点为基础进行LR或RL尾字母旋转，即RL型先以被破坏节点的R（右）节点为基础进行一次R（右）选，再以被破坏节点为基础进行一次L（左）旋；LR旋先以被破坏节点的L（左）节点为基础进行一次L（左）选，再以被破坏节点为基础进行一次R（右）旋。</li></ol></blockquote></li></ol><h3 id="🧵平衡二叉树的删除"><a href="#🧵平衡二叉树的删除" class="headerlink" title="🧵平衡二叉树的删除"></a><strong>🧵平衡二叉树的删除</strong></h3><h4 id="🧶删除结点在右子树"><a href="#🧶删除结点在右子树" class="headerlink" title="🧶删除结点在右子树"></a>🧶删除结点在右子树</h4><p>即在右边删除而导致树失衡，此时左子树高度会大于右子树，右子树删除有三种调节方式。</p><ul><li>注意：在右子树进行删除一个节点而导致失衡，则相当于在左子树插入一个新节点而导致的失衡，所以需要进行平衡性调整应该从左子树入手。</li></ul><ol><li><strong>删除后被破坏节点的左节点的左边高度大于右边高度</strong></li></ol><p><img src="https://i2.100024.xyz/2023/06/08/yydoh2.webp#height=208&id=CjvNK&originHeight=415&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=328"><br>当在右子树删除而导致树失衡时，判断被破坏节点的左节点的左边高度和右边高度，如果<strong>左边高度大于右边高度</strong>，则相当于在被破坏节点的左节点的左节点下插入一个新的节点而导致的不平衡，即<strong>LL型插入</strong>，此时进行<strong>右旋</strong>调整即可</p><ol start="2"><li><strong>删除后被破坏结点的左节点的左边高度小于右边高度</strong></li></ol><p><img src="https://i2.100024.xyz/2023/06/08/yzbw6h.webp#height=232&id=KGyA9&originHeight=464&originWidth=594&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=297"><br>当在右子树删除而导致树失衡时，判断被破坏节点的左节点的左边高度和右边高度，如果左边高度小于右边高度，则相当于在被破坏节点的左节点的右节点下插入一个新的节点而导致的不平衡，即<strong>LR型插入</strong>，此时先<strong>对被破坏节点的L（左）节点进行L（左）旋再对被破坏节点进行 R（右）旋即可</strong></p><ol start="3"><li><strong>删除后被破坏结点的左节点的左边高度等于右边高度</strong></li></ol><p><img src="https://i2.100024.xyz/2023/06/08/z1a704.webp#height=219&id=YlUwx&originHeight=438&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=340"><br>当在右子树删除而导致树失衡时，判断被破坏节点的左节点的左边高度和右边高度，如果左边高度等于右边高度，因为在右子树进行删除，此时对被破坏节点进行右旋即可</p><h4 id="🧶删除结点在左子树"><a href="#🧶删除结点在左子树" class="headerlink" title="🧶删除结点在左子树"></a>🧶删除结点在左子树</h4><p>即在左边删除而导致树失衡，此时右子树高度会大于左子树，左子树删除有三种调节方式。</p><ul><li>注意：在左子树进行删除一个节点而导致失衡，则相当于在右子树插入一个新节点而导致的失衡，所以需要进行平衡性调整应该从右子树入手。</li></ul><ol><li><strong>删除后被破坏结点的左节点的左边高度小于右边高度</strong></li></ol><p><img src="https://i2.100024.xyz/2023/06/08/z2wri8.webp#height=208&id=QlYKL&originHeight=416&originWidth=536&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=268"><br>当在左子树删除而导致树失衡时，判断被破坏节点的右节点的左边高度和右边高度，如果左边高度小于右边高度，则相当于在被破坏节点的右节点的右节点下插入一个新的节点而导致的不平衡，即<strong>RR型插入</strong>，此时进行<strong>左旋调整</strong>即可</p><ol start="2"><li><strong>删除后被破坏结点的左节点的左边高度大于右边高度</strong></li></ol><p><img src="https://i2.100024.xyz/2023/06/08/z3f1q7.webp#height=242&id=lRecA&originHeight=484&originWidth=488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=244"><br>当在左子树删除而导致树失衡时，判断被破坏节点的右节点的左边高度和右边高度，如果左边高度大于右边高度，则相当于在被破坏节点的右节点的左节点下插入一个新的节点而导致的不平衡，即<strong>RL型插入</strong>，此时<strong>先对被破坏节点的R（右）节点进行R（右）旋，再对被破坏节点进行L（左）旋即可</strong>。</p><ol start="3"><li><strong>删除后被破坏结点的左节点的左边高度等于右边高度</strong></li></ol><p><img src="https://i2.100024.xyz/2023/06/08/z4974s.webp#height=216&id=m21bK&originHeight=431&originWidth=475&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=238"><br>当在左子树删除而导致树失衡时，判断被破坏节点的左节点的左边高度和右边高度，如果左边高度等于右边高度，因为在左子树进行删除，此时对被破坏节点进行<strong>左旋</strong>即可</p><blockquote><p>在某一边删除而导致失衡时，则判断被破坏节点的某节点的左右高度，如果高度不一致，则相当于<strong>在某边+高度高的那一边进行的插入，根据类型判断对应的旋转</strong>；如果高度一致，则对<strong>被破坏节点进行删除某旋即可</strong>。<br>注意:某代表左或右，如果在左边删除则为左。</p></blockquote><h2 id="🎮哈夫曼树和哈夫曼编码"><a href="#🎮哈夫曼树和哈夫曼编码" class="headerlink" title="🎮哈夫曼树和哈夫曼编码"></a><strong>🎮哈夫曼树和哈夫曼编码</strong></h2><h3 id="🧵哈夫曼树"><a href="#🧵哈夫曼树" class="headerlink" title="🧵哈夫曼树"></a><strong>🧵哈夫曼树</strong></h3><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为<strong>最优二叉树</strong>，也称为<strong>哈夫曼树(Huffman Tree)<strong>。哈夫曼树是</strong>带权路径长度最短的树</strong>，权值较大的结点离根较近。</p><ul><li>路径：在一棵树中，从一个结点到另一个结点所经过的所有结点，被我们称为两个结点之间的路径。</li><li>路径长度：在一棵树中，从一个结点到另一个结点<strong>所经过的“边”的数量</strong>，被我们称为两个结点之间的路径长度。</li><li>结点的带权路径长度：在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。——权重*路径长度之和</li></ul><h4 id="🧶哈夫曼树的构建"><a href="#🧶哈夫曼树的构建" class="headerlink" title="🧶哈夫曼树的构建"></a>🧶哈夫曼树的构建</h4><ol><li>构建森林——把每个叶子结点都当作一棵独立的树</li><li>选择当前权值最小的两个结点，生成新的父节点——父节点的权值是两个权值之和</li><li>从队列中移除上一步选择的两个最小结点，把父节点加入队列</li><li>重复2、3步骤直到只剩下一棵树为止</li></ol><h4 id="🧶哈夫曼树的特点"><a href="#🧶哈夫曼树的特点" class="headerlink" title="🧶哈夫曼树的特点"></a>🧶哈夫曼树的特点</h4><ol><li>每个初始结点最终都称为叶节点，且权值越小的节点到根节点的路径长度越大</li><li>构造过程中共建立了n-1个新节点，因此哈夫曼树的节点总树为2n-1</li><li>每次构造都选择两棵树作为新节点的孩子，因此哈夫曼树不存在度为1的节点</li></ol><h3 id="🧵哈夫曼编码"><a href="#🧵哈夫曼编码" class="headerlink" title="🧵哈夫曼编码"></a><strong>🧵哈夫曼编码</strong></h3><p>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为<strong>固定长度编码</strong>。若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<strong>可变长度编码</strong>。<br>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。<strong>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。</strong></p><ul><li><strong>任意一个叶子节点都不可能在其他叶子节点的路径中</strong></li></ul><h4 id="🧶由哈夫曼树得到哈夫曼编码"><a href="#🧶由哈夫曼树得到哈夫曼编码" class="headerlink" title="🧶由哈夫曼树得到哈夫曼编码"></a>🧶由哈夫曼树得到哈夫曼编码</h4><p>由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”。<br><img src="https://i2.100024.xyz/2023/06/08/zbwe30.webp#height=216&id=SBlHY&originHeight=432&originWidth=950&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=475"></p><h4 id="🧶译码"><a href="#🧶译码" class="headerlink" title="🧶译码"></a>🧶译码</h4><p>从哈夫曼树根开始，对待译码电文逐位取码。若编码是“0”，则向左走;若编码是“1”，则向右走，一旦到达叶子结点，则译出一个字符;再重新从根出发，直到电文结束。</p><h2 id="🎮红黑树"><a href="#🎮红黑树" class="headerlink" title="🎮红黑树"></a><strong>🎮红黑树</strong></h2><h3 id="🧵有了二叉搜索树，为什么还需要平衡二叉树"><a href="#🧵有了二叉搜索树，为什么还需要平衡二叉树" class="headerlink" title="🧵有了二叉搜索树，为什么还需要平衡二叉树?"></a><strong>🧵有了二叉搜索树，为什么还需要平衡二叉树?</strong></h3><p>二叉搜索树容易退化成一条链，查找的时间复杂度从 O(log2N)也将退化成 O(N)<br>引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log2N)</p><h3 id="🧵有了平衡二叉树-为什么还需要红黑树"><a href="#🧵有了平衡二叉树-为什么还需要红黑树" class="headerlink" title="🧵有了平衡二叉树,为什么还需要红黑树?"></a><strong>🧵</strong>有了平衡二叉树,为什么还需要红黑树?</h3><p>AVL 的左右子树高度差不能超过 1，每次进行插入删除操作时，几乎都需要通过旋转操作保持平衡。在频繁进行插入删除的场景中，频繁的旋转操作使得 AVL 的性能大打折扣<br>红黑树通过牺牲严格的平衡，换取插入删除时少量的旋转操作，整体性能优于 AVL。红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决。红黑树的红黑规则，保证最坏的情况下，也能在 O(log2N )时间内完成查找操作。</p><h3 id="🧵红黑树"><a href="#🧵红黑树" class="headerlink" title="🧵红黑树"></a><strong>🧵</strong>红黑树</h3><p><img src="https://i2.100024.xyz/2023/06/08/zfe24k.webp#height=302&id=MASnQ&originHeight=603&originWidth=1240&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"></p><ol><li>节点不是红色就是黑色</li><li>根节点是黑色</li><li>叶节点为黑色（叶节点是指末梢的空节点Nil或NULL）</li><li>一个节点为红色，则其两个叶节点必须是黑色的（根到叶子的所有路径，不可能存在<strong>两个连续的红色节点</strong>）</li><li>每个节点到叶子节点的所有路径，都包含相<strong>同数目的黑色节点</strong>（相同的黑色高度）</li></ol><h4 id="🧶一些说明"><a href="#🧶一些说明" class="headerlink" title="🧶一些说明"></a>🧶一些说明</h4><ul><li>约束4 、5保证了红黑树的大致平衡：根到叶子的所有路径中，最长路径不会超过最短路径的2倍</li><li>红黑树最坏情况——O（log2N）</li><li>默认新插入的节点为红色：父节点为黑色的概率较大，插入新节点为红色可以避免颜色冲突</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课程总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——C++标注模板库（STL）介绍——algorithm头文件下的常用函数</title>
      <link href="/2023/05/29/%E7%AC%AC%E5%85%AD%E7%AB%A0%20C++%E6%A0%87%E6%B3%A8%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2023/05/29/%E7%AC%AC%E5%85%AD%E7%AB%A0%20C++%E6%A0%87%E6%B3%A8%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="🎂algorithm头文件下的常用函数"><a href="#🎂algorithm头文件下的常用函数" class="headerlink" title="🎂algorithm头文件下的常用函数"></a>🎂algorithm头文件下的常用函数</h1><blockquote><p>头文件#include<algorithm><br>using namespace std;</p></blockquote><h2 id="🍰max-、min-、abs"><a href="#🍰max-、min-、abs" class="headerlink" title="🍰max()、min()、abs()"></a>🍰max()、min()、abs()</h2><ol><li><strong>max(x,y)、min(x,y)</strong></li></ol><p>max和min分别返回x和y中的最大值和最小值，<strong>参数必须是两个，可以是浮点数</strong><br>若需要返回三个数字的最大值——max(x,max(y,z))</p><ol start="2"><li><strong>abs(x)</strong></li></ol><p>abs返回x的绝对值，<strong>x必须是整数</strong>，浮点数的绝对值需使用math头文件下的fbs</p><h2 id="🍰swap"><a href="#🍰swap" class="headerlink" title="🍰swap()"></a>🍰swap()</h2><p>swap(x,y)用来交换x和y的值</p><h2 id="🍰reverse"><a href="#🍰reverse" class="headerlink" title="🍰reverse()"></a>🍰reverse()</h2><p>reverse(it1,it2)可以将数组指针在[it1,it2)之间的元素或容器的迭代器在[it1,it2)范围内的元素进行反转</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"><span class="built_in">revserse</span>(a,a+<span class="number">4</span>);<span class="comment">//将a[0]~a[3]反转</span></span><br><span class="line"><span class="comment">//13，12，11，10，14</span></span><br></pre></td></tr></table></figure><p>也可以对容器内的元素（如string字符串）进行反转</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>()+<span class="number">2</span>,str.<span class="built_in">begin</span>()+<span class="number">6</span>);<span class="comment">//对str[2]~str[5]反转</span></span><br></pre></td></tr></table></figure><h2 id="🍰next-permutation"><a href="#🍰next-permutation" class="headerlink" title="🍰next_permutation()"></a>🍰next_permutation()</h2><p>next_permutation()给出一个序列在全排序中的下一个序列<br>当n&#x3D;3时，全排序为123，132，213，231，312，321——231的下一个排序为312</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%d%d\n&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>];</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a,a+<span class="number">3</span>));<span class="comment">//输出123的全排序</span></span><br></pre></td></tr></table></figure><h2 id="🍰fill"><a href="#🍰fill" class="headerlink" title="🍰fill()"></a>🍰fill()</h2><p>fill()可以把数组或容器中的某一区间赋为某个相同的值，和memset不同，这里的<strong>赋值可以实数组类型对应范围内的任意值</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">fill</span>(a,a+<span class="number">5</span>,<span class="number">233</span>);<span class="comment">//将a[0]~a[4]均赋值为233</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将二维数组a[n][m]全置为k</span></span><br><span class="line"><span class="built_in">fill</span>(a[<span class="number">0</span>], a[<span class="number">0</span>] + n * m, k);</span><br></pre></td></tr></table></figure><h2 id="🍰sort"><a href="#🍰sort" class="headerlink" title="🍰sort()"></a>🍰sort()</h2><blockquote><p>头文件#include<algorithm><br>using namespace std;</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(首元素地址，尾元素地址的下一个地址，比较函数（非必填）);</span><br></pre></td></tr></table></figure><ul><li>前面有具体学过，这边不多赘述</li></ul><h2 id="🍰lower-bound-和upper-bound"><a href="#🍰lower-bound-和upper-bound" class="headerlink" title="🍰lower_bound()和upper_bound()"></a>🍰lower_bound()和upper_bound()</h2><ol><li>lower_bound(first,last,val)</li></ol><p>用来寻找在数组或容器的[first,last)范围内第一个值<strong>大于等于val的元素</strong>的位置，如果是数组，则返回该位置的指针，如果是容器，返回该位置的迭代器</p><ol start="2"><li>upper_bound(first,last,val)</li></ol><p>用来寻找在数组或容器的[first,last)范围内第一个值<strong>大于val的元素</strong>的位置，如果是数组，则返回该位置的指针，如果是容器，返回该位置的迭代器<br>如果没有找到——返回可以插入该元素的位置的指针或迭代器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//寻找-1</span></span><br><span class="line"><span class="type">int</span>* lowerPos = <span class="built_in">lower_bound</span>(a,a+<span class="number">10</span>,<span class="number">-1</span>);<span class="comment">//指针！！</span></span><br><span class="line"><span class="type">int</span>* upperPos = <span class="built_in">upper_bound</span>(a,a+<span class="number">10</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,lowerPos-a,upperPos-a);<span class="comment">//0 0   //要注意减去首地址</span></span><br><span class="line"><span class="comment">//寻找3</span></span><br><span class="line"><span class="type">int</span> lowerPos = <span class="built_in">lower_bound</span>(a,a+<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> upperPos = <span class="built_in">upper_bound</span>(a,a+<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,lowerPos-a,upperPos-a);<span class="comment">//3 6</span></span><br></pre></td></tr></table></figure><p>若只想获得预查元素的下标，可以不使用临时指针，直接令返回值减去数组首地址即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">lower_bound</span>(a,a+<span class="number">10</span>,<span class="number">3</span>)-a,<span class="built_in">upper_bound</span>(a,a+<span class="number">10</span>,<span class="number">3</span>)-a;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——栈和队列</title>
      <link href="/2023/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2023/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="🎰栈和队列"><a href="#🎰栈和队列" class="headerlink" title="🎰栈和队列"></a>🎰栈和队列</h1><p><img src="https://i2.100024.xyz/2023/06/08/10mhlgn.webp#height=550&id=JiHqd&originHeight=733&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=924"></p><h2 id="🎮栈和队列的区别"><a href="#🎮栈和队列的区别" class="headerlink" title="🎮栈和队列的区别"></a>🎮栈和队列的区别</h2><h3 id="🧵队列"><a href="#🧵队列" class="headerlink" title="🧵队列"></a>🧵队列</h3><p>队列是允许在一端进行插入、另一端进行删除的线性表。队列顾名思义就像排队一样，对于进入队列的元素按<strong>“先进先出”</strong>的规则处理，<strong>在表头进行删除，在表尾进行插入</strong>。<br>由于队列要进行频繁的插入和删除，一般为了高效，选择用定长数组来存储队列元素，在队列进行操作之前要判断队列是否为空或者已满，如果想要动态长度也可以用链表来存储队列，这是要记住对头和队尾指针的地址。</p><h3 id="🧵栈"><a href="#🧵栈" class="headerlink" title="🧵栈"></a>🧵栈</h3><p>栈是只能<strong>在表尾进行插入和删除的线性表</strong>。对于插入到栈的元素按“后进先出”的规则处理，插入和删除操作都在栈顶进行，与队列类似一般用定长数组存储栈元素。<br>由于进栈和出栈都是在栈顶进行，因此要有一个size变量来记录当前栈的大小，当进栈时size不能超过数组的长度，size+1；出栈时栈不为空，size-1。</p><h2 id="🎮共享栈"><a href="#🎮共享栈" class="headerlink" title="🎮共享栈"></a>🎮共享栈</h2><p>利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将<strong>两个栈的栈底分别设置在共享空间的两端</strong>，两个栈顶向共享空间的中间延伸。<br><img src="https://s2.loli.net/2023/06/08/1nH8FTSiEJfvBdV.png#height=161&id=Mhwya&originHeight=322&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=631"><br>能够更有效的利用存储空间，两个栈的空间互相调节，只有在整个存储空间被占满时才会发生上溢</p><h2 id="🎮循环队列队空和队满的判断"><a href="#🎮循环队列队空和队满的判断" class="headerlink" title="🎮循环队列队空和队满的判断"></a>🎮循环队列队空和队满的判断</h2><ol><li>普通情况下，循环队列队空和队满的判定条件相同——Q.front&#x3D;&#x3D;Q.rear</li></ol><p>（对头指针指向第一个数；队尾指针指向最后一个数的下一个位置，即将要入队的位置）</p><ol start="2"><li><strong>方法一：牺牲一个单元来区分队空和队满</strong></li></ol><p>(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front为队满标志</p><ol start="3"><li><strong>方法二：类型中增设表示元素个数的数据成员</strong></li></ol><p>队空条件为Q.size&#x3D;&#x3D;0，队满条件为Q.size&#x3D;&#x3D;MaxSize</p><h2 id="🎮栈——括号匹配"><a href="#🎮栈——括号匹配" class="headerlink" title="🎮栈——括号匹配"></a>🎮栈——括号匹配</h2><ol><li>出现的凡是“左括号”，进栈</li><li>出现的时“右括号”——首先检查栈是否为空，若为空，则说明该“右括号”多余，否则和栈顶元素比较，若相匹配则栈顶“左括号出栈”，否则表明不匹配</li><li>表达式检验结束，若栈空，则表明表达式中匹配正确，否则表明“左括号”多余</li></ol><h2 id="🎮栈——后缀表达式求值"><a href="#🎮栈——后缀表达式求值" class="headerlink" title="🎮栈——后缀表达式求值"></a>🎮栈——后缀表达式求值</h2><h3 id="🧵表达式求值"><a href="#🧵表达式求值" class="headerlink" title="🧵表达式求值"></a>🧵表达式求值</h3><p>前缀、中缀、后缀表达式是对表达式不同记法，其区别在于<strong>运算符相对于操作数的位置不同</strong>，前缀表达式的运算符位于操作数之前，其他同理。</p><h4 id="🧶中缀表达式"><a href="#🧶中缀表达式" class="headerlink" title="🧶中缀表达式"></a>🧶中缀表达式</h4><p>计算表达式的值时，通常要将中缀表达式转换为前缀或后缀表达式，再进行求值</p><ul><li><strong>中缀表达式转换为前缀和后缀表达式</strong></li></ul><ol><li>按照运算符的优先级对所有运算单位加括号</li><li>将运算符移动到对应括号的前面（前缀表达式）或后面（后缀表达式）</li><li>去掉括号，得到前缀或后缀表达式</li></ol><p><img src="https://s2.loli.net/2023/06/08/NXAhy3jeq4Wdl8Y.png#height=230&id=eRQJa&originHeight=460&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=603"></p><h4 id="🧶后缀表达式的计算求值"><a href="#🧶后缀表达式的计算求值" class="headerlink" title="🧶后缀表达式的计算求值"></a>🧶后缀表达式的计算求值</h4><ol><li>从左至右扫描表达式</li><li>遇到数字，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们作相应的运算（次顶元素op栈顶元素），并将结果入栈</li><li>重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</li></ol><p><img src="https://s2.loli.net/2023/06/08/q4TuCIgeYQNLk2m.png#height=374&id=S1V81&originHeight=748&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=825"></p><ol><li>前缀表达式计算同理，<strong>从右往左扫描表达式</strong></li></ol><h2 id="🎮栈在递归中的应用"><a href="#🎮栈在递归中的应用" class="headerlink" title="🎮栈在递归中的应用"></a>🎮栈在递归中的应用</h2><h3 id="🧵递归"><a href="#🧵递归" class="headerlink" title="🧵递归"></a>🧵递归</h3><p>递归是一种重要的程序设计方法。简单的说，若在一个函数、过程或数据结构的定义中<strong>应用了它自身</strong>，则这个函数、过程或数据结构称为是递归定义的，简称递归。<br>递归通常把一个大型的复杂问题层层转化为一个与同问题相似的规模较小的问题来求解，递归策略只需要少量代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。<br>将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。</p><h2 id="🎮队列在层次遍历中的应用"><a href="#🎮队列在层次遍历中的应用" class="headerlink" title="🎮队列在层次遍历中的应用"></a>🎮队列在层次遍历中的应用</h2><p>在信息处理中，有一大类问题需要逐层或逐行进行处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行进行预处理，把处理顺序安排好，待当前层或当前层处理完毕，就可以处理下一层或下一行。<br>使用队列是为了保存下一步的处理顺序。</p><h2 id="🎮队列在计算机系统中的应用"><a href="#🎮队列在计算机系统中的应用" class="headerlink" title="🎮队列在计算机系统中的应用"></a>🎮队列在计算机系统中的应用</h2><p>队列在计算机系统中的应用非常广泛，以下仅从两个方面来简述队列在计算机系统中的作用：<br>第一个方面是<strong>解决主机与外部设备之间速度不匹配的问题</strong>；<br>第二个方面是<strong>解决由多用户引起的资源竞争问题</strong>。</p><ol><li>对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，由于速度不匹配，若直接把输出的数据送给打印机打印显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。</li><li>对于第二个方面，CPU（即中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU能够正常运行。</li></ol><h2 id="🎮矩阵的压缩存储"><a href="#🎮矩阵的压缩存储" class="headerlink" title="🎮矩阵的压缩存储"></a>🎮矩阵的压缩存储</h2><p>在数据结构中，提供针对某些特殊矩阵的压缩存储结构。</p><ul><li>含有大量相同数据元素的矩阵：对称矩阵（使用一维数组存储）</li><li>含有大量0元素的矩阵：稀疏矩阵、上下三角矩阵（同时存储该元素所在矩阵中的行标和列标，以及其数据元素）</li></ul><p>存储思想：矩阵中的相同数据元素（包括元素0）只存储一个。</p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课程总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——数学问题</title>
      <link href="/2023/05/22/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/22/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="🍻简单数学"><a href="#🍻简单数学" class="headerlink" title="🍻简单数学"></a>🍻简单数学</h1><h2 id="🍟西西弗斯串"><a href="#🍟西西弗斯串" class="headerlink" title="🍟西西弗斯串"></a>🍟西西弗斯串</h2><p>对任意一个数字串，求出它数位上的偶数个数、奇数个数、数位总数，然后拼接起来得到一个新的数字串（不需要去掉前导零），接着对这个新的数字串同样执行上面的步骤，最终一定会得到123，也就是著名的西西弗斯串。<br>现有一个数字串，可以对它执行零或正数次上面的步骤，请计算至少需要多少次可以得到西西弗斯串。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string nums;</span><br><span class="line">    cin&gt;&gt;nums;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(nums!=<span class="string">&quot;123&quot;</span>)&#123;</span><br><span class="line">        <span class="type">int</span> odd=<span class="number">0</span>,ji=<span class="number">0</span>,all=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">2</span>==<span class="number">0</span>)odd++;</span><br><span class="line">        &#125;</span><br><span class="line">        all=length;ji=all-odd;</span><br><span class="line">        nums=<span class="built_in">to_string</span>(odd)+<span class="built_in">to_string</span>(ji)+<span class="built_in">to_string</span>(all);</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重点：读入字符串，转为整形int进行讨论，再用to_string转为字符形式</li></ul><h1 id="🍻最大公约数与最小公倍数"><a href="#🍻最大公约数与最小公倍数" class="headerlink" title="🍻最大公约数与最小公倍数"></a>🍻最大公约数与最小公倍数</h1><h2 id="🍟最大公倍数"><a href="#🍟最大公倍数" class="headerlink" title="🍟最大公倍数"></a>🍟最大公倍数</h2><p>一般用gcd(a,b)来表示a和b的最大公约数，而求解得到最大公约数常用欧几里得算法——<strong>辗转相除法</strong></p><ul><li><strong>欧几里得算法定理</strong>——设a、b均为正整数，则gcd(a,b)&#x3D;gcd(b,a%b)</li></ul><p>递归进行</p><ol><li>递归式：gcd(a,b)&#x3D;gcd(b,a%b)</li><li>递归边界：gcd(a,0)&#x3D;a<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="🍟最小公倍数"><a href="#🍟最小公倍数" class="headerlink" title="🍟最小公倍数"></a>🍟最小公倍数</h2><p>一般用lcm(a,b)来表示a和b的最小公倍数。最小公倍数的求解是在最大公约数的基础上进行的，当得到a和b的最大公约数d之后，可以马上得到a和b的最小公倍数是<strong>ab&#x2F;d</strong></p><ul><li><strong>由于ab在实际计算时有可能会溢出，因此更恰当的写法是a &#x2F; d * b</strong></li></ul><h1 id="🍻分数的四则运算"><a href="#🍻分数的四则运算" class="headerlink" title="🍻分数的四则运算"></a>🍻分数的四则运算</h1><h2 id="🍟分数的表示和简化"><a href="#🍟分数的表示和简化" class="headerlink" title="🍟分数的表示和简化"></a>🍟分数的表示和简化</h2><h3 id="🍭分数的表达"><a href="#🍭分数的表达" class="headerlink" title="🍭分数的表达"></a>🍭分数的表达</h3><p>假分数的形式，即无论分子比分母大或者小，都保留其原数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体来存储</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fraction</span>&#123;<span class="comment">//分数</span></span><br><span class="line"><span class="type">int</span> up,down;<span class="comment">//分子，分母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使down为非负数。若分数为负，则令分子up为负即可</li><li>如果该分数恰为0，那么规定其分母为1，分子为0</li><li>分子和分母没有除了1以外的公约数</li></ol><h3 id="🍭分数的简化"><a href="#🍭分数的简化" class="headerlink" title="🍭分数的简化"></a>🍭分数的简化</h3><p>用来使Fraction变量满足分数表示的三项规定：</p><ol><li>如果分母down为负数，那么令分子up和分母down都变为相反数</li><li>如果分子up为0，那么令分母down为1</li><li>约分：求出分子绝对值与分母绝对值的最大公约数d，分子分母同除d<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.down&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        result.up=-reuslt.up;</span><br><span class="line">        result.down=-result.down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.up==<span class="number">0</span>)&#123;</span><br><span class="line">        result.down = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//绝对值不能忘！</span></span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(result.up),<span class="built_in">abd</span>(result.down));</span><br><span class="line">        result.up/=d;</span><br><span class="line">        result.down/=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="🍟分数的四则运算"><a href="#🍟分数的四则运算" class="headerlink" title="🍟分数的四则运算"></a>🍟分数的四则运算</h2><h3 id="🍭分数的加法"><a href="#🍭分数的加法" class="headerlink" title="🍭分数的加法"></a>🍭分数的加法</h3><p>对于两个分数f1和f2，其加法计算公式为<br>$\text { result }&#x3D;\frac{f 1 . u p * f 2 . d o w n+f 2 . u p * f 1 . d o w n}{f 1 . \text { down } * f 2 . \text { down }}$</p><h3 id="🍭分数的减法"><a href="#🍭分数的减法" class="headerlink" title="🍭分数的减法"></a>🍭分数的减法</h3><p>对于两个分数f1和f2，其减法计算公式为<br>$\text { result }&#x3D;\frac{f 1 . u p * f 2 . d o w n-f 2 . u p * f 1 . d o w n}{f 1 . \text { down } * f 2 . \text { down }}$</p><h3 id="🍭分数的乘法"><a href="#🍭分数的乘法" class="headerlink" title="🍭分数的乘法"></a>🍭分数的乘法</h3><p>对于两个分数f1和f2，其乘法计算公式为<br>$\text { result }&#x3D;\frac{f 1 . u p * f 2 . u p }{f 1 . \text { down } * f 2 . \text { down }}$</p><h3 id="🍭分数的除法"><a href="#🍭分数的除法" class="headerlink" title="🍭分数的除法"></a>🍭分数的除法</h3><p>对于两个分数f1和f2，其除法计算公式为<br>$\text { result }&#x3D;\frac{f 1 . u p * f 2 . down }{f 1 . \text { down } * f 2 . \text { up }}$</p><ul><li>除法需要注意的是f2.up需要判断是否为0，只有除数不为0时，才能用上面的公式；其余只需定义函数按照公式进行计算即可（return之前注意进行分数的简化）。</li></ul><h2 id="🍟分数的输出"><a href="#🍟分数的输出" class="headerlink" title="🍟分数的输出"></a>🍟分数的输出</h2><ol><li>输出分数前，需要先对其进行简化</li><li>如果分数r的分母down为1，则说明该分数为<strong>整数</strong>，通常直接输出</li><li>如果分数r的分子up的绝对值大于分母down，说明该分数为假分数，应按带分数的形式输出，整数部分为r.up&#x2F;r.down，分子部分为abs(r.up)%r.down</li></ol><p><strong>注意：</strong>由于分数的乘法和除法的过程中可能使分子或分母超过int型，因此分子和分母应使用<strong>long long型</strong>存储</p><h1 id="🍻素数"><a href="#🍻素数" class="headerlink" title="🍻素数"></a>🍻素数</h1><p>素数又称为质数，是指除了1和本身之外，不能被其他数整除的一类数。</p><ul><li>对给定的正整数n，如果对任何正整数a(1&lt;a&lt;n)，都有n%a!&#x3D;0，那么称n是素数；否则如果存在a(1&lt;a&lt;n)，使得n%a&#x3D;&#x3D;0，那么称n为合数</li><li><strong>1既不是素数也不是合数</strong></li></ul><h2 id="🍟素数的判断"><a href="#🍟素数的判断" class="headerlink" title="🍟素数的判断"></a>🍟素数的判断</h2><p>一个整数n要被判断为素数，需要判断n是否能被2,3,4….n-1中的一个整除，都不能整除才是素数。——复杂度很高<br>如果2~n-1中存在n的约数，假设为k，即n%k&#x3D;0，由k*(n&#x2F;k)&#x3D;&#x3D;n可知，n&#x2F;k也是n的一个约数，且k与n&#x2F;k中一定可满足一个小于等于sqrt(n)，一个大于等于sqrt(n)——<strong>判定n是否能被2,3,…sqrt(n)(向下取整)整除</strong></p><blockquote><p>sqrt的参数要求为浮点数——n*1.0</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//特判</span></span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//n是i的倍数，则n不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍟素数表的获取"><a href="#🍟素数表的获取" class="headerlink" title="🍟素数表的获取"></a>🍟素数表的获取</h2><p>打印1~n范围内的素数表的方法——从1到n进行枚举，判断每个数是否为素数，如果是素数则加入素数表</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">101</span>;<span class="comment">//表长</span></span><br><span class="line"><span class="type">int</span> prime[maxn],pNum=<span class="number">0</span>;<span class="comment">//prime数组存放所有的素数，pNum为素数的个数</span></span><br><span class="line"><span class="type">bool</span> p[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//p[i]==true表示i是素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(i==<span class="literal">true</span>))&#123;</span><br><span class="line">            prime[pNum++]=i;</span><br><span class="line">            p[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度为O(n√n)</li></ul><p>“埃式筛法”——算法从小到大枚举所有的数字，对每一个素数，筛去它所有的倍数，剩下的就是素数。<br>“筛”这个动作的实现可以使用一个bool型的数组p来标记，如果a被筛掉，那么p[a]&#x3D;true，否则p[a]&#x3D;false，可初始化p全为false</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">101</span>;<span class="comment">//表长</span></span><br><span class="line"><span class="type">int</span> prime[maxn],pNum=<span class="number">0</span>;<span class="comment">//prime数组存放所有的素数，pNum为素数的个数</span></span><br><span class="line"><span class="type">bool</span> p[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//p[i]==true表示i是素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[pNum++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;maxn;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度O(nloglogn)</li></ul><h1 id="🍻质因子分解"><a href="#🍻质因子分解" class="headerlink" title="🍻质因子分解"></a>🍻质因子分解</h1><p>质因子分解是指将一个正整数n写成一个或多个质数的乘积形式<br>由于每个质因子都可以不止出现一次，因此可以使用结构体factor用来存放质因子及其个数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">factor</span>&#123;</span><br><span class="line"><span class="type">int</span> x,cnt;<span class="comment">//x为质因子，cnt为其个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ol><li>枚举1~sqrt(n)范围内的所有质因子p，判断p是否为n的因子<ol><li><p>如果p是n的因子，那么给fac数组中增加质因子p，并初始化其个数为0。若p还是n的因子，则n不断除p，每次操作令p的个数+1，知道p不是n的因子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">    fac[num].x=prime[i];</span><br><span class="line">    fac[num].cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">        fac[num].cnt++;</span><br><span class="line">        n/=prime[i];</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果p不是n的因子，则直接跳过</p></li></ol></li><li>在步骤1后，n仍然大于1，说明n有且仅有一个大于sqrt(n)的质因子，把这个质因子加入fac，并个数为1<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">    fun[num].x=n;</span><br><span class="line">    fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="🍻大整数运算"><a href="#🍻大整数运算" class="headerlink" title="🍻大整数运算"></a>🍻大整数运算</h1><h2 id="🍟大整数的存储"><a href="#🍟大整数的存储" class="headerlink" title="🍟大整数的存储"></a>🍟大整数的存储</h2><p>用数组即可，数组中的每一位就代表了存放的整数的每一位，<strong>整数的高位存储在数组的高位，整数的地位存储在数组的地位</strong><br><strong>注意：</strong>把整数按字符串%s读入的时候，实际上是逆位存储的，在读入之后需要在另存为至d[]数组的时候反转一下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span>&#123;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> len;<span class="comment">//大整数的长度</span></span><br><span class="line"><span class="built_in">bign</span>()&#123;<span class="comment">//初始化结构体</span></span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>读入大整数：</strong>先用字符串读入，然后再把字符串另存至bign结构体（！逆着赋值）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;<span class="comment">//把整数转换为bign</span></span><br><span class="line">    bign a;</span><br><span class="line">    a.len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        a.d[i] = str[a.len-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较两个bign变量的大小：</strong>先判断两个数字的len大小，如果不相等，则以长的为大；如果相等，则从高位到地位进行比较，直到某一位不等</p><h2 id="🍟大整数的四则运算"><a href="#🍟大整数的四则运算" class="headerlink" title="🍟大整数的四则运算"></a>🍟大整数的四则运算</h2><h3 id="🍭高精度加法"><a href="#🍭高精度加法" class="headerlink" title="🍭高精度加法"></a>🍭高精度加法</h3><p>算法思路：将该位上的两个数字与进位，得到的结果取个位数作为该位的结果，取十位数作为新的进位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;<span class="comment">//以较长的为界限</span></span><br><span class="line">        <span class="type">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">        a.d[c.len++] = temp%<span class="number">10</span>;<span class="comment">//个位数为该位结果</span></span><br><span class="line">        carry = temp/<span class="number">10</span>;<span class="comment">//十位数为新的进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;<span class="comment">//如果最后进位不为0，则直接赋给结果的最高位</span></span><br><span class="line">        c.d[c.len++]=carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍭高精度减法"><a href="#🍭高精度减法" class="headerlink" title="🍭高精度减法"></a>🍭高精度减法</h3><p>算法思路：对每一步，比较被减位和减位，如果不够减，则令被减位的高位减1、被减位加10再进行减位；如果够减，则直接减。最后一步要注意减法后高位可能有多与的0，要去除它们，但也要保证结果至少有一位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;<span class="comment">//以较长的为界限</span></span><br><span class="line">        <span class="keyword">if</span>(a.d[i]&lt;b.d[i])&#123;<span class="comment">//不够减</span></span><br><span class="line">            a.d[i+<span class="number">1</span>]--;</span><br><span class="line">            a.d[i]+=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.d[c.len++]=a.d[i]-b.d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;<span class="comment">//去除高位的0，同时至少保留一位最低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用sub函数前需要比较两个数的大小，如果被减数小于减数，需要交换两个变量然后输出-，然后再使用sub函数</li></ul><h3 id="🍭高精度与低精度的乘法"><a href="#🍭高精度与低精度的乘法" class="headerlink" title="🍭高精度与低精度的乘法"></a>🍭高精度与低精度的乘法</h3><p>——bign型和int类型的乘法，需要把int型的数字看作一个整体<br>算法思路：取bign的某位与int型整体相乘，再与进位相加，所得结果的个位数作为该位的结果，高位作为新的进位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = a.d[i]*b+carry;</span><br><span class="line">        c.d[c.len++] = temp%<span class="number">10</span>;</span><br><span class="line">        carry = temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry!=<span class="number">0</span>)&#123;<span class="comment">//最后进位</span></span><br><span class="line">        c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">        carry/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🍭高精度与低精度的除法"><a href="#🍭高精度与低精度的除法" class="headerlink" title="🍭高精度与低精度的除法"></a>🍭高精度与低精度的除法</h3><p>上一步的余数乘以10加上该步的位，得到该步临时的被除数，将其与除数相比较；如果不够除，则该位的商为0；如果够除，则商即为对应的余数。最后一步要注意减法后的高位可能有多余的0，要去除他们，但也要保证结果至少由一位数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span><span class="comment">//r为余数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len=a.len;<span class="comment">//被除数的每一位和商的每一位是对应的，长度相等</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从高位开始</span></span><br><span class="line">        r=r*<span class="number">10</span>+a.d[i];<span class="comment">//和上一位遗留的余数组合</span></span><br><span class="line">        <span class="keyword">if</span>(r&lt;b)c.d[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c.d[i]=r/b;</span><br><span class="line">            r=r%b;<span class="comment">//新的余数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以把r设置为全局变量——r则是最后除法的余数（<strong>引用</strong>的作用：在函数中可以视作对原变量进行修改，而不像普通函数参数那样，在函数中的修改不影响原变量的值）</p><h1 id="🍻组合数"><a href="#🍻组合数" class="headerlink" title="🍻组合数"></a>🍻组合数</h1><h2 id="🍟关于n！的一个问题"><a href="#🍟关于n！的一个问题" class="headerlink" title="🍟关于n！的一个问题"></a>🍟关于n！的一个问题</h2><p>n!表示n的阶乘——<strong>求n!中有多少个质因子p</strong><br>举个例子：6!&#x3D;1×2×3×4×5×6——6!中有4个质因子2，有2个质因子3<br>最简单的求法：遍历1~n的每个数中各有多少个质因子p，然后将结果相加</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算n！中有多少个质因子p</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度太大O(nlogn)<blockquote><p>方法一</p></blockquote></li></ul><p>现在考虑10!中的质因子2的个数，10!中有质因子21的个数为5，22的个数为2，23的个数为1，则可以进行推广：<br>n!中有$\left(\frac{\mathrm{n}}{\mathrm{p}}+\frac{\mathrm{n}}{\mathrm{p}^{2}}+\frac{\mathrm{n}}{\mathrm{p}^{3}}+\cdots\right)$个质因子p，其中除法均向下取整——复杂度O(logn)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        ans+=n/p;</span><br><span class="line">        n/=p;<span class="comment">//相当于分母再多乘一个p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个算法还可以快速计算出n!的末尾有多少个0——相当于n中有多少个10的质因子，这又等于n中有多少个质因子5的个数，带入求cal(n,5)即可</p><blockquote><p>方法二</p></blockquote><p>以10!中质因子2的个数为例，对10!进行推导如下所示：<br>$\begin{aligned}<br>10 ! &amp; &#x3D;1 \times 2 \times 3 \times 4 \times 5 \times 6 \times 7 \times 8 \times 9 \times 10 \<br>&amp; &#x3D;2 \times 4 \times 6 \times 8 \times 10 \times \underline{1 \times 3 \times 5 \times 7 \times 9} \<br>&amp; &#x3D;2^{5} \times 1 \times 2 \times 3 \times 4 \times 5 \times \underline{1 \times 3 \times 5 \times 7 \times 9} \<br>&amp; &#x3D;2^{5} \times 5 ! \times 1 \times 3 \times 5 \times 7 \times 9<br>\end{aligned}$<br>可以推广到一般情况：<strong>n!中质因子p的个数，实际上等于1~n中p的倍数的个数n&#x2F;p，加上n&#x2F;p!中质因子p的个数</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算n!中有多少个质因子p</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;p)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//当n&lt;p 1~n不可能有质因子p</span></span><br><span class="line">    <span class="keyword">return</span> n / p + <span class="built_in">cal</span>( n/p , p );<span class="comment">//递归写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍟组合数的计算"><a href="#🍟组合数的计算" class="headerlink" title="🍟组合数的计算"></a>🍟组合数的计算</h2><p>组合数$C_{n}^{m}$是指从n个元素中选出m个元素的方案数（m≤n），一般也可以写成C(n,m)，定义式为$C_{n}^{m}&#x3D;\frac{n !}{m !(n-m) !}$，由三个整数的阶乘得到。组合数满足$C_{n}^{m}&#x3D;C_{n}^{n-m}$，且$C_{n}^{0}&#x3D;C_{n}^{n}&#x3D;1$</p><h3 id="🍭计算-C-n-m"><a href="#🍭计算-C-n-m" class="headerlink" title="🍭计算$C_{n}^{m}$"></a>🍭计算$C_{n}^{m}$</h3><ol><li><strong>通过定义式直接计算</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;n-m;i++)&#123;</span><br><span class="line">        ans/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>太容易溢出了</li></ul><ol start="2"><li><strong>通过递推公式计算</strong></li></ol><p>递推公式$C_{n}^{m}&#x3D;C_{n-1}^{m}+C_{n-1}^{m-1}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||m==n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">C</span>(n<span class="number">-1</span>,m)+<span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于可能会出现很多重复计算，因此可以把计算过的组合数记录下来</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> res[<span class="number">67</span>][<span class="number">67</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||m==n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>)<span class="keyword">return</span> res[n][m];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res[n][m]=<span class="built_in">C</span>(n<span class="number">-1</span>,m)+<span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以把整张表都计算出来，利用递推公式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;<span class="comment">//初始化边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            res[i][j]=res[i<span class="number">-1</span>,j]+res[i<span class="number">-1</span>,j<span class="number">-1</span>];</span><br><span class="line">            res[i][i-j]=res[i][j];<span class="comment">//C(i,i-j)=C(i,j)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>通过定义式的变形来计算</strong></li></ol><p>（没太看懂——见书P185）</p><h3 id="🍭计算-C-n-m-p"><a href="#🍭计算-C-n-m-p" class="headerlink" title="🍭计算$C_{n}^{m}%p$"></a>🍭计算$C_{n}^{m}%p$</h3><p>让运算结果对一个正整数p取模</p><ol><li><strong>通过递推公式计算</strong></li></ol><p>在原先的代码中对p进行取模即可<br><strong>递归</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> res[<span class="number">1010</span>][<span class="number">1010</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||m==n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>)<span class="keyword">return</span> res[n][m];</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (res[n][m]=<span class="built_in">C</span>(n<span class="number">-1</span>,m)+<span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>))%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递推</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;<span class="comment">//初始化边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            res[i][j]=(res[i<span class="number">-1</span>,j]+res[i<span class="number">-1</span>,j<span class="number">-1</span>])%p;</span><br><span class="line">            res[i][i-j]=res[i][j];<span class="comment">//C(i,i-j)=C(i,j)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程课程总结</title>
      <link href="/2023/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"/>
      <url>/2023/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="🍒01章-软件工程学概述"><a href="#🍒01章-软件工程学概述" class="headerlink" title="🍒01章 软件工程学概述"></a>🍒01章 软件工程学概述</h1><h4 id="软件的定义："><a href="#软件的定义：" class="headerlink" title="软件的定义："></a>软件的定义：</h4><p>软件是多种术语和对象的集合，并将这些术语和对象有效地配置在一起。软件包括三个组成部分——<strong>程序、文档和数据</strong><br>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><h4 id="软件的特点："><a href="#软件的特点：" class="headerlink" title="软件的特点："></a>软件的特点：</h4><ol><li>软件是被工程化的逻辑系统</li><li>软件一般没有磨损</li><li>软件具有不同于一般实物系统的复杂性</li></ol><h4 id="软件危机定义："><a href="#软件危机定义：" class="headerlink" title="软件危机定义："></a>软件危机定义：</h4><p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。这些问题不是在解决具体问题时遇到的，而是软件开发过程中所面临的具有<strong>普适性的问题</strong>。<br>软件危机的典型表现：概括的来说，<strong>开发周期长、成本高、质量差、适应性差和难以维护</strong></p><h4 id="软件工程方法学三要素："><a href="#软件工程方法学三要素：" class="headerlink" title="软件工程方法学三要素："></a>软件工程方法学三要素：</h4><p>软件工程的三个基本要素：<strong>方法、工具和过程</strong></p><ol><li><strong>过程：</strong>规定了完成各项任务的过程</li></ol><p>为了获得高质量软件所需要完成的一系列任务的<strong>框架</strong>，规定了完成各项任务的<br>工作步骤。</p><ol start="2"><li><strong>方法：</strong>完成软件开发的各项任务的技术方法，回答“怎样做”的问题</li><li><strong>工具：</strong>（为运用方法而提供的自动的或半自动的）软件工程的支撑环境</li></ol><p>目前使用最广泛的软件工程方法学，分别是<strong>传统方法学</strong>和<strong>面向对象方法学</strong></p><h4 id="软件生命周期各阶段定义："><a href="#软件生命周期各阶段定义：" class="headerlink" title="软件生命周期各阶段定义："></a>软件生命周期各阶段定义：</h4><p>三个时期：<strong>软件定义、软件开发和运行维护（软件维护）</strong></p><ol><li><strong>软件定义：问题定义、可行性研究和需求分析</strong></li></ol><p>软件定义时期的任务是：</p><ol><li>确定软件开发工程必须完成的总目标；</li><li>确定工程的可行性；</li><li>导出实现工程目标应该采用的策略及系统必须完成的功能；</li><li>估计完成该项工程需要的资源和成本，并且制定工程进度表。</li></ol><p>这个时期的工作通常又称为系统分析，由系统分析员负责完成。</p><ol start="2"><li><strong>软件开发：总体设计、详细设计、编码和单元测试、综合测试</strong>（前两个为系统设计，后两个为系统实现）</li></ol><p>开发时期具体设计和实现在前一个时期定义的软件</p><ol start="3"><li><strong>软件维护：</strong>主要任务是使软件持久地满足用户的需要</li></ol><h4 id="Scrum模型的框架图："><a href="#Scrum模型的框架图：" class="headerlink" title="Scrum模型的框架图："></a>Scrum模型的框架图：</h4><p>Scrum 是一个轻量级的项目管理的框架，它的核心在于迭代。<br><img src="https://s1.ax1x.com/2023/05/16/p92yWAH.png#height=324&id=N4BMo&originHeight=648&originWidth=1152&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=576"></p><h4 id="Scrum三大特点："><a href="#Scrum三大特点：" class="headerlink" title="Scrum三大特点："></a>Scrum三大特点：</h4><ol><li>关注当下——“可能性的”艺术</li><li>放权——团队自组织、自管理</li><li>提高沟通效率——面对面沟通</li></ol><h4 id="Scrum团队模型的三种角色："><a href="#Scrum团队模型的三种角色：" class="headerlink" title="Scrum团队模型的三种角色："></a>Scrum团队模型的三种角色：</h4><ol><li>Scrum Master——不要管理团队</li><li>Product Owner</li><li>团队</li></ol><p><img src="https://s1.ax1x.com/2023/05/13/p96rlLj.png#height=327&id=wJKbc&originHeight=654&originWidth=1398&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=699"></p><h1 id="🍒02章-可行性研究"><a href="#🍒02章-可行性研究" class="headerlink" title="🍒02章 可行性研究"></a>🍒02章 可行性研究</h1><h4 id="可行性分析定义："><a href="#可行性分析定义：" class="headerlink" title="可行性分析定义："></a>可行性分析定义：</h4><p>对需求内容进行初步的分析，确定解决问题的可能性，分析不同解决方案的优劣，并提出建议。其本质实际上就是一个粗略的系统分析和设计过程，通常由客户完成。<br>可行性研究的目的，就是用<strong>最小的代价</strong>在<strong>尽可能短的时间</strong>内确定问题是否能够解决<br>可行性研究的类型：</p><ol><li>研究型项目的可行性研究分析</li><li>委托型可行性研究分析</li><li>自主开发型可行性研究分析</li></ol><p>可行性研究分析过程：</p><ol><li>首先，进一步分析和澄清<strong>问题定义</strong></li><li>然后，分析员应该导出系统的<strong>逻辑模型</strong></li><li>最后，探索若干可供选择的<strong>主要解法</strong></li></ol><h4 id="可行性分析三个方面："><a href="#可行性分析三个方面：" class="headerlink" title="可行性分析三个方面："></a>可行性分析三个方面：</h4><ol><li>技术可行性</li><li>经济可行性</li><li>操作可行性</li></ol><p>技术可行性——使用现有的技术能实现这个系统吗?<br>经济可行性——这个系统的经济效益能超过它的开发成本吗?<br>操作可行性——系统的操作方式在这个用户组织内行得通吗?</p><h1 id="🍒03章-需求分析"><a href="#🍒03章-需求分析" class="headerlink" title="🍒03章 需求分析"></a>🍒03章 需求分析</h1><h4 id="需求分析定义："><a href="#需求分析定义：" class="headerlink" title="需求分析定义："></a>需求分析定义：</h4><p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答”系统必须做什么“这个问题。<br>需求分析的任务就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统“做什么”的问题。</p><h4 id="需求分析（面向过程）需要建立的三类模型："><a href="#需求分析（面向过程）需要建立的三类模型：" class="headerlink" title="需求分析（面向过程）需要建立的三类模型："></a>需求分析（面向过程）需要建立的三类模型：</h4><ol><li><strong>数据模型</strong>：主要采用实体联系图ERD图描述，描述数据对象及数据对象之间的关系</li><li><strong>功能模型</strong>：主要采用数据流图描述，描述当数据在软件系统中移动时被变换的逻辑过程，指明系统具有的变换数据的功能</li><li><strong>行为模型</strong>：采用状态转换图，指明了作为外部事件结果的系统行为。为此，状态转换图描述了系统各种行为模式（状态）和在不同状态间转换的方式</li></ol><h4 id="实体联系图定义："><a href="#实体联系图定义：" class="headerlink" title="实体联系图定义："></a>实体联系图定义：</h4><p>ER实体联系图，描述数据对象及数据对象之间的关系，是用于建立数据模型的图形<br>数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系</p><h4 id="数据流图定义："><a href="#数据流图定义：" class="headerlink" title="数据流图定义："></a>数据流图定义：</h4><p><strong>数据流图（DFD）</strong>是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。<br>数据流图是建立功能模型的基础<br>数据流图让软件工程师能够建模同时建模信息模型和功能模型。</p><h4 id="加油站-x2F-数据流图："><a href="#加油站-x2F-数据流图：" class="headerlink" title="加油站&#x2F;数据流图："></a>加油站&#x2F;数据流图：</h4><p>0层：<br><img src="https://s1.ax1x.com/2023/05/13/p96c5gf.png#height=141&id=J84Ho&originHeight=282&originWidth=1147&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574"><br>1层：<br><img src="https://s1.ax1x.com/2023/05/13/p96c48P.png#height=304&id=XPhm2&originHeight=607&originWidth=1192&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=596"><br>2层：<br><img src="https://s1.ax1x.com/2023/05/13/p96cIv8.png#height=364&id=IZ83a&originHeight=727&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=693"><br>3层：<br><img src="https://s1.ax1x.com/2023/05/13/p96chCt.png#height=387&id=CaN22&originHeight=773&originWidth=1373&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=687"></p><h4 id="登录-x2F-状态转换图："><a href="#登录-x2F-状态转换图：" class="headerlink" title="登录&#x2F;状态转换图："></a>登录&#x2F;状态转换图：</h4><p>密码验证状态转换图<br><img src="https://s1.ax1x.com/2023/05/13/p96WurT.png#id=F2nKx&originHeight=519&originWidth=838&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍒05章-总体设计"><a href="#🍒05章-总体设计" class="headerlink" title="🍒05章 总体设计"></a>🍒05章 总体设计</h1><h4 id="总体设计定义："><a href="#总体设计定义：" class="headerlink" title="总体设计定义："></a>总体设计定义：</h4><p>总体设计的基本目的就是回答”概括地说，系统应该如何实现“这个问题，又叫<strong>概要设计</strong>、<strong>初步设计</strong><br>总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系</p><h4 id="模块的三个基本要素："><a href="#模块的三个基本要素：" class="headerlink" title="模块的三个基本要素："></a>模块的三个基本要素：</h4><ol><li><strong>功能</strong>：描述该模块实现什么功能</li><li><strong>逻辑</strong>：描述模块内部该怎么做</li><li><strong>状态</strong>：该模块使用时的环境和条件</li></ol><p><strong>模块化</strong>是为了使一个复杂的大型程序能被人的智力所管理，<strong>是软件应该具备的唯一属性</strong></p><h4 id="信息隐藏："><a href="#信息隐藏：" class="headerlink" title="信息隐藏："></a>信息隐藏：</h4><p>应该这样设计和确定模块，使得一个模块内包含的信息（过程、数据）对于不需要这些信息的模块来说，是不能访问的<br>每个模块的实现细节对于其他模块来说是隐蔽的，也就是说，模块中所包含的信息（包括数据和过程）不允许其他不需要这些信息的模块使用</p><h4 id="模块独立性："><a href="#模块独立性：" class="headerlink" title="模块独立性："></a>模块独立性：</h4><p>模块的独立程度可以由两个定性标准度量，这两个标准分别为：<strong>内聚和耦合</strong><br><strong>模块独立性</strong>，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他模块的接口是简单的<br><strong>耦合</strong>，是模块之间的互相连接的紧密程度的度量(非数标控外公内)<br><img src="https://s1.ax1x.com/2023/05/14/p9cYjAS.png#height=144&id=bWIbT&originHeight=288&originWidth=805&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=403"><br><strong>内聚</strong>，标志一个模块内各个元素彼此结合的紧密程度（功信通过时逻巧）<br><img src="https://s1.ax1x.com/2023/05/14/p9cYO78.png#height=144&id=jcZ9T&originHeight=288&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=410"><br>模块独立性的重要原因：</p><ol><li>有效的模块化（即具有独立的模块）的软件比较容易开发出来</li><li>独立的模块比较容易测试和维护</li></ol><h4 id="作用域、控制域："><a href="#作用域、控制域：" class="headerlink" title="作用域、控制域："></a>作用域、控制域：</h4><p><strong>模块的作用域应该在控制域之内</strong><br><strong>作用域</strong>：受该模块内一个判定影响的所有模块的集合<br><strong>控制域</strong>：模块本身以及所有直接或间接从属与它的模块的集合</p><h4 id="总体设计原则："><a href="#总体设计原则：" class="headerlink" title="总体设计原则："></a>总体设计原则：</h4><p>（莫愁逐藏巨毒）</p><ol><li>模块化</li><li>抽象</li><li>逐步求精</li><li>信息隐藏和局部化</li><li>模块独立</li></ol><h4 id="变换流，事务流定义："><a href="#变换流，事务流定义：" class="headerlink" title="变换流，事务流定义："></a>变换流，事务流定义：</h4><p>面向数据流的式设计方法把信息流映射成软件结构，信息流的类型决定了映射方法。<br><strong>变换流</strong>：信息沿输入通路进入系统，由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫做变换流<br><strong>事务流</strong>：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类数据流应该划分为一类特殊的数据流，称为事务流<br>T称为事务中心，它完成下述任务：接收输入数据（输入数据又称为事务）；分析每个事务以确定它的类型；根据事务类型选取一条活动通路</p><h4 id="格式化123-x2F-软件结构图："><a href="#格式化123-x2F-软件结构图：" class="headerlink" title="格式化123&#x2F;软件结构图："></a>格式化123&#x2F;软件结构图：</h4><p><img src="https://s1.ax1x.com/2023/05/13/p96RTKK.png#height=404&id=TG027&originHeight=808&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=675"></p><h1 id="🍒06章-详细设计"><a href="#🍒06章-详细设计" class="headerlink" title="🍒06章 详细设计"></a>🍒06章 详细设计</h1><h4 id="详细设计定义："><a href="#详细设计定义：" class="headerlink" title="详细设计定义："></a>详细设计定义：</h4><p>根本目标：确定应该怎样具体地实现所要求的系统。详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。<br>详细设计的结果基本上决定了最终的程序代码的质量。</p><ol><li>确定软件各个组成部分内的算法以及各部分的内部数据结构</li><li>选定某种过程的表达形式来描述各种算法</li><li>进行详细设计的评审</li></ol><h4 id="结构化程序的三种基本控制结构："><a href="#结构化程序的三种基本控制结构：" class="headerlink" title="结构化程序的三种基本控制结构："></a>结构化程序的三种基本控制结构：</h4><p>顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这3种基本控制结构，则称为<strong>经典的结构程序设计</strong></p><ol><li>顺序</li><li>选择</li><li>循环</li></ol><h1 id="🍒07章-实现"><a href="#🍒07章-实现" class="headerlink" title="🍒07章 实现"></a>🍒07章 实现</h1><h4 id="软件测试的原则："><a href="#软件测试的原则：" class="headerlink" title="软件测试的原则："></a>软件测试的原则：</h4><p>（需前 P小 穷三 早两 合检妥）</p><ol><li>所有测试都应该能追溯到用户需求</li><li>应该远在测试之前就制定出测试计划</li><li>把Pareto原理应用到软件测试中（测试存在群集现象）</li><li>该从“小规模”测试开始，并逐步进行“大规模”的测试</li><li>穷举测试是不可能的</li><li>为了达到最佳测试效果，应该由独立的第三方从事测试工作</li><li>应当把“尽早地和不断地进行软件测试”作为软件开发者的座右铭</li><li>测试用例应由测试输入数据和对应的预计输出结果这两部分组成</li><li>在设计测试用例时，应当包括合理的输入条件和不合理的输入条件</li><li>应当对每个测试结果做全面检查</li><li>妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便</li></ol><p>测试过程按4个步骤进行，即<strong>单元测试、集成测试、确认测试和系统测试</strong></p><h4 id="单元测试定义："><a href="#单元测试定义：" class="headerlink" title="单元测试定义："></a>单元测试定义：</h4><p>单元测试又称<strong>模块测试</strong>，是针对软件设计的最小单元——程序模块，进行<strong>正确性检验</strong>的测试工作。其目的在于发现各模块内部可能存在的各种差错（采用的方法主要是白盒测试）单元测试需要从模块内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。<br>在单元测试期间着重从以下5个方面对模块进行测试：<br>（摩羯局指错边）</p><ol><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件（最重要）</li></ol><h4 id="驱动程序："><a href="#驱动程序：" class="headerlink" title="驱动程序："></a>驱动程序：</h4><p>驱动程序是一个<strong>“主程序”</strong>，它<strong>接收测试数据</strong>，把这些数据传送给被测试的模块，并且印出有关的结果。</p><h4 id="白盒测试定义-x2F-类型-x2F-步骤："><a href="#白盒测试定义-x2F-类型-x2F-步骤：" class="headerlink" title="白盒测试定义&#x2F;类型&#x2F;步骤："></a>白盒测试定义&#x2F;类型&#x2F;步骤：</h4><p>白盒测试<strong>把测试对象看作一个透明的盒子</strong>，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<br>通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。因此白盒测试又称为<strong>结构测试或逻辑驱动测试</strong>。<br>类型：白盒测试的测试方法有代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径测试法、域测试、符号测试、Z路径覆盖、程序变异。<br>（带境节制罗录迂腐Z变）<br>其中运用最为广泛的是<strong>基本路径测试法</strong>。<br>白盒测试类型：</p><ol><li><strong>逻辑覆盖</strong></li></ol><p>（预判条件组合点边）</p><ol><li><strong>语句覆盖</strong>——选择足够多的测试数据，是被测程序中每个语句至少执行一次</li><li><strong>判定覆盖</strong>——分支覆盖，不仅每个语句必须至少执行一次，而且<strong>每个判定的每种可能的结果</strong>都应该至少执行一次，也就是每个判定的每个分支都至少执行一次</li><li><strong>条件覆盖</strong>——不仅每个语句至少执行一次，而且使<strong>判定表达式中的每个条件</strong>都取到各种可能的结果</li><li><strong>判定&#x2F;条件覆盖</strong>——选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</li><li><strong>条件组合覆盖</strong>——它要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。<strong>最强的，但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到</strong></li><li><strong>点覆盖</strong>——点覆盖标准和语句覆盖标准是相同的</li><li><strong>边覆盖</strong>——通常边覆盖和判定覆盖是一致的</li></ol><p>白盒测试技术：</p><ol><li><strong>基本路径测试</strong></li></ol><p>（流环线测）</p><ol><li>根据过程设计结果画出相应的<strong>流图</strong></li><li>计算流图的<strong>环形复杂度</strong></li><li>确定线性独立路径的基本集合</li><li>设计<strong>可强制执行基本集合中</strong>每条路径的测试用例</li><li><strong>条件测试</strong></li></ol><p>优点：容易度量条件的测试覆盖率； 程序内条件的测试覆盖率可指导附加测试的设计</p><ol start="3"><li><strong>循环测试</strong></li></ol><p>在结构化的程序中通常只有3种循环，即<strong>简单循环、串接循环和嵌套循环</strong></p><h4 id="黑盒测试方法："><a href="#黑盒测试方法：" class="headerlink" title="黑盒测试方法："></a>黑盒测试方法：</h4><p>这种方法是<strong>把测试对象看做一个黑盒子</strong>，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。黑盒测试又叫做<strong>功能测试或数据驱动测试</strong>。<br>黑盒测试技术：（等边错）</p><ol><li><strong>等价划分</strong></li></ol><p>等价划分把程序的输入域划分成若干个数据类，据此导出测试用例<br>使用等价划分法设计测试方案首先需要划分输入数据的等价类，为此需要研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类。<br>划分出等价类以后，根据等价类设计测试方案时主要使用下面两个步骤<br>(1)设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止<br>(2)设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止<br>注意，通常程序发现一类错误后就不再检查是否还有其他错误，因此，应使每个测试方案只覆盖一个无效的等价类</p><ol start="2"><li><strong>边界值分析</strong></li></ol><p>使用边界值分析方法设计测试方案首先应该确定边界情况，通常输入等价类和输出等价类的边界。选取的测试数据应该刚好<strong>等于、刚刚小于和刚刚大于</strong>边界值<br>通常设计测试方案时总是联合使用<strong>等价划分和边界值分析</strong>两种技术</p><ol start="3"><li><strong>错误推测</strong></li></ol><p>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h4 id="软件调试定义-x2F-步骤："><a href="#软件调试定义-x2F-步骤：" class="headerlink" title="软件调试定义&#x2F;步骤："></a>软件调试定义&#x2F;步骤：</h4><p>调试（也称为纠错）作为成功测试的后果出现，即<strong>调试是在测试发现错误之后排除错误的过程</strong>。<br>软件错误的外部表现和它的内在原因之间可能并没有明显的联系。调试就是把症状和原因联系起来的尚未被人深入认识的智力过程。<br>调试不是测试<br>调试过程从执行一个测试用例开始，评估测试结果，如果发现实际结果与预期结果不一致，则这种不一致就是一个症状，它表明在软件中存在着隐藏的问题。调试过程试图找出产生症状的原因，以便改正错误。<br><img src="https://s1.ax1x.com/2023/05/15/p9glxGn.png#height=318&id=c67qe&originHeight=636&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=396"><br><strong>调试途径：</strong></p><ol><li>蛮干法：最低效</li><li>回溯法：从发现症状的地方开始，人工沿程序的控制流往回追踪分析源程序代码，直到找出错误原因为止</li><li>原因排查法：对分查找法、归纳法和演绎法<ol><li>对分查找法：如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近“注入”这些变量的正确值，然后运行程序并检查所得到的输出。</li><li>归纳法：从个别现象推断出一般性结论的思维方法。使用这种方法调试程序时，首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设</li><li>演绎法：从一般原理或前提出发，经过排除和精化的过程推导出结论。采用这种方法调试程序时，首先设想出所有可能的出错原因，然后试图用测试来排除每一个假设的原因</li></ol></li></ol><h1 id="🍒08章-维护"><a href="#🍒08章-维护" class="headerlink" title="🍒08章 维护"></a>🍒08章 维护</h1><h4 id="软件维护定义-x2F-类型"><a href="#软件维护定义-x2F-类型" class="headerlink" title="软件维护定义&#x2F;类型"></a>软件维护定义&#x2F;类型</h4><p>所谓软件维护就是在软件<strong>已经交付使用</strong>之后，为了<strong>改正错误或满足新的需要</strong>而<strong>修改软件</strong>的过程。可以通过描述软件交付使用后可能进行的<strong>4</strong>项活动，具体地定义软件维护。<br>（改适完预）</p><ol><li><strong>改正性维护</strong>：在任何大型程序的使用期间，用户必然会发现程序错误，并且把他们遇到的问题报告给维护人员。把<strong>诊断和改正错误的过程</strong>称为改正性维护。</li><li><strong>适应性维护</strong>：<strong>第二项维护活动</strong>。适应性维护也就是为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动</li><li><strong>完善性维护</strong>：当一个软件系统顺利地运行时，常常出现第三项维护活动：在使用软件的过程中用户往往提出<strong>增加新功能或修改已有功能</strong>的建议，还可能提出一般性的改进意见。为了满足这类要求，需要进行<strong>完善性维护</strong>。这项维护活动通常占软件维护工作的<strong>大部分</strong></li><li><strong>预防性维护</strong>：当为了改进未来的<strong>可维护性</strong>或<strong>可靠性</strong>，或为了给<strong>未来的改进</strong>奠定更好的基础而修改软件时，出现了第四项维护活动。这项维护活动通常称为预防性维护，目前这项维护活动相对比较少</li></ol><p>上述4类维护活动都<strong>必须应用于整个软件配置</strong></p><h4 id="软件再工程定义-x2F-步骤"><a href="#软件再工程定义-x2F-步骤" class="headerlink" title="软件再工程定义&#x2F;步骤"></a>软件再工程定义&#x2F;步骤</h4><p>程序再工程是指<strong>通过对目标系统的检查和改造</strong>，其中包括设计恢复（库存目录分析）、再文档、逆向工程、程序和数据重构以及正向工程等一系列活动，旨在将逆向工程、重构和正向工程组合起来，<strong>将现存系统重新构造为新的形式，以开发出质量更高、维护性更好的软件</strong><br>典型的<strong>软件再工程过程模型</strong>如下图所示。在某些情况下这些活动以线性顺序发生，但也并非总是这样。例如，为了理解某个程序的内部工作原理，可能在文档重构开始之前必须先进行逆向工程<br><img src="https://s1.ax1x.com/2023/05/14/p9co54O.png#height=272&id=dCMkE&originHeight=542&originWidth=495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=248"></p><h1 id="🍒09章-面向对象方法学引论"><a href="#🍒09章-面向对象方法学引论" class="headerlink" title="🍒09章 面向对象方法学引论"></a>🍒09章 面向对象方法学引论</h1><h4 id="面向对象的统一软件开发过程的各阶段-里程碑"><a href="#面向对象的统一软件开发过程的各阶段-里程碑" class="headerlink" title="面向对象的统一软件开发过程的各阶段 里程碑"></a>面向对象的统一软件开发过程的各阶段 里程碑</h4><p>RUP中的软件生命周期在时间上被分解为四个顺序的阶段 </p><ol><li>初始阶段(Inception) （生命周期目标里程碑 ）</li><li>细化阶段(Elaboration)（生命周期结构里程碑） </li><li>构造阶段(Construction)（初始运行能力 ）</li><li>交付阶段(Transition)（产品发布里程碑）</li></ol><h4 id="关联，两种聚集关联定义"><a href="#关联，两种聚集关联定义" class="headerlink" title="关联，两种聚集关联定义"></a>关联，两种聚集关联定义</h4><ol><li><strong>关联</strong></li></ol><p>关联表示<strong>两个类的对象之间存在某种语义上的联系</strong></p><ol><li>普通关联</li><li>关联的角色</li><li>限定关联</li><li>关联类</li><li><strong>聚集</strong></li></ol><p>聚集也称为聚合，是关联的特例。聚集表示类与类之间的关系是<strong>整体与部分</strong>的关系。使用的“包含”、“组成”、“分为……部分”等字句，意味着存在聚集关系。有<strong>共享聚集</strong>和<strong>组合聚集</strong>两种特殊的聚集关系</p><ol><li>共享聚集</li></ol><p>如果在聚集关系中<strong>处于部分方的对象可同时参与多个处于整体方对象的构成</strong>，则该聚集称为共享聚集。一般聚集和共享聚集的关联关系用空心菱形表示。</p><ol start="2"><li>组合聚集</li></ol><p>如果<strong>部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失</strong>（或失去存在价值了），则该聚集称为组合聚集（简称为组成）。组合聚集的组成关系用实心菱形表示。</p><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>一幅用例图包含的模型元素有<strong>系统、行为者、用例及用例之间的关系</strong>。<br>图是自动售货机系统的用例图。图中的方框代表系统，椭圆代表用例（售货、供货和取货款是自动售货机系统的典型用例），线条人代表行为者，它们之间的连线表示关系<br><img src="https://s1.ax1x.com/2023/05/15/p9g87Kx.png#height=185&id=PncPi&originHeight=737&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=148"><br>一个用例是可以被行为者感受到的、系统的一个完整的功能。在UML中把用例定义成系统完成的一系列动作，动作的结果能被特定的行为者察觉到。这些动作除了完成系统内部的计算与工作外，还包括与一些行为者的通信。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是双向的。<br>用例具有下述特征：</p><ol><li>用例代表某些用户可见的功能，实现一个具体的用户目标。</li><li>用例总是被行为者启动的，并向行为者提供可识别的值。</li><li>用例必须是完整的。</li></ol><p>UML提供的用例图是进行需求分析和建立功能模型的强有力工具。</p><ul><li>使用UML的<strong>类图</strong>来建立<strong>对象模型</strong>，使用UML的<strong>状态图</strong>来建立<strong>动态模型</strong>，使用<strong>数据流图</strong>或UML的<strong>用例图</strong>来建立<strong>功能模型</strong>。在UML中把用用例图建立起来的系统模型称为<strong>用例模型</strong>。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图<strong>描述类及类与类之间的静态关系</strong>。类图是一种静态模型，它是创建其他UML图的基础。一个系统可以由多张类图来描述，一个类也可以出现在几张类图中</p><ul><li>UML描述属性的语法格式如下：</li></ul><p>可见性 属性名：类型名&#x3D;初值{性质串}</p><ul><li>服务也就是操作，UML描述操作的语法格式如下：</li></ul><p>可见性 操作名（参数表）： 返回值类型{性质串}</p><h1 id="🍒10章-面向对象分析"><a href="#🍒10章-面向对象分析" class="headerlink" title="🍒10章 面向对象分析"></a>🍒10章 面向对象分析</h1><h4 id="面向对象需要建立的三类模型"><a href="#面向对象需要建立的三类模型" class="headerlink" title="面向对象需要建立的三类模型"></a>面向对象需要建立的三类模型</h4><p>用面向对象方法开发软件，通常需要建立3种形式的模型，它们分别是：</p><ol><li><strong>描述系统数据结构的对象模型</strong></li></ol><p>对象模型是从系统的静态结构上描述系统的需求</p><ol start="2"><li><strong>描述系统控制结构的动态模型</strong></li></ol><p>动态模型是描述系统的交互行为的需求</p><ol start="3"><li><strong>描述系统功能的功能模型</strong></li></ol><p>功能模型表明的是系统中数据之间的依赖关系，以及有关的数据处理功能，一般采用数据流图描述<br>在任何情况下，<strong>对象模型</strong>始终都是最重要、最基本、最核心的。<br>面向对象建模得到的模型包含系统的3个要素，即<strong>静态结构</strong>（对象模型）、<strong>交互次序</strong>（动态模型）和<strong>数据变换</strong>（功能模型）。解决的问题不同，这3个子模型的重要程度也不同。</p><h4 id="对象模型的5个层次"><a href="#对象模型的5个层次" class="headerlink" title="对象模型的5个层次"></a>对象模型的5个层次</h4><p>复杂问题（大型系统）的对象模型通常由下述5个层次组成：<br>（主类结束符）<br><img src="https://s1.ax1x.com/2023/05/14/p9cTaxH.png#height=185&id=DZtVP&originHeight=369&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=404"></p><h4 id="软件重用定义"><a href="#软件重用定义" class="headerlink" title="软件重用定义"></a>软件重用定义</h4><p>两次或多次不同的软件开发过程中使用相同或相似软件元素的过程<br>重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使用。广义地说，软件重用可分为以下3个层次：</p><ol><li>知识重用</li><li>方法和标准的重用</li><li><strong>软件成分的重用</strong></li></ol><p>软件过程的增量模型<img src="https://s1.ax1x.com/2023/05/16/p92zhIe.png#height=374&id=i82C8&originHeight=748&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"></p>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——线性表</title>
      <link href="/2023/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="🎰线性表"><a href="#🎰线性表" class="headerlink" title="🎰线性表"></a>🎰线性表</h1><p><img src="https://s2.loli.net/2023/06/08/S5eFVN2QDhJK4lI.png#height=572&id=oJtbY&originHeight=762&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1238"></p><h2 id="🎮顺序表与链表"><a href="#🎮顺序表与链表" class="headerlink" title="🎮顺序表与链表"></a>🎮顺序表与链表</h2><h3 id="🧵存取（读写）方式"><a href="#🧵存取（读写）方式" class="headerlink" title="🧵存取（读写）方式"></a>🧵存取（读写）方式</h3><ul><li>顺序表可以<strong>顺序存取</strong>，也可以<strong>随机存取</strong></li><li>链表只能从<strong>表头顺序存取元素</strong></li></ul><p>例：在第i个位置上执行存或取得操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次</p><h3 id="🧵逻辑结构与物理结构"><a href="#🧵逻辑结构与物理结构" class="headerlink" title="🧵逻辑结构与物理结构"></a>🧵逻辑结构与物理结构</h3><ul><li>顺序表——逻辑上相邻的元素，对应的物理存储位置也相邻</li><li>链式存储——逻辑上相邻的元素，物理位置则不一定相邻</li></ul><h3 id="🧵查找、插入和删除操作"><a href="#🧵查找、插入和删除操作" class="headerlink" title="🧵查找、插入和删除操作"></a>🧵查找、插入和删除操作</h3><ul><li><strong>按值查找</strong>——顺序表无序时，时间复杂度为O(n)；顺序表有序时，可以采用折半查找，时间复杂度为O(logn)</li><li><strong>按序号查找</strong>——顺序表支持随机访问，时间复杂度O(1)；链表的平均时间复杂度为O(n)</li></ul><p>顺序表的插入、删除操作平均需要移动半个表长的元素<br>链表的插入和删除只需要修改相关结点的指针域即可</p><h3 id="🧵空间分配"><a href="#🧵空间分配" class="headerlink" title="🧵空间分配"></a>🧵空间分配</h3><ul><li><strong>顺序存储</strong>在<strong>静态存储分配情况</strong>下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要<strong>预先分配足够大的存储空间</strong></li></ul><p>预先分配过大——顺序表后部大量限制；预先分配过小——造成溢出<br><strong>动态存储分配</strong>虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败（动态分配≠链式存储）</p><ul><li><strong>链式存储</strong>的结点空间只<strong>在需要时申请分配</strong>，只要内存有空间就可以分配，操作灵活、高效</li></ul><h2 id="🎮头指针和头结点"><a href="#🎮头指针和头结点" class="headerlink" title="🎮头指针和头结点"></a>🎮头指针和头结点</h2><ul><li><strong>头指针</strong>——<strong>指向第一个结点存储位置的指针</strong>，具有标识作用。<strong>头指针是链表的必要元素</strong>，无论链表是否为空，头指针都存在</li><li><strong>头结点</strong>——是<strong>放在第一个元素结点之前</strong>，便于在第一个元素结点之前进行插入和删除操作。<strong>头结点不是链表的必须元素</strong>，可有可无，头结点的数据域也可以不存储任何信息</li></ul><h2 id="🎮利用单链表解决问题时，为什么引入头结点的单链表"><a href="#🎮利用单链表解决问题时，为什么引入头结点的单链表" class="headerlink" title="🎮利用单链表解决问题时，为什么引入头结点的单链表"></a>🎮利用单链表解决问题时，为什么引入头结点的单链表</h2><ol><li>链表的第一个位置和其他位置的操作进行了统一</li><li>空表和非空表的操作统一——无论有没有数据节点，带有头结点的，单链表始终head指针不为空，它始终指向了头结点</li></ol><h2 id="🎮链表"><a href="#🎮链表" class="headerlink" title="🎮链表"></a>🎮链表</h2><h3 id="🧵双向链表"><a href="#🧵双向链表" class="headerlink" title="🧵双向链表"></a>🧵双向链表</h3><p>双向，指的是个节点之间的逻辑关系是双向的，但通常头指针只设置一个。双向链表中各结点包含以下3部分信息：</p><ol><li>指针域：用于指向当前结点的直接前驱结点；</li><li>数据域：用于存储数据元素；</li><li>指针域：用于指向当前节点的直接后继节点</li></ol><h3 id="🧵循环链表"><a href="#🧵循环链表" class="headerlink" title="🧵循环链表"></a>🧵循环链表</h3><p>将单链表中终端结点的指针端有空指针改为指向头结点，使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，检测循环链表</p><ul><li>优点：无论从链表的哪个结点出发，都可以访问到所有的结点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课程总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——算法初步</title>
      <link href="/2023/05/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/"/>
      <url>/2023/05/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊算法初步"><a href="#🎊算法初步" class="headerlink" title="🎊算法初步"></a>🎊算法初步</h1><h2 id="🎀排序"><a href="#🎀排序" class="headerlink" title="🎀排序"></a>🎀排序</h2><h3 id="🎈选择排序"><a href="#🎈选择排序" class="headerlink" title="🎈选择排序"></a>🎈选择排序</h3><ul><li><strong>简单选择排序</strong></li></ul><p>算法思路——对一个序列A中的元素A[1]~A[n]，令i从1到n枚举，进行n趟操作，每趟从待排序部分[i,n]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈插入排序"><a href="#🎈插入排序" class="headerlink" title="🎈插入排序"></a>🎈插入排序</h3><ul><li><strong>直接插入排序</strong></li></ul><p>算法思路——对一个序列A中的元素A[1]~A[n]，令i从2到n枚举,进行n-1趟操作。将插入元素一个个插入初始已有序部分中的过程，而插入位置的选择遵循使插入后依然保持有序的原则—从后往前枚举已有序部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈排序题与sort函数的应用"><a href="#🎈排序题与sort函数的应用" class="headerlink" title="🎈排序题与sort函数的应用"></a>🎈排序题与sort函数的应用</h3><h4 id="🎄sort函数"><a href="#🎄sort函数" class="headerlink" title="🎄sort函数"></a>🎄sort函数</h4><p>直接使用C++中的库函数<strong>sort函数</strong><br>头文件#include<algorithm>和using namespace std;<br>:::success<br>使用方法：<br><strong>sort(首元素地址（必填），尾元素地址的下一个地址（必填），比较函数（非必填）)；</strong><br>如果不写比较函数，则默认对面前给出的区间进行递增排序<br>:::</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>] =&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">4</span>)</span><br><span class="line"><span class="comment">//将a[0]~a[3]从小到大排序</span></span><br><span class="line">    <span class="comment">//实际上尾元素地址的下一地址-首元素地址就是排序元素的个数</span></span><br></pre></td></tr></table></figure><ul><li><strong>比较函数cmp</strong></li></ul><p>比较函数不填写的时候，默认从小到大的顺序进行排序</p><ol><li><p>从大到小排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;<span class="comment">//可以理解为当a&gt;b时，把a放在b前面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">3</span>,cmp);<span class="comment">//从大到小排序</span></span><br></pre></td></tr></table></figure></li><li><p>结构体数组的排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//将ssd数组按照x从大到小的顺序进行排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将ssd数组按照x从大到小的顺序进行排序,若x相等则按照y从小到大</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x)</span><br><span class="line">    <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ssd,ssd+<span class="number">3</span>,cmp);</span><br></pre></td></tr></table></figure></li><li><p>容器的排序</p></li></ol><p>在STL标准容器中，vector、string、deque可以使用sort</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="built_in">sort</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="comment">//string</span></span><br><span class="line">string str[<span class="number">3</span>]=&#123;<span class="string">&quot;bbbb&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(str,str+<span class="number">3</span>);<span class="comment">//按字典序从小到大</span></span><br><span class="line"><span class="comment">//也可以按照字符串长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">com</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">length</span>()&lt;str2.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🎄排序题基本步骤"><a href="#🎄排序题基本步骤" class="headerlink" title="🎄排序题基本步骤"></a>🎄排序题基本步骤</h4><ol><li>相关结构体的定义</li></ol><p>对于题目中所给出的很多个题信息，利用结构体数组表示多个个体</p><ol start="2"><li>cmp函数的编写</li></ol><p>特别的char数组进行比较时，使用return strcmp(a.name,b.name)&lt;0——从小到大字典序排序</p><ol start="3"><li>排名的实现</li></ol><p>在排序之后求出每个个体的排名（分数不同排名不同；分数相同占用一位，排名相同）<br>将排位添加到结构体中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stu[<span class="number">0</span>].r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(stu[i].score == stu[i<span class="number">-1</span>].score;&#123;</span><br><span class="line">        stu[i].r = stu[i<span class="number">-1</span>].r;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">stu[i].r = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//也可以不通过结构体，直接定义一个int r即可</span></span><br></pre></td></tr></table></figure><h2 id="🎀散列（哈希）"><a href="#🎀散列（哈希）" class="headerlink" title="🎀散列（哈希）"></a>🎀散列（哈希）</h2><h3 id="🎈散列的定义-x2F-整数hash"><a href="#🎈散列的定义-x2F-整数hash" class="headerlink" title="🎈散列的定义&#x2F;整数hash"></a>🎈散列的定义&#x2F;整数hash</h3><p>查询M个数是否在N个数中出现过——对每个欲查询的正整数x，遍历所有的N个数——时间复杂度非常大<br>使用<strong>空间换时间</strong>—使用一个bool类型的数组hashTable[10000]，其中hashTable[x]&#x3D;&#x3D;true表示正整数x出现过，反之表示未出现，可以在读取数字时就对数字进行预处理<br>M个欲查询的数中每个数在N中出现的次数——int hashTable[10000]，hashTable[x]++<br><strong>特点——直接把输入的数作为数组的下标</strong></p><h4 id="🎄散列（Hash）"><a href="#🎄散列（Hash）" class="headerlink" title="🎄散列（Hash）"></a>🎄散列（Hash）</h4><p>将元素通过一个函数转换未整数，使得该整数可以尽量唯一的代表这个元素H(key)</p><ol><li><strong>直接定值法</strong></li></ol><p>H(key)&#x3D;key</p><ol start="2"><li><strong>线性变换</strong></li></ol><p>H(key)&#x3D;a*key+b</p><ol start="3"><li><strong>除留余数法</strong></li></ol><p>H(key)&#x3D;key%mod——一个数除以mod得到的余数作为hash<br>一般取mod为素数TSize</p><h4 id="🎄冲突"><a href="#🎄冲突" class="headerlink" title="🎄冲突"></a>🎄冲突</h4><p>除留余数法可能会出现两个不同的数字key1和key2它们的hash值相同</p><ol><li><strong>线性探查法（开放定址法）</strong></li></ol><p>当得到key的值的hash值H(key)，但表中下标为H(key)的位置已经被占用，探索下一位置H(key)+1<br>超过表长，则回到表长继续循环</p><ol start="2"><li><strong>平方探查法（开放定址法）</strong></li></ol><p>H(key)被占用——H(key)+12、H(key)-12、H(key)+22、H(key)-22…<br>超过表长，则把H(key)+k2对表长TSize取模</p><ol start="3"><li><strong>链地址法</strong></li></ol><p>把所有相同的H(key)的key连接成一条单链表，可以设定一个数组Link（Link[0]~Link[mod-1]，Link[h]存放H(key)&#x3D;h的一条单链表）<br>使用map函数直接使用hash功能</p><h3 id="🎈字符串hash"><a href="#🎈字符串hash" class="headerlink" title="🎈字符串hash"></a>🎈字符串hash</h3><h4 id="🎄二维整点映射为一个整数"><a href="#🎄二维整点映射为一个整数" class="headerlink" title="🎄二维整点映射为一个整数"></a>🎄二维整点映射为一个整数</h4><p>假设P(x,y)，可以令H(P)&#x3D;x*Range+y</p><h4 id="🎄字符串hash"><a href="#🎄字符串hash" class="headerlink" title="🎄字符串hash"></a>🎄字符串hash</h4><ul><li><strong>只考虑大写字母A~Z的情况</strong></li></ul><p>将A<del>Z视为0</del>25——再将26进制转为10进制的数字</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">char</span> S[],<span class="type">int</span> len)</span></span>&#123;<span class="comment">//len表示字符串的长度</span></span><br><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    id=id*<span class="number">26</span>+(S[i]-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>同时考虑小写字母</strong></li></ul><p>A<del>Z为0</del>25，a<del>z为26</del>51——与上做法相同，将五十二进制转为十进制</p><ul><li><strong>出现数字的情况</strong></li></ul><ol><li>按照小写字母的情况，增大进制至62</li><li>字符串的末尾是个位数字，就可以直接在字母转化成的数字后加一位数表示该数字</li></ol><h2 id="🎀贪心"><a href="#🎀贪心" class="headerlink" title="🎀贪心"></a>🎀贪心</h2><h3 id="🎈简单贪心"><a href="#🎈简单贪心" class="headerlink" title="🎈简单贪心"></a>🎈简单贪心</h3><h3 id="🎈区间贪心"><a href="#🎈区间贪心" class="headerlink" title="🎈区间贪心"></a>🎈区间贪心</h3><p>区间不相交问题——给出N个开区间(x,y)，从中选择尽可能多的开区间，使得这些开区间两两没有交集<br>区间排序</p><ol><li>按<strong>左端点从大到小顺序排序</strong></li><li><strong>左端点相同，右端点从小到大</strong></li></ol><p>区间相交问题——类似</p><h2 id="🎀递归"><a href="#🎀递归" class="headerlink" title="🎀递归"></a>🎀递归</h2><p>——反复调用自身函数，但每次把问题的范围缩小，知道范围缩小到可以直接得到边界数据的结果<br>递归的两个重要概念</p><ol><li>递归边界</li><li>递归式</li></ol><ul><li><strong>substr的用法</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//有两个参数，一个参数是起始位置，一个参数是截取长度。</span></span><br><span class="line">s.<span class="built_in">substr</span>(pos,len);</span><br><span class="line">string s=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">string sub=s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="🎀二分"><a href="#🎀二分" class="headerlink" title="🎀二分"></a>🎀二分</h2><h3 id="🎈二分查找"><a href="#🎈二分查找" class="headerlink" title="🎈二分查找"></a>🎈二分查找</h3><p>——基于有序序列的查找算法<br>[left,right]——mid&#x3D;(left+right)&#x2F;2——[left,mid-1]或[mid+1,right]<br>——<strong>min&#x3D;left+(right-left)&#x2F;2</strong>避免溢出</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> x)</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>解决”寻找有序序列第一个满足某条件的元素的位置“</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分区间为左闭又闭[left,right]，初值必须能覆盖所有的可能值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;<span class="comment">//若左开右闭(left,right]——while(left+1&lt;right)——left+1==right可以确定唯一的值</span></span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(条件成立)right=mid;</span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="🎈二分查找拓展"><a href="#🎈二分查找拓展" class="headerlink" title="🎈二分查找拓展"></a>🎈二分查找拓展</h3><ul><li>计算√2的近似值——<strong>给定一个定义在[L,R]上的单调函数f(x),求方程f(x)&#x3D;0的根</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-5</span>;</span><br><span class="line"><span class="built_in">doublef</span>(<span class="type">int</span> x)&#123;<span class="comment">//假设f(x)递增</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> l,<span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> left=l,right=r,mid;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-5</span>)&#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(mid)&gt;<span class="number">0</span>)right=mid;</span><br><span class="line">        <span class="keyword">else</span> left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="🎈快速幂"><a href="#🎈快速幂" class="headerlink" title="🎈快速幂"></a>🎈快速幂</h3><p>求ab%m当a、b、m很大时，直接求很慢</p><ol><li>b为奇数——ab&#x3D;a*ab-1</li><li>b为偶数——ab&#x3D;ab&#x2F;2*ab&#x2F;2</li></ol><ul><li><p><strong>快速幂的递归写法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速幂的递归写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">BinaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//奇数——(b%2==1)可以用(b&amp;2)替代,判断b的末位是否为1</span></span><br><span class="line">        <span class="keyword">return</span> a*<span class="built_in">BinaryPow</span>(a,b<span class="number">-1</span>,m);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        LL mul = <span class="built_in">BinaryPow</span>(a,b/<span class="number">2</span>,m);</span><br><span class="line">        <span class="keyword">return</span> mul*mul%m;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快速幂的迭代写法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速幂的迭代写法</span></span><br><span class="line"><span class="comment">//把b写成二进制的形式，当前位为1 ans累计上a</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">BinaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=ans*a%m;</span><br><span class="line">        &#125;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        b &gt;&gt;=<span class="number">1</span>;<span class="comment">//b的二进制右移1位 或b=b/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🎀two-pointers"><a href="#🎀two-pointers" class="headerlink" title="🎀two pointers"></a>🎀two pointers</h2><p>利用<strong>有序序列</strong>的枚举特性来有效降低复杂度</p><blockquote><p><strong>给定一个递增的正整数序列和一个正整数M。求序列中两个不同位置的数a和b，使得他们的和恰好为M</strong><br>二重循环枚举的时间复杂度为O(n2)，使用双指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[left]+a[right]==k)&#123;</span><br><span class="line">            num++;left++;right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[left]+a[right]&gt;k)right--;</span><br><span class="line">        <span class="keyword">else</span> left++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令下标i初值为0，下标j初值为n-1，即令i和j分别指向序列的第一个元素和最后一个元素，根据a[i]+a[j]与M的大小来不断地移动两个指针</p><blockquote><p><strong>序列合并问题</strong><br><strong>假设有两个递增序列A和B，要求将它们合并为一个递增序列C</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;n&amp;&amp;right&lt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[left]&lt;b[right])&#123;</span><br><span class="line">            ans[i++]=a[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[left]&gt;b[right])&#123;</span><br><span class="line">           ans[i++]=b[right];</span><br><span class="line">           right++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i++]=a[left];</span><br><span class="line">            ans[i++]=a[left];</span><br><span class="line">            left++;right++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left&lt;n)&#123;</span><br><span class="line">    ans[i++]=a[left];left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(right&lt;m)&#123;</span><br><span class="line">    ans[i++]=b[right];right++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈归并排序"><a href="#🎈归并排序" class="headerlink" title="🎈归并排序"></a>🎈归并排序</h3><p>2-路归并排序——将序列两两分组，将序列归并为[n&#x2F;2]个组，组内单独排序；然乎将这些组再两两归并，生成[n&#x2F;4]个组，组内再单独排序；以此类推直到只剩下一个组为止</p><ul><li><strong>递归实现</strong></li></ul><p>反复将当前区间[left,right]分为两半，对两个子区间[left,mid]和[mid+1，right]分别再进行递归归并，直到left&gt;&#x3D;right，再将左子区间和右子区间合并</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> mid1,<span class="type">int</span> mid2,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> L1=left,L2=mid2;</span><br><span class="line">    <span class="type">int</span> ans[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L1&lt;=mid1&amp;&amp;L2&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[L1]&lt;=a[L2])&#123;</span><br><span class="line">            ans[num++]=a[L1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[L1]&gt;a[L2])&#123;</span><br><span class="line">            ans[num++]=a[L2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L1&lt;=mid1)&#123;</span><br><span class="line">        ans[num++]=a[L1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L2&lt;=right)&#123;</span><br><span class="line">        ans[num++]=a[L2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;<span class="comment">//将合并后的数组传回给A</span></span><br><span class="line">        a[left++]=ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid =left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergesort</span>(a,left,mid);<span class="comment">//左半区二分</span></span><br><span class="line">        <span class="built_in">mergesort</span>(a,mid+<span class="number">1</span>,right);<span class="comment">//右半区二分</span></span><br><span class="line">        <span class="built_in">merge</span>(a,left,mid,mid+<span class="number">1</span>,right);<span class="comment">//两个排序并合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>非递归实现——比递归难懂，要多看看</strong></li></ul><p>令步长初值为2，然后将数组中每个step元素作为一组，将其内部进行排序；再令step&#x3D;step*2，重复上述操作，直到step&#x2F;2超过元素n个<br><strong>修正区间</strong></p><ul><li>修正end1：</li></ul><p>当end1越界时，让end1等于最后一个元素下标即可。 end1 &#x3D; n-1</p><ul><li>修正begin2：</li></ul><p>如果begin2越界，就说明第二个区间并不存在，我们都不需要合并了，因为区间2不存在，区间1就是我们最终的数组，因此我们就让区间2搞成一个不存在 begin &#x3D; n,end2 &#x3D; n-1.</p><ul><li>修正end2：</li></ul><p>当begin2ok,end2越界时,我们修正end2等于最后一个元素下标即可。 end2 &#x3D; n-1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> step=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(step&lt;n)&#123;</span><br><span class="line">        <span class="comment">//step个元素为一组，两两合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>*step)&#123;</span><br><span class="line">            <span class="type">int</span> begin1=i,end1=i+step<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> begin2=i+step,end2=i+<span class="number">2</span>*step<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//修正区间</span></span><br><span class="line">            <span class="keyword">if</span>(end1&gt;=n)end1=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(begin2&gt;=n)&#123;</span><br><span class="line">                begin2=n,end2=n<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(begin2&lt;n&amp;&amp;end2&gt;=n)&#123;</span><br><span class="line">                end2=n<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">merge</span>(a,begin1,end1,begin2,end2);</span><br><span class="line">        &#125;</span><br><span class="line">        step*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈快速排序"><a href="#🎈快速排序" class="headerlink" title="🎈快速排序"></a>🎈快速排序</h3><p>思路：</p><ol><li>调整序列中的元素，使当前序列最左端的元素再调整后满足左侧所有元素均不超过该元素，右侧素有元素均大于该元素</li><li>对该元素的左侧和右侧分别递归进行1中的操作，直到当前调整区间的长度不超过1<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line"><span class="type">int</span> pos=<span class="built_in">Partition</span>(A,left,right);</span><br><span class="line"><span class="built_in">quickSort</span>(A,left,pos<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">quickSort</span>(A,pos,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>快速排序算法当序列中的元素排列比较随机时，效率较高；但当序列中的元素接近有序时，时间复杂度最坏O(n2)<br>解决方法：在[left,right]中随机选一个元素作为主元</li></ol><h4 id="🎄随机数生成方法"><a href="#🎄随机数生成方法" class="headerlink" title="🎄随机数生成方法"></a>🎄随机数生成方法</h4><p>:::success<br>头文件：#inlcude&lt;stdlib.h&gt;和#include&lt;time.h&gt;<br>在main的开头加上srand((unsigned)time(NULL));<br>在需要使用随机数的地方使用rand()即可<br><strong>输出给定范围[a,b]内的随机数——rand()%(b-a+1)+a</strong><br><strong>生成大范围随机数[left,right]——round(1.0<em>rand()&#x2F;Rand_MAX</em>(right-left)+left)</strong><br>:::</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">round</span>(<span class="number">1.0</span>*<span class="built_in">rand</span>())/RAND_MAX*(right-left)+left;</span><br><span class="line">    <span class="built_in">swap</span>(a[p],a[left]);</span><br><span class="line">    <span class="type">int</span> temp=a[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;temp) right--;</span><br><span class="line">        a[left]=a[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=temp) left++;</span><br><span class="line">        a[right]=a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left]=temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">Partition</span>(a,left,right);</span><br><span class="line">        <span class="built_in">quicksort</span>(a,left,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quicksort</span>(a,pos+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀其他算法技巧"><a href="#🎀其他算法技巧" class="headerlink" title="🎀其他算法技巧"></a>🎀其他算法技巧</h2><h3 id="🎈打表"><a href="#🎈打表" class="headerlink" title="🎈打表"></a>🎈打表</h3><ul><li>用空间换时间</li></ul><p>将所有可能用到的结果事先计算出来，这样后面需要用到的时候就可以直接查表得到</p><ol><li>在程序中那个一次性计算出所有需要用到的结果，之后的查询直接取这些结果</li><li>在程序B中分一次或者多次计算出所有需要用到的结果，手动把这些结果写在程序A的数组中，然后在程序A中就可以直接使用</li><li>先暴力程序计算小范围数据的结果，然后找规律</li></ol><h3 id="🎈活用递推"><a href="#🎈活用递推" class="headerlink" title="🎈活用递推"></a>🎈活用递推</h3><p>对于暴力求法会超时的题目，要巧妙利用地递推，找到可以求解的规律算法</p><h3 id="🎈随机选择算法"><a href="#🎈随机选择算法" class="headerlink" title="🎈随机选择算法"></a>🎈随机选择算法</h3><blockquote><p><strong>从一个无序的书组长求出第K大的数</strong><br>对数组排序后取第K个——时间复杂度O(nlogn)<br>随机选择排序算法——类似于快速排序算法，对A[left,right]执行一次randPartition函数后，设此时主元是A[P]，那么此时第P-left+1大的数就是A[P]，反之就在左侧或者右侧，继续递归即可</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I SIT——坐姿监测系统及可视化设计</title>
      <link href="/2023/05/14/I%20SIT%E2%80%94%E2%80%94%E5%9D%90%E5%A7%BF%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/14/I%20SIT%E2%80%94%E2%80%94%E5%9D%90%E5%A7%BF%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="👕产品简介"><a href="#👕产品简介" class="headerlink" title="👕产品简介"></a>👕产品简介</h1><h2 id="👖产品名称"><a href="#👖产品名称" class="headerlink" title="👖产品名称"></a>👖产品名称</h2><p>I SIT——坐姿监测系统及可视化设计</p><h2 id="👖产品描述"><a href="#👖产品描述" class="headerlink" title="👖产品描述"></a>👖产品描述</h2><p>近年来，随着近视及颈椎、腰椎等各种疾病的低龄化，国家对青少年的坐姿越来越重视。本项目基于电脑摄像头中获取的视频进行坐姿检测，无需额外的辅助设备即可对青少年坐姿不正情况进行提醒，从而综合判断儿童的健康状况，给出相关的优化建议，从而减少相关健康问题的发生。<br>该作品基于PYQT进行页面设计，结合开源可视化库ECharts进行数据可视化展示。坐标检测判定的坐姿判定方式，通过收集的700多名同学的各种坐姿数据库进行规则制定，具有稳定，准确，经济，安全，实用的优势。</p><h2 id="👖产品特点"><a href="#👖产品特点" class="headerlink" title="👖产品特点"></a>👖产品特点</h2><h3 id="🩳基于电脑摄像头设备中获取的视频数据进行坐姿和疲劳程度检测"><a href="#🩳基于电脑摄像头设备中获取的视频数据进行坐姿和疲劳程度检测" class="headerlink" title="🩳基于电脑摄像头设备中获取的视频数据进行坐姿和疲劳程度检测"></a>🩳基于电脑摄像头设备中获取的视频数据进行坐姿和疲劳程度检测</h3><p>本项目利用电脑摄像头获取视频，基于计算机视觉的方法，进行坐姿和疲劳程度的检测，可以在青少年没有意识的情况下进行“监控”；另一方面，坐姿的判断，可以为青少年的健康评估提供依据，成为父母们信任的“好帮手”。</p><h3 id="🩳坐标判定法的判断方案"><a href="#🩳坐标判定法的判断方案" class="headerlink" title="🩳坐标判定法的判断方案"></a>🩳坐标判定法的判断方案</h3><p>本项目基于MediaPipe人体骨架图识别算法提取骨骼关键点，形成骨骼关键点位置布局图，然后针对骨骼关键点布局图进行标定，通过将700多名同学的坐姿图转化为相应骨骼图，指定相应的以骨骼关键点坐标关系的判定法，并利用视频检测进行长时间测试和修改，得到准确、有效的坐标关系，用以判断儿童的坐姿，做到尽量不要误判、漏判。</p><h2 id="👖产品功能"><a href="#👖产品功能" class="headerlink" title="👖产品功能"></a>👖产品功能</h2><h3 id="🩳计时器功能"><a href="#🩳计时器功能" class="headerlink" title="🩳计时器功能"></a>🩳计时器功能</h3><p>点击进入软件，映入眼帘的便是计时器功能，并带有当天日期以及天气。当用户不需要进行坐姿检测时，可以使用该软件进行学习计时，并带有动态清零功能。</p><h3 id="🩳人体骨架图显示功能"><a href="#🩳人体骨架图显示功能" class="headerlink" title="🩳人体骨架图显示功能"></a>🩳人体骨架图显示功能</h3><p>在进行实时坐姿检测时，系统会基于Mediapipe的人像识别功能抽象出使用者的坐姿的骨骼图，通过所给图像+骨架图的形式给出，可以形象展示使用者目前的坐姿，使用者可以看到部分身体关键点的位置。</p><h3 id="🩳当前坐姿情况判断功能"><a href="#🩳当前坐姿情况判断功能" class="headerlink" title="🩳当前坐姿情况判断功能"></a>🩳当前坐姿情况判断功能</h3><p>当前坐姿情况的判断主要是通过对所生成的骨骼图进行判断的，所采用的方法坐标判断检测。在图像检测界面，用户可以通过选择相应的坐姿图片来得到相应的坐姿情况，并会输出在界面的右下方。而在实时监测部分，当用户单击“打开摄像头”后，电脑会实时监测用户当前的坐姿情况，并不断输出在屏幕的右下方。当用户选择截取保存时，点击“截取图片”按钮，进行路径选择存放生成的骨骼数据图，可以截取当前软件的界面。</p><h3 id="🩳坐姿情况可视化功能"><a href="#🩳坐姿情况可视化功能" class="headerlink" title="🩳坐姿情况可视化功能"></a>🩳坐姿情况可视化功能</h3><p>在用户进行实时监控坐姿检测的过程中，系统会实时进行坐姿问题的检测，并在后台予以记录，当此次检测结束后，用户可以点击界面下方的“坐姿情况”按钮，就会进入“坐姿可视化系统”，该系统会根据坐姿问题的汇总统计。<br>界面主要分为三大部分：坐姿总体情况，坐姿情况和疲劳情况。在坐姿总体情况部分，可以得到上一段用户使用时，错误坐姿、正确坐姿以及疲劳坐姿的出现次数以及相关可视化图表。在坐姿情况处，可以得到周度统计，月度统等可视化图表。在疲劳情况处，可以得到趴写、伸懒腰、打哈欠三种情况的相关统计图表，以清晰的得到使用者的学习情况。</p><h2 id="👖产品优势"><a href="#👖产品优势" class="headerlink" title="👖产品优势"></a>👖产品优势</h2><p>软件基于MediaPipe提取骨骼关键点，形成骨骼关键点位置布局图，然后针对骨骼关键点布局图进行坐标规则制定。因此，坐姿检测软件在精确度、可靠性等方面拥有很大优势。本项目则提出坐姿检测软件系统，基于计算机视觉的方法，进行坐姿和疲劳程度的检测，一方面可以在青少年没有意识的情况下进行“监控”；另一方面，坐姿的判断，可以为青少年的健康状况评估提供依据。<br>于此同时，该电脑软件系统，界面简洁，可爱易操作，用户不需要花费其他金钱购买相关监测软件，只需通过电脑运行程序即可随时随地进行监测。且学习成本低，易操作。</p><h1 id="👕开源代码与组件使用情况说明"><a href="#👕开源代码与组件使用情况说明" class="headerlink" title="👕开源代码与组件使用情况说明"></a>👕开源代码与组件使用情况说明</h1><p>在软件可视化部分，使用了pyecharts进行坐姿以及疲劳可视化情况的绘制。运用了pyecharts中的雷达图、折线图、饼图、日历图等相关开源组件并加以使用和加工。<br>“pyecharts 是一个用于生成 Echarts 图表的类库。Echarts 是百度开源的一个数据可视化 JS 库。用 Echarts 生成的图可视化效果非常棒，为了与 Python 进行对接，方便在 Python 中直接使用数据生成图”。pyecharts可以展示动态图，在线报告使用比较美观，并且展示数据方便，鼠标悬停在图上，即可显示数值、标签等。<br>官网地址：<br><a href="http://pyecharts.org/#/zh-cn/charts">http://pyecharts.org/#/zh-cn/charts</a>、<a href="https://pyecharts.org/#/zh-cn/quickstart">https://pyecharts.org/#/zh-cn/quickstart</a>、<a href="https://github.com/pyecharts/pyecharts">https://github.com/pyecharts/pyecharts</a></p><h1 id="👕概要分析"><a href="#👕概要分析" class="headerlink" title="👕概要分析"></a>👕概要分析</h1><h2 id="👖系统分析"><a href="#👖系统分析" class="headerlink" title="👖系统分析"></a>👖系统分析</h2><p>功能需求：</p><ol><li>时钟的计时功能和天气查询功能。</li><li>坐姿照片的检测功能。</li><li>运行结果的截图保存功能。</li><li>实时坐姿检测功能。</li><li>实时监测的输出结果的可视化功能</li><li>界面简洁且跳转流畅。</li></ol><p>针对需求分析，将我们的软件图分解成如下功能模块示意图。功能模块图如图所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh405s.md.png#id=HRNZn&originHeight=500&originWidth=280&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="👖技术框架"><a href="#👖技术框架" class="headerlink" title="👖技术框架"></a>👖技术框架</h2><h3 id="🩳UI设计"><a href="#🩳UI设计" class="headerlink" title="🩳UI设计"></a>🩳UI设计</h3><p>使用PyQt作为我们的界面UI设计软件。<br>PyQt是一个用于Python编程语言的GUI框架，它使用了Qt应用程序开发框架。PyQt允许程序员创建具有良好外观和功能的交互式应用程序。<br>设计UI界面：使用Qt Designer工具来创建UI布局，它提供了拖放式用户界面设计器。设计完后保存为.ui文件。将UI转换为Python代码：使用pyuic工具将.ui文件转换为.py文件，这样可以在Python代码中调用UI元素。将转换后的代码添加到Python程序中：将UI生成的Python代码导入到主程序中，并初始化窗口，设置事件处理程序等。再完成初步界面设计后，再加以美化即可。</p><h3 id="🩳可视化设计"><a href="#🩳可视化设计" class="headerlink" title="🩳可视化设计"></a>🩳可视化设计</h3><p>使用专业数据可视化工具PyECharts对坐姿情况数据及进行可视化。<br>Pyecharts是一个基于Python语言的数据可视化库，它使用了Echarts开源项目提供的JavaScript图表库。Pyecharts可以帮助用户快速、简单地创建各种动态、交互式的数据可视化图表。<br>创建图表对象：首先需要导入所需的图表类型和绘图组件类别，然后创建相应的图表对象。添加数据和配置项：在图表对象中添加需要展示的数据和配置项。渲染生成图像文件或网页：将图表对象渲染成图像文件或网页。在浏览器中打开图像文件或网页：用浏览器打开渲染生成的图像文件或网页，即可查看数据可视化图表。Pyecharts支持多种类型的图表，包括折线图、柱状图、散点图、饼图等。它使用简单，易于学习，同时提供了强大的自定义功能，可以满足各种数据可视化需求。<br>因此我们使用这一可视化库对我们的软件进行可视化并通过插件导入软件界面，实时生成相关图。</p><h2 id="👖项目文件"><a href="#👖项目文件" class="headerlink" title="👖项目文件"></a>👖项目文件</h2><h3 id="🩳UI界面"><a href="#🩳UI界面" class="headerlink" title="🩳UI界面"></a>🩳UI界面</h3><p>本项目共由6个UI界面，项目如下图所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4cKK.png#id=Hb5z8&originHeight=281&originWidth=1358&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>其中，camera.ui为实时检测部分的界面设计，homepage.ui为计时部分的ui设计，也是我们整个项目的首页，picture.ui为图片实时监测部分的界面设计，而剩下三个作为可视化部分的界面设计，分别是坐姿情况、疲劳情况以及坐姿总体情况的界面。将ui界面转化为py文件，即生成以下6个文件。<br><img src="https://i.imgtg.com/2023/07/23/Oh4d0a.png#id=Db9OC&originHeight=491&originWidth=1363&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🩳设计代码"><a href="#🩳设计代码" class="headerlink" title="🩳设计代码"></a>🩳设计代码</h3><p>对每一个UI界面进行调用并初始化窗口，设置事件处理程序等即可完成每一部分对应的功能设计。<br>Cameramain主要实现的是实时监测的功能设计，主要完成界面跳转、开启摄像头、识别摄像头所拍摄的内容并进行人体骨骼图识别、根据所指定的规则进行坐姿判断、实时输出、截图保存，截取视频图片等相关功能。<br>Main主要实现的是计时功能，主要完成点击开始计时以及动态清零的操作，界面上还实时显示当前日期以及天气，并能通过点击按钮就进行界面的跳转功能。<br>Picturemain主要实现的是图像监测功能，主要实现界面跳转，导入图片并进行骨骼图识别和坐姿检测，截图保存功能。<br>vis_sitting_main主要实现的是坐姿情况的可视化操作，能够根据实时监测的内容实时生成可视化数据图，这个界面的图标主要包括坐姿情况周报和坐姿情况年度统计图两张，并能实现界面跳转功能。<br>vis_tired_main主要实现的是疲劳情况的可视化操作，能够根据实时监测的内容生成可视化数据图，围绕趴着、打哈欠、伸懒腰的次数进行展开，该界面共有三张数据图，分别为疲劳情况周报、疲劳情况雷达图和疲劳情况月报，并能实现界面跳转功能。<br>vis_total_main主要实现的是坐姿总体情况的可视化操作，共有三张可视化的图标，分别显示坐姿总体的良好率、坐姿情况分析图和坐姿状况分析图三项，同时左下角能够实时生成正确坐姿、错误坐姿和疲劳的次数，并能实现界面跳转功能。</p><h3 id="🩳可视化部分"><a href="#🩳可视化部分" class="headerlink" title="🩳可视化部分"></a>🩳可视化部分</h3><p>该软件将所有可视乎代码嵌入主程序，使修改以及调用更为方便。同时也单独将每一格式化图标区分到一个python文件中，使得用户可是直接后台打开对应可视化文件的html文件，直接对此进行保存或者交互，更直观的了解自己的坐姿以及疲劳情况。</p><h1 id="👕作品效果图"><a href="#👕作品效果图" class="headerlink" title="👕作品效果图"></a>👕作品效果图</h1><h2 id="👖I-SIT坐姿监测系统（软件系统）"><a href="#👖I-SIT坐姿监测系统（软件系统）" class="headerlink" title="👖I SIT坐姿监测系统（软件系统）"></a>👖I SIT坐姿监测系统（软件系统）</h2><h3 id="🩳计时界面"><a href="#🩳计时界面" class="headerlink" title="🩳计时界面"></a>🩳计时界面</h3><p><img src="https://i.imgtg.com/2023/07/23/Oh4fDC.md.png#id=iRMJA&originHeight=500&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🩳照片检测"><a href="#🩳照片检测" class="headerlink" title="🩳照片检测"></a>🩳照片检测</h3><p><img src="https://i.imgtg.com/2023/07/23/Oh4jxi.md.png#id=uOzEZ&originHeight=500&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🩳实时检测"><a href="#🩳实时检测" class="headerlink" title="🩳实时检测"></a>🩳实时检测</h3><p><img src="https://i.imgtg.com/2023/07/23/Oh4swS.md.png#id=xjhu3&originHeight=500&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="👖I-SIT坐姿情况可视化（可视化系统）"><a href="#👖I-SIT坐姿情况可视化（可视化系统）" class="headerlink" title="👖I SIT坐姿情况可视化（可视化系统）"></a>👖I SIT坐姿情况可视化（可视化系统）</h2><h3 id="🩳坐姿总体情况"><a href="#🩳坐姿总体情况" class="headerlink" title="🩳坐姿总体情况"></a>🩳坐姿总体情况</h3><p><img src="https://i.imgtg.com/2023/07/23/Oh4l8L.md.png#id=XsoNQ&originHeight=500&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🩳坐姿情况"><a href="#🩳坐姿情况" class="headerlink" title="🩳坐姿情况"></a>🩳坐姿情况</h3><p><img src="https://i.imgtg.com/2023/07/23/Oh4Y1N.md.png#id=nahKE&originHeight=500&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🩳疲劳情况"><a href="#🩳疲劳情况" class="headerlink" title="🩳疲劳情况"></a>🩳疲劳情况</h3><p><img src="https://i.imgtg.com/2023/07/23/Oh42pX.md.png#id=cyEL0&originHeight=500&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="👕设计思路"><a href="#👕设计思路" class="headerlink" title="👕设计思路"></a>👕设计思路</h1><h2 id="👖界面设计"><a href="#👖界面设计" class="headerlink" title="👖界面设计"></a>👖界面设计</h2><h3 id="🩳I-SIT坐姿监测系统"><a href="#🩳I-SIT坐姿监测系统" class="headerlink" title="🩳I SIT坐姿监测系统"></a>🩳I SIT坐姿监测系统</h3><p>该软件可以分为三个部分，分别是计时部分、静止图像坐姿检测、实时监控坐姿检测。</p><ul><li><strong>计时部分：</strong></li></ul><p>界面主要由两部分组成，上方为本软件的形象图—一个坐着的卡通小人，右上方则是计时部分；而下方则是当前时间、天气以及明后4天的天气情况，最下方共有3个按钮，“开始计时”按钮和“动态清零”按钮主要用于用户计时。点击“首页”即可进入软件主界面。</p><ul><li><strong>图像检测：</strong></li></ul><p>界面主要由两个部分组成，左边为I SIT坐姿监测系统的导航栏，右边则是图像检测的主界面。在主界面中，通过点击“导入图片”，用户即可选择对应的图片进行图像坐姿识别，并将结果显示到界面下方，点击“保存结果”按钮，即可对当前界面进行截图保存。</p><ul><li><strong>实时检测：</strong></li></ul><p>在左侧导航栏点击相应界面的名称，即可进入对应界面。实时检测界面与图像检测界面相似，主要由两个部分组成，左边为I SIT坐姿监测系统的导航栏，右边则是实时检测的主界面。在主界面中，上方为图像显示区域以及操作按钮区域。共有4个按键——“连接电脑摄像头”、“关闭摄像头”、“截图保存”、“截取视频图片”。<br>用户点击连接摄像头，则开始实时坐姿识别，所识别得到的坐姿情况会实时输出在界面的右下方“当前坐姿情况”处。用户点击“截取视频图片”并选择对应路径和命名，就可以保存当前摄像头下的照片。于此同时，也可以点击“保存结果”按钮，即可对当前界面进行截图保存。用户点击“关闭摄像头”，则实时监测结束。<br>界面左下方显示当前时间和日期，用户在实时监测完后，可以通过点击下方“坐姿情况”按钮，跳转到坐姿情况可视化界面。</p><h3 id="🩳I-SIT坐姿情况可视化系统"><a href="#🩳I-SIT坐姿情况可视化系统" class="headerlink" title="🩳I SIT坐姿情况可视化系统"></a>🩳I SIT坐姿情况可视化系统</h3><p>该软件可以分为三个部分，分别是坐姿总体情况部分、坐姿情况和疲劳情况。</p><ul><li><strong>坐姿总体情况：</strong></li></ul><p>坐姿总体情况界面同样，左边为导航栏界面，右边为具体可视化情况，共有三张可视化图，分别为坐姿总体良好率，其中良好率为正确坐姿次数&#x2F;总体监测次数，通过水滴图的形成呈现；坐姿情况分析图则以玫瑰图的形式展现，分别记录初正确坐姿之外的其余9种坐姿，通过玫瑰图可以形象生动的显示出哪种坐姿出现次数最为多，可以对此有相应的改正计划；右下角为坐姿状况分析，共分为4种情况——良好、轻微、中度、严重。根据我们对于不同坐姿的权重加合得到对应的数据，并根据其所在范围得到对应的次数生成此图，来得到坐姿错误的严重程度。左下角则直接显示了正确坐姿、错误坐姿和疲劳的次数，简单明了。</p><ul><li><strong>坐姿情况：</strong></li></ul><p>坐姿情况界面同样，左边为导航栏界面，右边为具体可视化情况，共有两张可视化图，上方为坐姿情况周报，下方为坐姿情况年度统计，分别通过折线图以及日历图来显示不同坐姿的发生次数来形象的显示坐姿情况。右上角则放置了一段坐姿正确口诀来呼吁用户坐姿正确。</p><ul><li><strong>疲劳情况：</strong></li></ul><p>疲劳情况的主界面共有3张可视化图表，上方为一章疲劳情况周报，根据当日用户的坐姿情况来对表中数据进行修改，得到近期一周曲线图，通过曲线图可以得到该用户的坐姿改变曲线。左下方为疲劳情况雷达图，上面具体显示了趴写、伸懒腰、打哈欠三种坐姿的发生次数，可以通过该图得知用户是否近期疲劳，需要休息。右侧则为疲劳情况月报，通过饼图轮播图的形式，对12个月每个月的坐姿情况进行轮播。右上角为缓解疲劳的方法，来呼吁用户及时休息，合理安排时间。左下角点击退出即可退出软件。</p><h2 id="👖关键算法"><a href="#👖关键算法" class="headerlink" title="👖关键算法"></a>👖关键算法</h2><h3 id="🩳坐姿检测规则"><a href="#🩳坐姿检测规则" class="headerlink" title="🩳坐姿检测规则"></a>🩳坐姿检测规则</h3><p>在上一部分有详细介绍过，因此这篇不做过多介绍</p><h3 id="🩳PyECharts的使用"><a href="#🩳PyECharts的使用" class="headerlink" title="🩳PyECharts的使用"></a>🩳PyECharts的使用</h3><p>在数据可视化系统部分，主要使用的是开源库pyecharts。pyecharts 是一个用于生成 Echarts 图表的类库。Echarts是由百度开发的一个数据可视化开源JS 库。可视化类型多，效果也非常好，但是使用时需要通过导入js库在Java Web项目上运行，使用比较复杂。pyecharts 是一个国人开发的一个Echarts与Python结合的类库，为了与 Python 进行对接，方便在 Python 中直接使用数据生成图。pyecharts可以生成动态网页来展示数据。<br>在软件设计过程中，通过1.导包2.创建一个图对象3.添加数据4.设置全局配置项5.通过render方法将代码生成图像的方式，即可对我们所限要的数据进行可视化。需要注意的是，将数据从不同文件中传输，一定要使用全局函数进行全局变量的传输。</p><h1 id="👕主要测试"><a href="#👕主要测试" class="headerlink" title="👕主要测试"></a>👕主要测试</h1><p>本次测试对坐姿检测系统在各种情况下的可靠性、稳定性和性能，包括但不限于系统的功能、响应速度、准确性和鲁棒性。</p><h2 id="👖图片检测系统测试"><a href="#👖图片检测系统测试" class="headerlink" title="👖图片检测系统测试"></a>👖图片检测系统测试</h2><p>针对我们定义的九种错误坐姿，我们这里对每一种坐姿选取了不同的用户进行测试。<br>准确度：测试了不同用户在不同光照环境下的坐姿情况，准确度高。</p><table><thead><tr><th>光照类型</th><th>坐姿类型</th><th>输入图片数量</th><th>检测正确数量</th><th>检测准确率</th></tr></thead><tbody><tr><td>强光</td><td>正确坐姿</td><td>134</td><td>128</td><td>95.52%</td></tr><tr><td></td><td>头左倾</td><td>123</td><td>99</td><td>80.49%</td></tr><tr><td></td><td>头右倾</td><td>142</td><td>129</td><td>90.85%</td></tr><tr><td></td><td>左手挠头</td><td>122</td><td>110</td><td>90.16%</td></tr><tr><td></td><td>右手挠头</td><td>111</td><td>102</td><td>91.89%</td></tr><tr><td></td><td>左手托腮</td><td>123</td><td>111</td><td>90.24%</td></tr><tr><td></td><td>右手托腮</td><td>113</td><td>101</td><td>89.38%</td></tr><tr><td></td><td>打哈欠</td><td>115</td><td>101</td><td>87.83%</td></tr><tr><td></td><td>伸懒腰</td><td>121</td><td>111</td><td>91.74%</td></tr><tr><td></td><td>趴着</td><td>114</td><td>102</td><td>89.47%</td></tr><tr><td>弱光</td><td>正确坐姿</td><td>133</td><td>120</td><td>90.23%</td></tr><tr><td></td><td>头左倾</td><td>112</td><td>101</td><td>90.18%</td></tr><tr><td></td><td>头右倾</td><td>115</td><td>90</td><td>78.26%</td></tr><tr><td></td><td>左手挠头</td><td>121</td><td>103</td><td>85.12%</td></tr><tr><td></td><td>右手挠头</td><td>114</td><td>100</td><td>87.72%</td></tr><tr><td></td><td>左手托腮</td><td>116</td><td>101</td><td>87.07%</td></tr><tr><td></td><td>右手托腮</td><td>101</td><td>90</td><td>89.11%</td></tr><tr><td></td><td>打哈欠</td><td>119</td><td>103</td><td>86.55%</td></tr><tr><td></td><td>伸懒腰</td><td>114</td><td>107</td><td>93.86%</td></tr><tr><td></td><td>趴着</td><td>111</td><td>99</td><td>89.19%</td></tr><tr><td>自然光</td><td>正确坐姿</td><td>111</td><td>100</td><td>90.09%</td></tr><tr><td></td><td>头左倾</td><td>121</td><td>102</td><td>84.30%</td></tr><tr><td></td><td>头右倾</td><td>109</td><td>100</td><td>91.74%</td></tr><tr><td></td><td>左手挠头</td><td>134</td><td>122</td><td>91.04%</td></tr><tr><td></td><td>右手挠头</td><td>123</td><td>110</td><td>89.43%</td></tr><tr><td></td><td>左手托腮</td><td>113</td><td>103</td><td>91.15%</td></tr><tr><td></td><td>右手托腮</td><td>119</td><td>113</td><td>94.96%</td></tr><tr><td></td><td>打哈欠</td><td>113</td><td>102</td><td>90.27%</td></tr><tr><td></td><td>伸懒腰</td><td>131</td><td>121</td><td>92.37%</td></tr><tr><td></td><td>趴着</td><td>122</td><td>110</td><td>90.16%</td></tr><tr><td></td><td>正确坐姿</td><td>120</td><td>109</td><td>90.83%</td></tr></tbody></table><p>检测速度：用户导入图片后点击提交，一秒内自动识别当前的坐姿情况，并且可以在下方实时输出检测结果。<br><img src="https://i.imgtg.com/2023/07/23/Oh4I0p.md.png#height=415&id=WI8MS&originHeight=500&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=774"><br><img src="https://i.imgtg.com/2023/07/23/Oh4uKj.md.png#height=414&id=FBcI9&originHeight=500&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=772"></p><h2 id="👖实时检测系统测试"><a href="#👖实时检测系统测试" class="headerlink" title="👖实时检测系统测试"></a>👖实时检测系统测试</h2><h3 id="🩳检测结果测试"><a href="#🩳检测结果测试" class="headerlink" title="🩳检测结果测试"></a>🩳检测结果测试</h3><p>准确度：每隔一帧截取一次画面，并检测当前的坐姿情况，准确度较高。</p><table><thead><tr><th>光照</th><th>用户</th><th>检测坐姿次数</th><th>检测正确次数</th><th>检测准确率</th></tr></thead><tbody><tr><td>强光</td><td>1</td><td>121</td><td>113</td><td>93.39%</td></tr><tr><td></td><td>2</td><td>99</td><td>85</td><td>89.90%</td></tr><tr><td></td><td>3</td><td>100</td><td>89</td><td>89.00%</td></tr><tr><td>弱光</td><td>1</td><td>103</td><td>91</td><td>88.35%</td></tr><tr><td></td><td>2</td><td>109</td><td>92</td><td>84.40%</td></tr><tr><td></td><td>3</td><td>111</td><td>94</td><td>84.68%</td></tr><tr><td>自然光</td><td>1</td><td>110</td><td>103</td><td>93.64%</td></tr><tr><td></td><td>2</td><td>121</td><td>115</td><td>95.04%</td></tr><tr><td></td><td>3</td><td>119</td><td>109</td><td>91.60%</td></tr></tbody></table><p>运行速度：实时坐姿检测系统可以在不到200毫秒的时间内完成一次检测，并以25帧&#x2F;秒的帧率检测图像。系统的数据处理时间为50毫秒，而服务器响应时间则为20毫秒。通过这些指标，可以看出本系统具有较快的检测速度和高效的数据处理能力。同时，系统可以适应不同的硬件配置和网络环境，保证在不同的使用场景下都能具有优异的性能表现。<br>可用性：我们的实时坐姿检测系统能够准确地识别和分析用户的坐姿姿势，跟我们之前定义的九种错误坐姿和正确坐姿，可以快速的检测到当前坐姿情况。此外，还可以实时检测和反馈用户的坐姿状态，以帮助用户及时纠正错误的姿势，避免长时间的错误姿势导致的身体不适。并且具有高度的可靠性，不会出现误判或漏检的情况，从而保证用户使用时的安全性和准确性。</p><h3 id="🩳可视化测试"><a href="#🩳可视化测试" class="headerlink" title="🩳可视化测试"></a>🩳可视化测试</h3><p>根据实时检测连接摄像头收集的数据，我们可以将结果可视化为相关的图表。<br>左上角的坐姿情况分析图可以直观的展示在一段时间内的坐姿情况。右边的坐姿情况分析图表示每种坐姿在监测时间内出现的次数。色块越大，说明在这段时间内的该种姿态出现次数越多。可以看到当前的可视化结果与之前的检测结果相符。<br>下方使用数字来呈现这段时间内的坐姿情况， 经测试可以发现与检测收集的数据相符。右边模块是坐姿状况分析图。我们定义了严重、轻微、良好、中度四个等级，根据这段时间出现次数的占比来定义。<br>然后是坐姿情况模块，为了演示方便这里我们提前设定了一些数据，然后根据刚刚测试生成的数据，当前是哪一天就修改坐姿情况周报模块中的数据，可以看到测试结果与与其相符。坐姿情况年度统计图也是为了演示方便提前设定的数据。<br><img src="https://i.imgtg.com/2023/07/23/OhDMHv.md.png#id=IaPk7&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://i.imgtg.com/2023/07/23/Oh4w1Y.md.png#id=zeKZ0&originHeight=500&originWidth=802&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>最后是疲劳情况统计模块，疲劳情况周报、月报和上文中提到的坐姿情况相同，根据当前测试天数修改数据。疲劳情况雷达图也根据此前收集的测试数据生成，可以看到收集的数据与可视化结果相符合。<br><img src="https://i.imgtg.com/2023/07/23/Oh4CMU.md.png#id=zJ2r3&originHeight=500&originWidth=815&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="👖测试总结"><a href="#👖测试总结" class="headerlink" title="👖测试总结"></a>👖测试总结</h2><p>根据我们的测试，在不同光线条线下进行测试，我们可以发现在弱光下的识别准确率相较于强光下的准确率较低。此外，在测试的过程中我们还发现用户使用的背景，包括但不限于单色背景、复杂背景，以及用户的不同衣服穿着都有可能影响坐姿检测的准确度。但是总体来说，我们的坐姿检测系统的检测成功率还是比较高，有很强的可用性。</p><h1 id="👕项目总结"><a href="#👕项目总结" class="headerlink" title="👕项目总结"></a>👕项目总结</h1><h2 id="👖项目目标"><a href="#👖项目目标" class="headerlink" title="👖项目目标"></a>👖项目目标</h2><p>本项目是基于家庭摄像头对儿童坐姿进行检测的一种智能化、实时性的设备。该设备不同于目前市面上的以相关实体矫正器为载体的青少年正确坐姿的提醒与矫正的设备，“I SIT——坐姿监测系统及可视化设计”旨在基于视频捕获青少年的各种坐姿，同时基于计算机视觉技术提取人体骨架，通过对骨架姿态的识别来对青少年的坐姿进行判断。产品定位是<strong>协助青少年培养良好的坐姿习惯</strong>，而不是强迫用户去改变。<br><strong>软件平台</strong>通过信息技术，主要实现四大功能，满足用户的需要。在软件内，用户可以查看<strong>使用时长和坐姿良好率</strong>，来随时掌握自己的动态，在每次检测后，会<strong>自动生成报告</strong>，进入“查看报告”中，可以查看每天、每周、每月的坐姿情况，查看自己<strong>坐姿良好率的变化</strong>。</p><h2 id="👖项目设计重点"><a href="#👖项目设计重点" class="headerlink" title="👖项目设计重点"></a>👖项目设计重点</h2><p>前端设计的重点主要是通过Pyqt5实现软件界面的搭建，并且通过开源工具Pyecharts实现坐姿数据可视化的展现。<br>后端设计的重点主要是坐姿检测算法的实现。在算法设计初，我们已经假设了几种错误坐姿情况如下表：</p><table><thead><tr><th><strong>错误坐姿</strong></th><th></th></tr></thead><tbody><tr><td><strong>可根据手部动作进行判断</strong></td><td><strong>可根据头部&#x2F;腰部动作判断</strong></td></tr><tr><td>1  左&#x2F;右手托腮</td><td>5  头左&#x2F;右倾斜</td></tr><tr><td>2  左&#x2F;右手挠头</td><td>6  高低肩</td></tr><tr><td>3  打哈欠</td><td>7  腰背左右倾斜</td></tr><tr><td>4  伸懒腰</td><td>8  趴写</td></tr></tbody></table><p>针对这些错误坐姿，实现坐标检测方法。通过对人体骨骼点的识别，实现骨骼图的搭建，通过人体关节骨骼点以及人体运动相关知识判断当前的坐姿动作，经过多次优化与改进，坐标检测算法准确度显著上升。</p><h2 id="👖项目设计难点"><a href="#👖项目设计难点" class="headerlink" title="👖项目设计难点"></a>👖项目设计难点</h2><h3 id="🩳电脑软件的搭建困难"><a href="#🩳电脑软件的搭建困难" class="headerlink" title="🩳电脑软件的搭建困难"></a>🩳电脑软件的搭建困难</h3><p>在电脑软件的搭建过程中，我们所使用的是pyqt5进行界面的设计，通过Pycharm进行与后端的连接。</p><ol><li>软件界面对于结果的保存的困难<ol><li>在最初构思PC端软件时，我们预期将监测的数据通过可视化的形式能够进行导出，但由于技术的限制以及可能需要连接后端数据库，最终我们还是没有能实现这一功能，这也是后续我们需要再次进行改进的。</li></ol></li><li>Pyechart图表渲染速度慢、缺乏高级可视化功能<ol><li>在数据量较大的情况下，Pyecharts渲染图表的速度可能会比较慢。我们进行了部分改进，采用数据分块，以此对数据和图表进行优化。</li><li>缺乏一些高级可视化功能：尽管 Pyecharts 提供了许多图表类型和配置选项，但是在我们的项目中需要一些高级的可视化功能，例如多维度数据分析和可视化、图表动态更新，这些功能在Pyecharts中暂时无法直接呈现。</li></ol></li></ol><h3 id="🩳用坐标来判断的不准确和困难"><a href="#🩳用坐标来判断的不准确和困难" class="headerlink" title="🩳用坐标来判断的不准确和困难"></a>🩳用坐标来判断的不准确和困难</h3><ol><li><strong>设置规则的普遍性不高</strong></li></ol><p>在初步设置完坐标检测规则，投入测试的时候，会出现这样的情况：编写人员用自己做测试时准确率很高的坐标检测规则，再由其他人测试某些坐姿的时候会出现严重错误，这是由于每个人的骨架关键点的相对位置可能有较大的差距，因此某些规则设置的普遍性较差。</p><ol start="2"><li><strong>坐标检测的准确度较低</strong></li></ol><p>使用坐标判定需要依赖预先训练好的模型，因此模型的训练数据、算法、参数等都可能影响坐姿检测的准确性，而且不同的人群、肢体形态、坐姿姿态等也可能对模型的训练产生影响。在测试的过程中，我们不断推翻初版的检测规则，对于不同人群的检测准确度始终很低。在此期间，成员提出利用向量关系来加强某些坐姿检测规则，测试发现，加上向量规则的约束可以再一定程度上提高坐标检测的准确率。</p><ol start="3"><li><strong>部分坐姿检测规则过于相似引起检测错误</strong></li></ol><p>在我们的项目中，存在一些相似的错误坐姿，例如挠头、托腮，这两组错误因为是解决上十分相似，此外，成员设置的检测规则也基于同一个原理，所以会导致两组错误坐姿出现混淆。在这里采取了将某一种检测概率较大的坐姿情况置于后面，代码顺序执行时先判断检测成功率不高的坐姿情况是否成立，若成立，则终止；否则继续向下检测。</p><ol start="4"><li><strong>某些伴随坐姿会干扰检测结果</strong></li></ol><p>在项目中，设置了头倾斜这类错误坐姿，但是设置的其他错误坐姿通常伴随着头倾斜坐姿，因此测试结果会因为检测到头倾斜而不继续检测其他坐姿，导致检测准确度下降。而且头倾斜错误坐姿的判定标准不太明显，设置规则会出现过于灵敏或过于迟钝的表现效果。</p><ol start="5"><li><strong>精度问题</strong></li></ol><p>使用坐标判定需要根据预设坐标系和阈值进行判断，因此对于不同的坐姿判定精度可能有所差异，例如判断头部偏斜的角度、判断手臂和腿部的角度等。对此，我们对不同部位进行了不同的阈值设计，以此提高精度。</p><ol start="6"><li><strong>实时性问题</strong></li></ol><p>在实际应用场景中，需要对被测试者的坐姿状态进行实时监控和判定，而且需要快速反馈结果，这可能会对坐姿检测的实时性提出较高的要求，可以采用多线程、GPU加速等技术提高坐姿检测的实时性，同时还可以采用合适的数据传输、数据存储等方法提高数据处理和传输的速度和效率。</p>]]></content>
      
      
      <categories>
          
          <category> 科研项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全技术——DES和RSA加密解密程序</title>
      <link href="/2023/05/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DES%E5%92%8CRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DES%E5%92%8CRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="🍹题目要求"><a href="#🍹题目要求" class="headerlink" title="🍹题目要求"></a>🍹题目要求</h1><p>用Java语言设计并实现DES和RSA加密解密程序。<br>利用实现的DES加密解密程序分别对字符串、文本、图像等数据进行加密和解密。<br>利用实现的RSA加密解密程序对文本加密和解密，并与DES算法进行效率对比。</p><h1 id="🍹算法思路"><a href="#🍹算法思路" class="headerlink" title="🍹算法思路"></a>🍹算法思路</h1><h2 id="🍬DES算法"><a href="#🍬DES算法" class="headerlink" title="🍬DES算法"></a>🍬DES算法</h2><p>数据加密标准（Data Encryption Standard，简称DES）是一种对称加密算法，于1977年由美国国家标准与技术研究院（NIST）正式发布。DES算法使用相同的密钥进行加密和解密操作。该算法基于分组密码设计原则，将明文分为固定大小（64位）的块，然后对每个块进行加密。DES使用一个56位的密钥，但其密钥长度实际上为64位（其中8位用于奇偶校验）。<br>DES加密算法的主要步骤如下：</p><ol><li><strong>初始置换</strong>：将64位明文输入块进行置换（重新排列）操作。初始置换表定义了明文位的重新排列规则。</li><li><strong>密钥处理</strong>：对于给定的56位密钥，使用密钥调度算法（key schedule）生成16个48位的子密钥，这些子密钥将在接下来的加密过程中使用。</li><li><strong>16轮迭代</strong>：DES算法进行16轮迭代操作，每轮迭代包括以下步骤： <ul><li><strong>扩展置换</strong>：将32位的右半部分进行扩展置换，得到一个48位的数据块。</li><li><strong>子密钥异或</strong>：将扩展后的数据块与对应轮的子密钥进行异或操作。</li><li><strong>S-盒替换</strong>：将异或后的48位数据块划分为8个6位的分组，然后使用8个S-盒（替换盒）将每个6位分组映射为4位的输出。S-盒的设计是DES安全性的关键。</li><li><strong>P-盒置换</strong>：将S-盒的输出进行P-盒置换，重新排列比特，得到一个32位的数据块。</li><li><strong>左右交换与混合</strong>：最后，将P-盒置换后的32位数据与输入的左半部分进行异或，得到下一轮迭代的右半部分。同时，本轮的右半部分变为下一轮的左半部分。</li></ul></li><li><strong>最终交换</strong>：在16轮迭代完成后，将最后一轮的左右半部分合并，并进行最终置换，即初始置换的逆置换，得到64位的密文输出。</li></ol><p>解密过程与加密过程类似，只需使用相同的密钥进行逆操作即可。注意，解密时使用的子密钥顺序与加密时相反。</p><h2 id="🍬RSA算法"><a href="#🍬RSA算法" class="headerlink" title="🍬RSA算法"></a>🍬RSA算法</h2><p>RSA加密算法是一种非对称加密算法，于1978年由Ron Rivest、Adi Shamir和Leonard Adleman提出，算法名称就是根据他们的名字首字母得来。非对称加密意味着加密和解密过程使用不同的密钥。在RSA算法中，有一对密钥：公钥和私钥。公钥用于加密数据，私钥用于解密数据。通常，公钥是公开的，任何人都可以用它加密数据；私钥是保密的，仅拥有者可以用它解密数据。<br>RSA加密算法的原理基于数论和大数计算。以下是算法的主要步骤：</p><ol><li>选择两个大质数 ${p}$ 和 ${q}$ 。</li><li>计算 ${n &#x3D; p\times q}$ 。 ${n}$ 用于构建公钥和私钥，是模数。</li><li>计算欧拉函数 ${\varphi(n) &#x3D; (p-1)(q-1)}$ 。</li><li>选择一个整数 ${e}$ ，使得 ${1 &lt; e &lt; \varphi(n)}$ ，且 ${e}$ 与 ${\varphi(n)}$ 互质 $ {(gcd(e, \varphi(n)) &#x3D; 1)} $ 。 ${e}$ 是公钥的一部分。</li><li>计算整数 ${d}$ ，使得 ${d ≡ e^{-1}(mod \varphi(n))}$ 。换句话说，找到一个数 ${d}$ ，满足 ${ed \equiv 1 (mod \varphi(n))}$ 。 ${d}$ 是私钥的一部分。</li><li>公钥为 $(n, e)$ ，私钥为 $(n, d)$ 。</li></ol><p>加密和解密的过程如下：</p><ol><li>加密：假设明文消息为 ${M(0 &lt; M &lt; n)}$，密文C可以通过以下公式计算： ${C ≡ M^e (mod n)}$。</li><li>解密：已知密文 ${C}$，明文消息 ${M}$可以通过以下公式计算： ${M ≡ C^d (mod n)}$。</li></ol><p>RSA算法的安全性依赖于大数因子分解的困难性，即随着密钥长度( ${n}$ 的位数)的增加，攻击难度呈指数级增长。给定 ${n}$ 的值，分解出 ${p}$ 和 ${q}$ 是非常困难的，特别是当 ${p}$ 和 ${q}$ 都是大质数时。目前，尚无已知的高效算法能够在合理时间内分解大数${n}$</p><h1 id="🍹实现思路"><a href="#🍹实现思路" class="headerlink" title="🍹实现思路"></a>🍹实现思路</h1><h2 id="🍬DES算法-1"><a href="#🍬DES算法-1" class="headerlink" title="🍬DES算法"></a>🍬DES算法</h2><ol><li>首先根据DES算法的具体步骤，定义每一步所需要使用的矩阵；</li><li>接着，根据DES算法的过程，定义在DES算法中会使用到的函数。特别要说明的是在本算法中，实现了任何长度的密钥加密，因此定义了publicstaticbyte[]DataFormat(byte[] data)来实现了对秘钥的扩展。</li><li>最后开始正式实现DES算法：<ol><li>定义publicstaticbyte[]DesEncrypt(byte[] des_data,int flag)其中，DesEncrypt方法接收待加密&#x2F;解密的数据和一个标志位flag，用于指示执行加密或解密操作。在方法内部，首先将传入的密钥和数据进行格式化处理，然后按照ECB模式对数据进行加解密操作。ECB模式是一种基础的分组密码加密模式，它将明文数据按照固定长度分组，并对每个分组进行加密处理。</li><li>接着，如果flag为0，则表示执行解密操作。此时需要去掉加密时产生的填充位，具体做法是从加密结果中读取最后一个分组的最后一个字节，该字节记录了填充的长度。然后根据填充长度计算出实际的解密数据长度，并将解密数据复制到decryptbytearray数组中返回。</li><li>最后，无论执行加密还是解密操作，result_data数组都会被返回。如果flag为1，则表示执行加密操作，返回加密结果；如果flag为0，则表示执行解密操作，返回解密结果。</li></ol></li></ol><ul><li>本算法实现了对字符串、文本、图像等数据的加密和解密。通过终端直接输入密钥和想要加密的字符串即可进行加密输出，在对应的文件夹中存入想要加密的文件，即可在解密，密文文件夹发现相应的加解密文件。</li></ul><h2 id="🍬RSA算法-1"><a href="#🍬RSA算法-1" class="headerlink" title="🍬RSA算法"></a>🍬RSA算法</h2><ol><li>首先，程序生成一个RSA密钥对：一个公钥和一个私钥。公钥用于加密，私钥用于解密。具体来说，程序通过Java的KeyPairGenerator类生成了一个1024位的RSA密钥对，并将其存储在HashMap中以便后续使用。</li><li>接下来，程序演示了如何使用模和指数来生成公钥和私钥。模是大质数的乘积，而指数是一个小质数。程序根据给定的模和指数生成了相应的公钥和私钥。</li><li>然后，程序演示了如何使用公钥加密一个明文。在加密过程中，程序首先使用Java的Cipher类创建了一个RSA实例，并将其初始化为加密模式。然后，程序计算出加密数据长度并将明文分成若干个块进行加密。最后，程序将所有加密后的块连接起来得到密文。</li><li>最后，程序演示了如何使用私钥解密密文。在解密过程中，程序首先使用Java的Cipher类创建了一个RSA实例，并将其初始化为解密模式。然后，程序将密文分成若干个块进行解密，并将所有解密后的块连接起来得到明文。</li></ol><h1 id="🍹运行结果"><a href="#🍹运行结果" class="headerlink" title="🍹运行结果"></a>🍹运行结果</h1><h2 id="🍬DES加密解密算法"><a href="#🍬DES加密解密算法" class="headerlink" title="🍬DES加密解密算法"></a>🍬DES加密解密算法</h2><p>在明文文件夹中存入以下文件：<br><img src="https://s1.ax1x.com/2023/05/12/p9yOdRU.png#id=pter0&originHeight=362&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>运行项目，输入密钥wxy0409，输入字符串2020218090，可以得到如下所示的结果：<br><img src="https://s1.ax1x.com/2023/05/12/p9yOUiV.png#id=Ca1u3&originHeight=449&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>可以看到经过DES加密和解密后的字符串与原来输入的字符串相同，同时在密文文件夹中出现了经过加密后的文件，在解密文件夹中出现如下所示的文件：<br><img src="https://s1.ax1x.com/2023/05/12/p9yOwzF.png#id=s2uGc&originHeight=366&originWidth=1059&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/12/p9yOBM4.png#id=chGSQ&originHeight=327&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><p>将加密前后的文件进行对比，可以发现本项目成果符合预期。<img src="https://s1.ax1x.com/2023/05/12/p9yOaGT.png#id=rMfTi&originHeight=346&originWidth=1706&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/12/p9yOrL9.png#id=ESzj3&originHeight=1156&originWidth=2240&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 33%;" /></p><p>test3和test4也与实验预期相符，这里不过多赘述。</p><h2 id="🍬RSA加密解密算法"><a href="#🍬RSA加密解密算法" class="headerlink" title="🍬RSA加密解密算法"></a>🍬RSA加密解密算法</h2><p>利用实现的RSA加密解密程序对文本加密和解密，因此这一部分直接在程序中定义了所要进行加解密的文本字符串，是编程更为简单。运行结果如下图所示：<br><img src="https://s1.ax1x.com/2023/05/12/p9yODsJ.png#id=fEnto&originHeight=430&originWidth=1857&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><h2 id="🍬RSA加密解密算法与DES算法进行效率对比"><a href="#🍬RSA加密解密算法与DES算法进行效率对比" class="headerlink" title="🍬RSA加密解密算法与DES算法进行效率对比"></a>🍬RSA加密解密算法与DES算法进行效率对比</h2><p>RSA 是一种公钥加密算法，其安全性基于大质数分解难题和离散对数难题。RSA 加密和解密速度较慢，计算复杂度高，适合对数据量较小、安全性要求较高的场合。RSA 算法可以用于数字签名、证书认证等方面。<br>DES 是一种对称加密算法，其安全性基于密钥长度。DES 加密和解密速度很快，计算复杂度低，适合对数据量较大、且对加密解密速度有要求的场合。DES 算法主要应用于数据加密通信、文件加密和存储等方面。<br>RSA 适合加密较小的数据，如密钥、数字签名等，而 DES 适合加密较大的数据，如文件传输等。在实际应用中，可以根据数据量大小、安全性要求和加密解密速度要求等因素综合考虑，选择合适的加密算法。</p><h1 id="🍹程序代码"><a href="#🍹程序代码" class="headerlink" title="🍹程序代码"></a>🍹程序代码</h1><p>程序代码已上传至Github</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF-DES%E5%92%8CRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A8%8B%E5%BA%8F">Cassie&#x2F;信息安全技术-DES和RSA加密解密程序 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程作业 </category>
          
          <category> 信息安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程作业 </tag>
            
            <tag> 信息安全技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——绪论</title>
      <link href="/2023/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/"/>
      <url>/2023/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="🎰绪论"><a href="#🎰绪论" class="headerlink" title="🎰绪论"></a>🎰绪论</h1><p><img src="https://s2.loli.net/2023/06/08/tsG27INXYMZv6h3.png#height=736&id=GE7fB&originHeight=981&originWidth=1595&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1196"></p><h2 id="🎮时间复杂度"><a href="#🎮时间复杂度" class="headerlink" title="🎮时间复杂度"></a>🎮时间复杂度</h2><p>一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。<br>O表示T（n）与f（n）在n趋向于正无穷时为同阶无穷大<br>算法的时间复杂度记为：T(n)&#x3D;O(f(n))，O的含义是T(n)的数量级</p><h2 id="🎮空间复杂度"><a href="#🎮空间复杂度" class="headerlink" title="🎮空间复杂度"></a>🎮空间复杂度</h2><p>算法的空间复杂度S(n)定义为该算法<strong>所消耗的存储空间</strong>，它是问题规模n的函数，记为S(n)&#x3D;O(g(n))</p><h2 id="🎮数的逻辑结构"><a href="#🎮数的逻辑结构" class="headerlink" title="🎮数的逻辑结构"></a>🎮数的逻辑结构</h2><p>逻辑结构指的是数据元素之间的逻辑关系，与数的存储结构无关，是独立于计算机的<br>分类图如下所示：<br><img src="https://s2.loli.net/2023/06/08/5gybErHZGPLvzQR.png#height=266&id=sv4wW&originHeight=531&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=825"></p><h2 id="🎮数的存储结构"><a href="#🎮数的存储结构" class="headerlink" title="🎮数的存储结构"></a>🎮数的存储结构</h2><p>存储结构是指数据结构在计算机中的表示，也称物理结构，主要分为4种：</p><h3 id="🧵顺序存储"><a href="#🧵顺序存储" class="headerlink" title="🧵顺序存储"></a>🧵顺序存储</h3><p>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p><ul><li>优点：可以实现随机存取，每个元素占用最少的存储空间；</li><li>缺点：只能使用相邻的一整块存储单元，可能产生较多的外部碎片</li></ul><h3 id="🧵链式存储"><a href="#🧵链式存储" class="headerlink" title="🧵链式存储"></a>🧵链式存储</h3><p>不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</p><ul><li>优点：不会出现碎片现象，可以充分利用所有存储单元</li><li>缺点：每个元素因存储指针而占用额外的存储空间，只能实现顺序存取</li></ul><h3 id="🧵索引存储"><a href="#🧵索引存储" class="headerlink" title="🧵索引存储"></a>🧵索引存储</h3><p>在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）</p><ul><li>优点：检索速度快</li><li>缺点：附加的索引表额外占用存储空间。增加和删除数据也要同时修改索引表，会花费较多的时间</li></ul><h3 id="🧵散列存储"><a href="#🧵散列存储" class="headerlink" title="🧵散列存储"></a>🧵散列存储</h3><p>根据元素的关键字直接计算出该元素的存储地址，又称为哈希（Hash）存储</p><ul><li>优点：检索、增加和删除结点的操作都很快</li><li>缺点：若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销</li></ul><h2 id="🎮循环与递归"><a href="#🎮循环与递归" class="headerlink" title="🎮循环与递归"></a>🎮循环与递归</h2><p>循环和递归两者是可以互换的，不能决定性的说循环比递归效率要高</p><h3 id="🧵递归"><a href="#🧵递归" class="headerlink" title="🧵递归"></a>🧵递归</h3><ul><li>优点：代码简洁清晰，容易检查正确性</li><li>缺点：当递归调用的次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况，对执行效率有一定的影响</li></ul><h3 id="🧵循环"><a href="#🧵循环" class="headerlink" title="🧵循环"></a>🧵循环</h3><ul><li>优点：结构简单，速度快</li><li>缺点：循环并不能解决所有的问题，有的问题只适合使用递归来处理</li></ul><h2 id="🎮贪心算法、动态规划和分治法"><a href="#🎮贪心算法、动态规划和分治法" class="headerlink" title="🎮贪心算法、动态规划和分治法"></a>🎮贪心算法、动态规划和分治法</h2><h3 id="🧵贪心算法"><a href="#🧵贪心算法" class="headerlink" title="🧵贪心算法"></a>🧵贪心算法</h3><p>做出在当前看来是最好的结果，不从整体上考虑，<strong>局部最优解</strong><br>贪心算法<strong>从上往下</strong>，从顶部一步一步最优，得到最后的结果，它<strong>不能保证全局最优解</strong>，与贪心策略的选择有关</p><h3 id="🧵动态规划"><a href="#🧵动态规划" class="headerlink" title="🧵动态规划"></a>🧵动态规划</h3><p>把问题分解成子问题，这些子问题有可能有重复，可以记录下前面子问题的结果防止重复计算<br>动态规划解决子问题，前一个子问题的解对后一个子问题产生一定的影响。在求解子问题的过程中保留那些可能得到最优的局部姐，丢弃其他局部解，直到解决最后一个问题也就是初始问题的解。<br>动态规划<strong>从下往上</strong>，一步一步找到<strong>全局最优解</strong>。<strong>（各子问题重叠）</strong></p><h3 id="🧵分治法（divide-and-conquer）"><a href="#🧵分治法（divide-and-conquer）" class="headerlink" title="🧵分治法（divide-and-conquer）"></a>🧵分治法（divide-and-conquer）</h3><p>将原问题划分成n个规模较小而结构与原问题相似的子问题，<strong>递归</strong>的解决这些子问题，然后再合并其结果，得到原问题的解。<strong>（各子问题独立）</strong><br>分支模式在每一层递归上的三个步骤：</p><ol><li>分解（divide）：将原问题分解成一系列子问题</li><li>解决（conquer）：递归的解各个子问题。若子问题足够小，则直接求解</li><li>合并（Combine）：将子问题的结果合并成原问题的解</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 课程总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——入门模拟</title>
      <link href="/2023/05/08/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/"/>
      <url>/2023/05/08/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊入门模拟"><a href="#🎊入门模拟" class="headerlink" title="🎊入门模拟"></a>🎊入门模拟</h1><h2 id="🎀日期处理"><a href="#🎀日期处理" class="headerlink" title="🎀日期处理"></a>🎀日期处理</h2><p>一个二维数组int month[13][2]，用于存放每个月的天数，其中第二维为0表示平年，为1表示闰年<br>具体处理：当加了一天后天数d等于当前月份m所拥有的天数加1，那么月份m+1，同时置天数d为1；若此时月份m为13，则令年份加1，同时置月份m为1</p><h4 id="🎈scanf的用法"><a href="#🎈scanf的用法" class="headerlink" title="🎈scanf的用法"></a>🎈scanf的用法</h4><p>——要读入以下的数据，得到年月日（2019-10-3）因为里面有-字符所以你没有办法直接的把数据读进来scanf(“%d-%d-%d”,&amp;a,&amp;b,&amp;c);，这样你就可以得到年月日，也就是a，b，c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n%<span class="number">400</span>==<span class="number">0</span>|| (n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yyyy,mm,dd,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;yyyy,&amp;mm,&amp;dd);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a=n;</span><br><span class="line">    <span class="keyword">while</span>(a--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        dd--;</span><br><span class="line">        <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">            mm--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((mm)==<span class="number">0</span>)&#123;</span><br><span class="line">            mm=<span class="number">12</span>;yyyy--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">            dd=month[mm][<span class="built_in">year</span>(yyyy)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d&quot;</span>,yyyy,mm,dd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该题中，日月年的减法顺序是很重要的，需要考虑dd为0，mm为1的情况，此时需要跳转到前一年的最后一天</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闰则为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">400</span>==<span class="number">0</span>||(n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2加一天</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;yyyy,<span class="type">int</span> &amp;mm,<span class="type">int</span> &amp;dd)</span></span>&#123;</span><br><span class="line">    dd++;</span><br><span class="line">    <span class="keyword">if</span>(dd==month[mm][<span class="built_in">year</span>(yyyy)]+<span class="number">1</span>)&#123;</span><br><span class="line">        dd=<span class="number">1</span>;mm++;</span><br><span class="line">        <span class="keyword">if</span>(mm==<span class="number">13</span>)&#123;</span><br><span class="line">            mm=<span class="number">1</span>;yyyy++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2减一天</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;yyyy,<span class="type">int</span> &amp;mm,<span class="type">int</span> &amp;dd)</span></span>&#123;</span><br><span class="line">    dd--;</span><br><span class="line">    <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">        mm--;</span><br><span class="line">        <span class="keyword">if</span>(mm==<span class="number">0</span>)&#123;</span><br><span class="line">            mm=<span class="number">12</span>;yyyy--;</span><br><span class="line">        &#125;</span><br><span class="line">        dd=month[mm][<span class="built_in">year</span>(yyyy)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1则1比2大 2要加   0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> yyyy1,<span class="type">int</span> yyyy2,<span class="type">int</span> mm1,<span class="type">int</span> mm2,<span class="type">int</span> dd1,<span class="type">int</span> dd2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(yyyy1&gt;yyyy2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(yyyy1&lt;yyyy2)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mm1&gt;mm2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mm1&lt;mm2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dd1&gt;dd2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dd1&lt;dd2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yyyy1=<span class="number">2020</span>,mm1=<span class="number">2</span>,dd1=<span class="number">28</span>,w=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> yyyy2,mm2,dd2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;yyyy2,&amp;mm2,&amp;dd2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">1</span>)&#123;<span class="comment">//1大 日期2要加1  星期要减1</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(yyyy2,mm2,dd2);</span><br><span class="line">            w=(w<span class="number">-1</span>+<span class="number">7</span>)%<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sub</span>(yyyy2,mm2,dd2);</span><br><span class="line">            w=(w+<span class="number">1</span>)%<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知一个日期是周几，求输入日期的星期数——根据两个日期间的差值求<br>所给日期与当前日期的关系一定要搞清楚！</p><h2 id="🎀进制转换"><a href="#🎀进制转换" class="headerlink" title="🎀进制转换"></a>🎀进制转换</h2><h4 id="🎈将P进制数x转换为十进制数y"><a href="#🎈将P进制数x转换为十进制数y" class="headerlink" title="🎈将P进制数x转换为十进制数y"></a>🎈将P进制数x转换为十进制数y</h4><p>P进制数x为a1a2…an，可以得到十进制数y<br>$y&#x3D;a_{1} * P^{n-1}+a_{2} * P^{n-2}+\cdots+a_{n-1} * P+a_{n}$<br>可以利用循环代码实现上述公式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">0</span>, product = <span class="number">1</span>;<span class="comment">//product每次都乘p</span></span><br><span class="line"><span class="keyword">while</span>(x! = <span class="number">0</span>)&#123;</span><br><span class="line">    y = y + (x % <span class="number">10</span>) * product;<span class="comment">//x%10获取x的个位数</span></span><br><span class="line">    x = x/<span class="number">10</span>;</span><br><span class="line">    product = product * p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🎈将十进制数y转换为P进制数z"><a href="#🎈将十进制数y转换为P进制数z" class="headerlink" title="🎈将十进制数y转换为P进制数z"></a>🎈将十进制数y转换为P进制数z</h4><p>采用“除基取余法”，基为将要转化为的进制Q，得到的余数作为低位存储</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> z[<span class="number">40</span>],num = <span class="number">0</span>;<span class="comment">//num为位数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num++] = y % Q;<span class="comment">//除基取余</span></span><br><span class="line">    y = y/Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y != <span class="number">0</span>)<span class="comment">//当商不为0时进行循环</span></span><br></pre></td></tr></table></figure><p>z数组从高位z[num–]到低位z[0]即为Q进制z</p><h2 id="🎀字符串处理"><a href="#🎀字符串处理" class="headerlink" title="🎀字符串处理"></a>🎀字符串处理</h2><p><strong>难题1：</strong><br>给定n个字符串，求它们的公共前缀。<br>——如何获取输入的数值和如何比较公共前缀是本题的两大重点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">51</span>;</span><br><span class="line"><span class="type">char</span> str[MAXN][MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, minL = MAXL;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="comment">//千万不能漏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin.<span class="built_in">getline</span>(str[i], MAXL);<span class="comment">//不要忘记这种读取一行字符串的方式</span></span><br><span class="line">        minL = <span class="built_in">min</span>(minL, (<span class="type">int</span>)<span class="built_in">strlen</span>(str[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; minL; j++) &#123;</span><br><span class="line">        <span class="type">bool</span> isSame = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i][j] != str[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                isSame = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[<span class="number">0</span>][j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>难题2：</strong><br>按从左到右字符出现的顺序，输出每个字符连续出现的个数。<br>其中每个字符输出一行，每行以空格为分隔，输出该字符与出现的个数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(str,<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==str[i+<span class="number">1</span>]&amp;&amp;i+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">            i++;num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>——不要把简单问题想复杂了，所求是连续字符的个数，完全不需要使用二维数组</p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——基础知识</title>
      <link href="/2023/05/05/C-C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/05/C-C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊基础知识"><a href="#🎊基础知识" class="headerlink" title="🎊基础知识"></a>🎊基础知识</h1><h2 id="🎀if-else"><a href="#🎀if-else" class="headerlink" title="🎀if-else"></a>🎀if-else</h2><p>使用如下方式而不使用if-else，更为简便清晰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(a &gt;= b ? <span class="string">&quot;A &gt;= B&quot;</span> : <span class="string">&quot;A &lt; B&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="🎀getchar函数"><a href="#🎀getchar函数" class="headerlink" title="🎀getchar函数"></a>🎀getchar函数</h2><p>用来输入单个字符，因此需要注意换行符的存在，可以使用getchar()来读取换行符</p><h2 id="🎀数学函数的使用"><a href="#🎀数学函数的使用" class="headerlink" title="🎀数学函数的使用"></a>🎀数学函数的使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span> <span class="comment">//头文件 </span></span></span><br><span class="line"><span class="built_in">fabs</span>(a):a的绝对值</span><br><span class="line"><span class="built_in">floor</span>(a):a的向下取整</span><br><span class="line"><span class="built_in">ceil</span>(a):a的向上取整</span><br><span class="line"><span class="built_in">round</span>(a):a的四舍五入(四舍六入五成双)</span><br><span class="line"><span class="built_in">pow</span>(a,b):a的b次方,b可以为浮点型</span><br><span class="line"><span class="built_in">sqrt</span>(a):a的算术平方根(开根号)</span><br><span class="line"><span class="built_in">log</span>(a):a的以自然对数e为底的对数</span><br></pre></td></tr></table></figure><h2 id="🎀switch-case语句格式"><a href="#🎀switch-case语句格式" class="headerlink" title="🎀switch-case语句格式"></a>🎀switch-case语句格式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常数表达式<span class="number">1</span>：</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常数表达式<span class="number">2</span>：</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀continue语句"><a href="#🎀continue语句" class="headerlink" title="🎀continue语句"></a>🎀continue语句</h2><p>和break类似，continue也是用在循环当中，但区别是break语句执行后循环就被彻底退出，而continue则只是跳过当前这一轮，继续进行下一轮，并不是停止循环，所以很适合在满足某些条件需要不执行循环体内容时使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀比较两数大小"><a href="#🎀比较两数大小" class="headerlink" title="🎀比较两数大小"></a>🎀比较两数大小</h2><p>C语言快速比较两数大小——<strong>fmax，fmin函数</strong><br>头文件include&lt;math.h&gt;，作用是返回两个浮点参数中较大的一个</p><h2 id="🎀冒泡排序"><a href="#🎀冒泡排序" class="headerlink" title="🎀冒泡排序"></a>🎀冒泡排序</h2><p>——本质在于交换，每趟将最大或者最小值移到最后</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//比较趟数，n个数共比较n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//a[0]到a[n-i-1]都与他们的下一个数进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>交换两个数可以用#include<algorithm>中的swap（a,b）</p><h2 id="🎀memset函数"><a href="#🎀memset函数" class="headerlink" title="🎀memset函数"></a>🎀memset函数</h2><p>——头文件#include&lt;string.h&gt;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,值,<span class="built_in">sizeof</span>(数组名));</span><br></pre></td></tr></table></figure><p>一般只建议用memset函数赋值0和-1——memset按照字节赋值，赋值其他数字可以用fill</p><h2 id="🎀字符数组"><a href="#🎀字符数组" class="headerlink" title="🎀字符数组"></a>🎀字符数组</h2><p>char型字符数组的长度比事迹存储字符串的长度至少多1（结束符\0）<br>如果不是使用scanf函数或gets函数输入字符串（如getchar），一定要加入\0，否则会乱码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=<span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>输出和输出——%c用来输入单个字符，%s用来输入一个字符串并存在字符数组中。</li></ul><p>%c格式能够识别空格跟换行并将其输入，%s通过空格或换行来识别一个字符串的结束。<br><strong>scanf在使用%s不需要&amp;取地址</strong></p><ul><li>getchar()输入，putchar()输出单个字符</li></ul><p>str[i][j]&#x3D;getchar() putchar(str[i][j])   注意：<strong>每行末尾有换行符</strong>,有需要的需要通过gets()或getchar()来处理换行符</p><ul><li><strong>gets(str)输入</strong>和puts()输出一行字符串</li></ul><p>gets()识别\n作为输入结束，<strong>puts()输出自带\n换行</strong>，比printf(“%s\n”,str[i]);更便捷</p><ul><li>字符数组的整行输入</li></ul><p>在比较早的C&#x2F;C++版本中，经常可以看到推荐使用gets函数来进行整行字符串的输入，就像下面这样的简单写法即可输入一整行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gets</span>(str);</span><br></pre></td></tr></table></figure><p>但是当输入的字符串长度超过数组长度上限MAX_LEN时，gets函数会把超出的部分也一并读进来，并且会覆盖数组之外的内存空间，这就导致了一定的安全风险，因此C++11标准将gets函数废弃了，然后在C++14时将该函数移除，如果现在想要整行输入的话，推荐使用cin.getline函数；而在C语言标准中gets函数则是在C11时被移除，与此同时增加了gets_s函数，除此之外还有fgets函数可供选择。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namesapce std;</span><br><span class="line">cin.<span class="built_in">getline</span>(str, MAX_LEN);<span class="comment">//第一个参数为字符数组，第二个参数是最大允许读入的字符个数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gets_s(str, MAX_LEN);</span><br></pre></td></tr></table></figure><h3 id="🎈string-h头文件"><a href="#🎈string-h头文件" class="headerlink" title="🎈string.h头文件"></a>🎈string.h头文件</h3><p>strlen()函数——得到字符数组中第一个\0前的字符个数<br>strcmp()函数——返回字符串大小的比较结果，比较原则”字典序”<br>strcmp(str1,str2)——str1&lt;str2返回一个负整数；str1&#x3D;str2返回0；str1&gt;str2返回一个正整数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strcpy()函数——把一个字符串复制给另一个字符串<br>strcpy(str1,str2)——把字符数组2复制给字符数组1，包括\0<br>strcat()函数——把一个字符串接到另一个字符串后面<br>strcat(str1,str2)——把字符数组2接到字符数组1后面</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    cin &gt;&gt; s2;</span><br><span class="line">    cout &lt;&lt; s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈sscanf与springf"><a href="#🎈sscanf与springf" class="headerlink" title="🎈sscanf与springf"></a>🎈sscanf与springf</h3><p>假定一个char数组str[100]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="comment">//把字符数组str中的内容以%d的形式写到n中</span></span><br><span class="line"><span class="comment">//成功返回参数的数目，失败则返回0</span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="comment">//把n以%d的格式写到字符数组str中</span></span><br></pre></td></tr></table></figure><p>%04d可以输出四位数，不够则前面用0补全，与%.2f有异曲同工之处</p><h2 id="🎀Max值"><a href="#🎀Max值" class="headerlink" title="🎀Max值"></a>🎀Max值</h2><p>求三个数中的最大值，不仅可以自定义函数，也可如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(&#123;a, b, c&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀指针"><a href="#🎀指针" class="headerlink" title="🎀指针"></a>🎀指针</h2><p>获得变量的地址——取地址运算符&amp;</p><h3 id="🎈指针变量"><a href="#🎈指针变量" class="headerlink" title="🎈指针变量"></a>🎈指针变量</h3><p>指针变量用来存放指针（可以理解为地址）——int* p;<br>（一次有好几个同种类型的指针变量 要同时定义，星号只会结合第一个变量名）<br>给指针变量赋值的方式——把变量的地址取出来，然后赋给对应类型的指针变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="comment">//(int*)是指针变量的类型 p才是变量名</span></span><br><span class="line">*p = a的值</span><br><span class="line"><span class="comment">//*作为开启房间的钥匙，放在p的前面，这样*p就可以获取到房间里的东西，即存储的数据</span></span><br><span class="line"><span class="comment">//直接对*p进行赋值，也可以起到改变那个保存的元素的功能</span></span><br></pre></td></tr></table></figure><p>指针变量p+1——p所指的int型变量的下一个int型变量地址（也支持++,–操作）</p><h3 id="🎈指针与数组"><a href="#🎈指针与数组" class="headerlink" title="🎈指针与数组"></a>🎈指针与数组</h3><p>对于数组，可以在元素前面加取地址运算符&amp;来获取它的地址，例如a[0]的地址为&amp;a[0]，即数组a的首地址为&amp;a[0]<br>在C语言中，数组名称也作为数组的首地址使用，a&#x3D;&#x3D;&amp;a[0]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);<span class="comment">//a+i等同于&amp;a[i]——数组a的首地址偏移i个int型变量的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(a+i));<span class="comment">//a+i只是一个地址，要想访问其中的元素，还是需要*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针变量可以自增操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span>* p = a; p &lt; a+<span class="number">10</span>; p++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈使用指针变量作为函数参数"><a href="#🎈使用指针变量作为函数参数" class="headerlink" title="🎈使用指针变量作为函数参数"></a>🎈使用指针变量作为函数参数</h3><p>指针类型也可以作为函数参数的类型，这时视为把变量的地址传入函数。如果在函数中对这个地址中的元素进行改变，原先的数据就会确实地被改变。</p><ul><li>使用指针进行两个数的交换</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span>* temp;</span><br><span class="line">    <span class="comment">//在定义temp时，temp没有被初始化，此时temp中存放的地址是随机的，很有可能出错</span></span><br><span class="line">    <span class="comment">/*可以给temp赋个初值</span></span><br><span class="line"><span class="comment">int x;int* temp = &amp;x;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    *temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法二</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="comment">//直接交换两个数的地址，在swap函数中交换后，在main函数中实际并未交换</span></span><br><span class="line">    <span class="comment">//传入swap中的只是a和b的地址，无符号整型的数字而已，并不能实现main函数中的双向交换</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数参数的传送方式是单向一次性的</span></span><br></pre></td></tr></table></figure><h3 id="🎈引用"><a href="#🎈引用" class="headerlink" title="🎈引用"></a>🎈引用</h3><p>——在函数中想要修改传入的参数，但又不想使用指针<br>引用不产生副本，只是给变量起了个别名，对引用变量的操作就是对原变量的操作（取一个小名）</p><ul><li>在函数参数类型后面加一个&amp;即可</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;<span class="comment">//不需要return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(a);<span class="comment">//a=10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把引用的&amp;和取地址运算符&amp;区分开来，引用≠取地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对指针本身的修改无法作用到原指针变量上</span></span><br><span class="line"><span class="comment">//可以通过指针的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* &amp;a,<span class="type">int</span>* &amp;b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀结构体（struct）的使用"><a href="#🎀结构体（struct）的使用" class="headerlink" title="🎀结构体（struct）的使用"></a>🎀结构体（struct）的使用</h2><h3 id="🎈结构体的定义"><a href="#🎈结构体的定义" class="headerlink" title="🎈结构体的定义"></a>🎈结构体的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Name</span>&#123;</span><br><span class="line"><span class="comment">//一些基本的数据结构或者自定义的数据类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> gender;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;Alice,Bob,stu[<span class="number">1000</span>];<span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="comment">//也可以</span></span><br><span class="line">studentInfo Alice;</span><br><span class="line">studentInfo stu[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure><p>结构体里面不能定义自身，但可以定义自身类型的指针变量 studentInfo* next;——√</p><h3 id="🎈访问结构体内的元素"><a href="#🎈访问结构体内的元素" class="headerlink" title="🎈访问结构体内的元素"></a>🎈访问结构体内的元素</h3><p>访问结构体内的元素——“.”操作和“-&gt;”操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">studentInfo* next;</span><br><span class="line">&#125;stu,*p;<span class="comment">//普通变量stu和指针变量p</span></span><br><span class="line">——访问stu变量</span><br><span class="line">stu.id</span><br><span class="line">stu.name</span><br><span class="line">stu.next</span><br><span class="line">——访问指针变量p中的元素</span><br><span class="line">(*p).<span class="built_in">id</span></span><br><span class="line">(*p).<span class="built_in">name</span></span><br><span class="line">(*p).next</span><br><span class="line">——访问结构体指针变量内元素的更简洁的方法</span><br><span class="line">p-&gt;id</span><br><span class="line">p-&gt;name</span><br><span class="line">p-&gt;next</span><br></pre></td></tr></table></figure><h3 id="🎈结构体的初始化"><a href="#🎈结构体的初始化" class="headerlink" title="🎈结构体的初始化"></a>🎈结构体的初始化</h3><p>构造函数的方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//下面的参数用以对结构体内部变量进行赋值</span></span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id,<span class="type">char</span> _gender)&#123;</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        id = _id;</span><br><span class="line">        gender = _gender;</span><br><span class="line">    <span class="comment">//也可以</span></span><br><span class="line">    <span class="built_in">studentInfo</span>(<span class="type">int</span> _id,<span class="type">int</span> _gender):<span class="built_in">id</span>(_id),<span class="built_in">gender</span>(_gender)&#123;&#125;</span><br><span class="line">    <span class="built_in">studentInfo</span>()&#123;&#125;;</span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id):<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">studentInfo stu = <span class="built_in">studentInfo</span>(<span class="number">10086</span>,<span class="string">&#x27;M&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了既能不初始化就定义结构变量，又能享受初始化带来的便捷，可以手动加上默认的生成函数，也可以定义参数个数和类型不完全相同的构造函数</p><h2 id="🎀补充"><a href="#🎀补充" class="headerlink" title="🎀补充"></a>🎀补充</h2><h3 id="🎈cin和cout"><a href="#🎈cin和cout" class="headerlink" title="🎈cin和cout"></a>🎈cin和cout</h3><p>——#include<iostream> using namespace std;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;<span class="comment">//endl表示换行</span></span><br></pre></td></tr></table></figure><p>保留小数setprecision（n）的用法<br>——头文件#include<iomanip><br>cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;d;</p><h2 id="🎀黑盒测试"><a href="#🎀黑盒测试" class="headerlink" title="🎀黑盒测试"></a>🎀黑盒测试</h2><h3 id="🎈单点测试"><a href="#🎈单点测试" class="headerlink" title="🎈单点测试"></a>🎈单点测试</h3><h3 id="🎈多点测试"><a href="#🎈多点测试" class="headerlink" title="🎈多点测试"></a>🎈多点测试</h3><ol><li>三种输入方式</li></ol><ul><li><strong>while…EOF型</strong></li></ul><p>题目<strong>没有给定输入的结束条件</strong>，默认读取到文件末尾</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)!=EOF)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入字符串</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">gets</span>(str)!=<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;str)!=EOF)&#123;&#125;</span><br></pre></td></tr></table></figure><p>只要scanf的返回值不为EOF（文件中的数据没有读完）就反复读入a，执行while中的内容</p><ul><li><strong>while…break型</strong></li></ul><p>题目要求当<strong>输入的数据满足某个条件</strong>时，停止输入<br><strong>w</strong>hile…EOF型的衍生</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简略写法</span></span><br><span class="line"><span class="comment">//a和b中有一个不为0就进行循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b),a||b)&#123;<span class="comment">//a!=0||b!=0</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>while（T–）型</strong></li></ul><p>题目会给出测试数据的组数，接着才给出相应数量组数的输入数据</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>三种输出方法</li></ol><ul><li><strong>正常输出</strong></li><li><strong>每组数据输出后都要额外加一个空行</strong></li><li><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于MediaPipe的坐姿及疲劳检测系统</title>
      <link href="/2023/02/26/%E5%9F%BA%E4%BA%8EMediaPipe%E7%9A%84%E5%9D%90%E5%A7%BF%E5%8F%8A%E7%96%B2%E5%8A%B3%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/02/26/%E5%9F%BA%E4%BA%8EMediaPipe%E7%9A%84%E5%9D%90%E5%A7%BF%E5%8F%8A%E7%96%B2%E5%8A%B3%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="🌈基本介绍"><a href="#🌈基本介绍" class="headerlink" title="🌈基本介绍"></a>🌈基本介绍</h1><h2 id="🌀项目背景、编写目的"><a href="#🌀项目背景、编写目的" class="headerlink" title="🌀项目背景、编写目的"></a>🌀项目背景、编写目的</h2><p>随着现代社会的高速发展，青少年学习和生活负担越来越重，因为久坐、坐姿不正确而导致的各类疾病正在日渐低龄化，很多青少年的身体已经处于一种亚健康或者有疾病状态，其中近视、颈椎疾病、腰椎疾病和各部位肌肉僵硬劳损等问题已经在儿童乃至成年人身上普遍发生。<br>从世界卫生组织年公布的统计数据：在日本，40%的人患有近视；美国25%；在我国近视的人数至少在31%以上，我国人口众多，近视人数位列全球第一。根据国家教育部和卫生部的调查数据显示，我国近视患者人数已达亿万，占中国人口总数的，并呈现出“总体人数越来越多，初始患者年龄越来越小”的发展趋势。我国青少年近视发病率目前已居世界第二位，近视新发病例都出现在青春发育阶段。据专家调查与分析，导致近视的一个主要原因是坐姿不当。<br>第二，是近些年来，在青少年中的发病率不断上升。导致颈椎病的一个很重要的原因就是坐姿不当。例如托腮，因为当单手托腮的时候，身体的坐姿会发生一边的倾斜，长此以往，脊椎会受到压力而出现变形。这种坐姿让身体一侧沉重过度，导致一侧肌肉拉伸明显，而另外一侧肢体受到挤压，久而久之会影响血液循环，导致颈部肌肉牵拉损伤，因而容易引起颈椎病。<br>第三，不正确的坐姿也容易引发脊柱侧弯，如今青少年中的脊椎病发病率越来越高，发病的重要原因之一是忽视了坐姿。种种不良的坐姿都轻易使脊椎长时间处于屈曲位或某些特定体位，长时间如此，脊椎畸形就有可能发生。<br>目前市面上对于青少年正确坐姿的提醒与矫正的主要方式都是以相关实体矫正器为载体为主，如：通过物理阻挡的方法来组织阻止孩子的过度低头的坐姿矫正器、通过顶住孩子上半身和头部的各个部位来让孩子不要以不正确的姿势靠近书桌的矫正杆、矫正背带等等，然而这些物理矫正虽然可以在一定程度上让孩子保持一定的姿势，但是很难实时的发现青少年的坐姿问题，也不能对躲避这些器械的青少年进行实时的监控和提醒。因此，市场上还没有一款产品软件可以实时监测儿童的坐姿情况并对错误坐姿发出提醒。所以总体来看，该市场还未被开发、具有较大潜力。<br>综上可以说该市场还没有被开荒，所以目前压力较小，竞争对手不明显，而根据市场发展来看，先进入市场的产品，会有更大的用户基础、更长的产品完善时间，这也意味着更大的市场占有率。<br>因此，此软件旨在通过分析青年各种常见的错误坐姿并对此将开展一系列针对坐姿检测的研究和对目前市面上研究工作进行改进；与此同时，此系统中我们还增加了用于疲劳监测功能，能在该用户进行长时间工作或学习的过程中进行提醒。</p><h1 id="🌈软件总体设计"><a href="#🌈软件总体设计" class="headerlink" title="🌈软件总体设计"></a>🌈软件总体设计</h1><h2 id="🌀软件需求概括"><a href="#🌀软件需求概括" class="headerlink" title="🌀软件需求概括"></a>🌀软件需求概括</h2><p>作为一款图像类检测软件，根据图像检测和用户的实际需要，对软件进行了分析与设计，总结了本软件所需要的几个功能模块。</p><ul><li><strong>静止图像坐姿分析检测：</strong>软件支持在确定输入图片路径前浏览文件和目录，并可以手动输入或选择输入图片路径。当开始进行静止图像中人物的坐姿分析检测时，通过生成人体骨骼关键点，以抽象的人体骨架姿态来检测人体的坐姿状态，检测完成后，如若出现错误坐姿，会在软件界面进行显示。</li><li><strong>动态视频坐姿分析检测：</strong>软件支持在确定输入视频路径前浏览文件和目录，并可以手动输入或选择输入视频路径。用户可以随时开始和暂停视频，在坐姿检测过程中，生成视频中人物的人体骨架，以抽象的人体骨架姿态来检测人体的坐姿状态，检测完成后，如若出现错误坐姿，会在软件界面进行显示，在错误坐姿的持续时长达到设定的阈值后，会对使用者进行提醒。</li><li><strong>实时监控坐姿分析检测：</strong>软件支持系统自带摄像头和外部链接摄像头检测，在检测到人体画面后，选择最为清晰、最贴近摄像头的人体，实时生成骨架图，并且根据人体姿态的变化，实施更新骨架图，并以此为基础，进行人体姿态的判断，实施监控坐姿检测较为灵敏，为了防止在检测过程中不断打扰使用者，我们设定了阈值，在达到设定阈值之后，会对使用者程度不一的提醒。</li><li><strong>疲劳情况分析检测：</strong>这项功能主要是针对实时监控坐姿分析检测，通过对一段时间内实时监测到的错误坐姿进行分类整理，分析错误坐姿的种类和次数，以此为基础判断使用者是否出现了疲劳的情况。</li></ul><h2 id="🌀软件系统功能结构图"><a href="#🌀软件系统功能结构图" class="headerlink" title="🌀软件系统功能结构图"></a>🌀软件系统功能结构图</h2><p><img src="https://i.imgtg.com/2023/07/23/Oht9V1.md.jpg#id=siWhQ&originHeight=500&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🌀系统的软硬件环境"><a href="#🌀系统的软硬件环境" class="headerlink" title="🌀系统的软硬件环境"></a>🌀系统的软硬件环境</h2><ol><li>系统开发软硬件环境：<ol><li>软件配置：Windows 10操作面板，PyCharm</li><li>硬件配置：4G CPU、16G内存</li></ol></li><li>系统运行软硬件环境：<ol><li>CPU：2G以上</li><li>内存：8G以上</li><li>操作面板：Windows操作面板<table><thead><tr><th>实验平台</th><th>CPU</th><th>Intel I5-8300</th></tr></thead><tbody><tr><td></td><td>内存</td><td>16GB</td></tr><tr><td></td><td>显卡</td><td>NVIDIA GTX1060</td></tr><tr><td></td><td>显存</td><td>6GB</td></tr><tr><td></td><td>硬盘转速</td><td>两块7200r&#x2F;s组成磁盘阵列</td></tr></tbody></table></li></ol></li></ol><h2 id="🌀软件总体功能流程"><a href="#🌀软件总体功能流程" class="headerlink" title="🌀软件总体功能流程"></a>🌀软件总体功能流程</h2><h3 id="🔥静止图像坐姿分析检测"><a href="#🔥静止图像坐姿分析检测" class="headerlink" title="🔥静止图像坐姿分析检测"></a>🔥静止图像坐姿分析检测</h3><h4 id="🌊选择输入、输出图片路径功能"><a href="#🌊选择输入、输出图片路径功能" class="headerlink" title="🌊选择输入、输出图片路径功能"></a>🌊选择输入、输出图片路径功能</h4><p>选择输入、输出图片路径模块主要完成原始数据集的文件路径导入相关工作，选择输入、输出图片路径模块主要完成原始数据集的文件路径导入相关工作，选定或输入包含待转换的坐姿图像文件夹和存放检测后生成的骨骼图文件。<br>系统浏览的默认路径是Python项目的路径，需要用户手动选择或输入数据集路径。用户点击“输入图片路径”按钮，进行包含待检测坐姿的图像文件夹的路径选择，用户选择文件夹以后，对话框消失。</p><h4 id="🌊抽象骨骼图生成功能"><a href="#🌊抽象骨骼图生成功能" class="headerlink" title="🌊抽象骨骼图生成功能"></a>🌊抽象骨骼图生成功能</h4><p>选择输入图片后，系统会基于Mediapipe的人像识别功能抽象出使用者的坐姿的骨骼图，通过黑底骨架图可以形象展示使用者目前的坐姿，使用者可以看到部分身体关键点的位置。</p><h3 id="🔥动态视频坐姿分析检测"><a href="#🔥动态视频坐姿分析检测" class="headerlink" title="🔥动态视频坐姿分析检测"></a>🔥动态视频坐姿分析检测</h3><h4 id="🌊选择输入视频、输出图片路径功能"><a href="#🌊选择输入视频、输出图片路径功能" class="headerlink" title="🌊选择输入视频、输出图片路径功能"></a>🌊选择输入视频、输出图片路径功能</h4><p>选择输入视频路径模块主要完成原始数据集的文件路径导入相关工作，选定或输入包含待转换的坐姿图像文件夹和存放检测后生成的骨骼图文件。<br>系统浏览的默认路径是Python项目的路径，需要用户手动选择或输入数据集路径。用户点击“输入视频路径”按钮，进行包含待检测坐姿的图像文件夹的路径选择，用户选择文件夹以后，对话框消失。当用户选择截取当前页面骨骼图时，点击“截取图片”按钮，进行路径选择存放生成的骨骼数据图，用户选择文件夹以后，对话框消失。</p><h4 id="🌊抽象骨骼图生成功能-1"><a href="#🌊抽象骨骼图生成功能-1" class="headerlink" title="🌊抽象骨骼图生成功能"></a>🌊抽象骨骼图生成功能</h4><p>选择输入视频后，系统会基于Mediapipe的人像识别功能抽象出使用者的坐姿的骨骼图，通过黑底骨架图可以形象展示使用者目前的坐姿，使用者可以看到部分身体关键点的位置。</p><h4 id="🌊暂停、继续进程功能"><a href="#🌊暂停、继续进程功能" class="headerlink" title="🌊暂停、继续进程功能"></a>🌊暂停、继续进程功能</h4><p>暂停、继续进程模块主要控制图像视频播放的工作，可以在坐姿检测的过程中暂停和继续进程。<br>点击“开始”按钮开始视频播放后，在进行坐姿检测的过程中可点击“暂停”按钮实现坐姿检测的暂停。点击“暂停”按钮后图像显示正在处理的最后一帧坐姿图像。<br>点击“暂停”按钮后视频暂停播放，点击“继续”按钮后进程继续进行。</p><h4 id="🌊错误坐姿检测汇总统计功能"><a href="#🌊错误坐姿检测汇总统计功能" class="headerlink" title="🌊错误坐姿检测汇总统计功能"></a>🌊错误坐姿检测汇总统计功能</h4><p>在进行动态视频坐姿检测的过程中，系统会实时进行坐姿问题的检测，并在后台予以记录，当视频播放结束后，会进行坐姿问题的汇总统计，生成相应的汇总表。</p><h3 id="🔥实时监控坐姿分析检测"><a href="#🔥实时监控坐姿分析检测" class="headerlink" title="🔥实时监控坐姿分析检测"></a>🔥实时监控坐姿分析检测</h3><h4 id="🌊摄像头选择功能"><a href="#🌊摄像头选择功能" class="headerlink" title="🌊摄像头选择功能"></a>🌊摄像头选择功能</h4><p>当用户要进行实时坐姿检测时，有两个选择，一是通过计算机自带摄像机进行实时检测，点击“连接计算机摄像头”按钮后开始进行实时检测；二是通过外接摄像头进行实时检测，点击“链接外部摄像头”按钮后即开始检测。当用户选择截取当前页面骨骼图时，点击“截取图片”按钮，进行路径选择存放生成的骨骼数据图，用户选择文件夹以后，对话框消失。</p><h4 id="🌊抽象骨骼图生成功能-2"><a href="#🌊抽象骨骼图生成功能-2" class="headerlink" title="🌊抽象骨骼图生成功能"></a>🌊抽象骨骼图生成功能</h4><p>在进行实时坐姿检测时，系统会基于Mediapipe的人像识别功能抽象出使用者的坐姿的骨骼图，通过黑底骨架图可以形象展示使用者目前的坐姿，使用者可以看到部分身体关键点的位置。</p><h4 id="🌊当前坐姿情况判断功能"><a href="#🌊当前坐姿情况判断功能" class="headerlink" title="🌊当前坐姿情况判断功能"></a>🌊当前坐姿情况判断功能</h4><p>当前坐姿情况的判断主要是通过对所生成的骨骼图进行判断的，所采用的方法为神经网络判断方法为主，坐标判断检测为辅。<br>在开始实时坐姿检测后，用户可在主界面的“当前坐姿情况”内实时看到用户的坐姿情况。</p><h4 id="🌊错误坐姿提醒功能"><a href="#🌊错误坐姿提醒功能" class="headerlink" title="🌊错误坐姿提醒功能"></a>🌊错误坐姿提醒功能</h4><p>当检测到用户维持一个错误坐姿太久时，系统将进行语音提醒。</p><h4 id="🌊坐姿检测统计功能"><a href="#🌊坐姿检测统计功能" class="headerlink" title="🌊坐姿检测统计功能"></a>🌊坐姿检测统计功能</h4><p>在进行实时监控坐姿检测的过程中，系统会实时进行坐姿问题的检测，并在后台予以记录，当此次检测结束后，会进行坐姿问题的汇总统计，生成相应的统计文档，主要包括：本次使用时间段内各种坐姿出现的次数；各种坐姿所生成的饼状图；用户的疲劳检测分析；用户的专注度分析。</p><h3 id="🔥疲劳情况分析检测"><a href="#🔥疲劳情况分析检测" class="headerlink" title="🔥疲劳情况分析检测"></a>🔥疲劳情况分析检测</h3><h4 id="🌊静止图像模式"><a href="#🌊静止图像模式" class="headerlink" title="🌊静止图像模式"></a>🌊静止图像模式</h4><p>点击“导入图片”按钮，用户手动选择输入图片的路径，选择完毕后，图片会被显示在界面上，并在右下角“疲劳情况”部分出现提示，提示用户选择输入的是图片，无法检测疲劳情况。在右下角根据软件提示选择“保存”或者“不保存”按钮。点击“不保存按钮”，系统自动重置，可以重新选择要输入的文件。点击“保存”按钮，系统自动生成用户疲劳情况的统计。</p><h4 id="🌊动态视频模式"><a href="#🌊动态视频模式" class="headerlink" title="🌊动态视频模式"></a>🌊动态视频模式</h4><p>点击“导入视频”模式，从浏览文件中选择要输入的视频文件后点击确定，此时主视图会导入选择的视频。点击“开始&#x2F;暂停视频”，视频开始播放，此时主视图会显示有实时骨架的视频，并在“疲劳情况”部分，根据用户出现的错误坐姿的次数，监测视频用户的疲劳情况。</p><h4 id="🌊实时监控模式"><a href="#🌊实时监控模式" class="headerlink" title="🌊实时监控模式"></a>🌊实时监控模式</h4><p>点击“连接计算机摄像头”，软件会自动获取电脑摄像机画面并显示在软件主视图上，主视图会有实时的骨架标注，此时处于实时监控模式，在右下角“疲劳情况”部分，实时监测用户疲劳情况，并且根据选择生成统计报告。</p><h1 id="🌈软件功能描述及软件使用说明"><a href="#🌈软件功能描述及软件使用说明" class="headerlink" title="🌈软件功能描述及软件使用说明"></a>🌈软件功能描述及软件使用说明</h1><p>软件的初始界面如图1所示：<br><img src="https://i.imgtg.com/2023/07/23/Oht34b.md.png#id=YxnXZ&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🌀静止图像坐姿分析检测"><a href="#🌀静止图像坐姿分析检测" class="headerlink" title="🌀静止图像坐姿分析检测"></a>🌀静止图像坐姿分析检测</h2><p>点击软件左下方“导入图片”按钮，在弹出的文件选择窗口中选择待检测的图片即可将图片路径保存至软件的输入图片路径，具体操作如图2所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4aVs.md.png#id=LrDSs&originHeight=500&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当软件处于选择图片功能时，此时界面左上方将显示“正在加载图像…”提示，具体显示如图3所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4OmB.md.png#id=caGNb&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当用户选定所需要检测的图像时，软件将会将所选择的图像添加相应的骨架图并显示在软件主界面左上方，同时检测出此时图中人物的坐姿情况，并在当前坐姿情况处显示“当前坐姿为——正确坐姿&#x2F;左手挠头&#x2F;右手挠头&#x2F;左手托腮&#x2F;右手托腮&#x2F;打哈欠&#x2F;伸懒腰&#x2F;趴写&#x2F;头左倾斜&#x2F;头右倾斜！”。由于此时的检测对象为图片，因此在疲劳情况处显示“当前检测对象为图片，无法判断其疲劳情况！”。软件界面显示如图4所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4qqK.md.png#id=A86OL&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>若所选择的图像不存在人像或检测人像十分困难，则在软件右侧当前坐姿情况“当前图像未检测到人像，无法判断其坐姿！”并在疲劳情况处输出“当前图像未检测到人像，无法判断其疲劳情况！”信息，软件界面显示如图5所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh45Aa.md.png#id=wZRno&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>若想要保存当前结果，即可点击“保存”功能，进入截图功能，选择想要截取的画面就可以保存所选画面；若不想要保存结果，则可以直接选择界面右下角的“不保存”按键，初始化当前界面。结果保存图如图6所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4BQS.md.png#id=KeIkv&originHeight=500&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>点击软件右下方的不保存按钮，即可将界面进行重置，回到最开始的界面以等待下一步操作，具体显示如图7所示。<br><img src="https://i.imgtg.com/2023/07/23/Oh4TCN.md.png#id=cv2Hm&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当软件处于检测静态图像坐姿功能时，若点击“关闭视频&#x2F;摄像头”、“截取视频图像”或“开始&#x2F;暂停视频”按钮，将会产生错误提醒，提醒如下图所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4WiC.png#height=118&id=PXE6D&originHeight=235&originWidth=431&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=216"><br><img src="https://i.imgtg.com/2023/07/23/Oh4b4L.png#height=118&id=JPyk4&originHeight=235&originWidth=287&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=144"></p><h2 id="🌀动态视频坐姿分析检测"><a href="#🌀动态视频坐姿分析检测" class="headerlink" title="🌀动态视频坐姿分析检测"></a>🌀动态视频坐姿分析检测</h2><p>点击软件左下方“导入视频”按钮，在弹出的文件选择窗口中选择待检测的图片即可将图片路径保存至软件的导入视频路径，具体操作如图10所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4k6i.md.png#id=xOgd9&originHeight=500&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当软件处于选择视频功能时，此时界面左上方将显示“正在加载视频…”提示，具体显示如图11所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4zbX.md.png#id=uUzFy&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当用户选定所需要检测的视频时，软件将会将所选择的视频添加相应的骨架图并显示在软件主界面左上方，同时检测出此时图中人物的坐姿情况，并在当前坐姿情况处显示“当前坐姿为——正确坐姿&#x2F;左手挠头&#x2F;右手挠头&#x2F;左手托腮&#x2F;右手托腮&#x2F;打哈欠&#x2F;伸懒腰&#x2F;趴写&#x2F;头左倾斜&#x2F;头右倾斜！”。<br>点击界面下方的“开始&#x2F;暂停视频”，即可播放和暂停所选视频，并进行相应的坐姿检测和疲劳情况分析，并在软件界面下方视频设置区域的当前帧率显示所播放视频帧数的大小——这里为25帧。<br>软件每40毫秒截取一帧图片，并检测当前坐姿情况输出在界面右侧的“当前坐姿情况”处，导入视频结果显示图如下图12所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4hYx.md.png#id=mWL4j&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>由于此时的检测对象为视频，且检测时长不大于60分钟，则输出“当前检测时间过短，无法生成疲劳情况统计图！”<br>若视频中的人物在短时间内多次出现“伸懒腰&#x2F;左手托腮&#x2F;右手托腮和打哈欠”的坐姿，则软件“疲劳情况”处将会进行相应的提醒，结果展示以多次发生打哈欠为例子，如下图13所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4Fmt.md.png#id=jVABU&originHeight=500&originWidth=814&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>若点击界面下方视频设置的“截取视频图像”功能，则可以截取当前视频的图像，并进入文件保存界面，选择选择文件保存地址并对文件进行命名即可保存图像，截取视频图像和所截取得图像如下图所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4nqj.md.png#id=R79uj&originHeight=500&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://i.imgtg.com/2023/07/23/Oh41Ap.md.png#id=aoNDD&originHeight=500&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当检测的视频时长超过60分钟时，可以选择界面右下角“保存”按钮，生成所检测时间段内的疲劳情况统计图，生成过程如下图16所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh47SU.md.png#id=jHDGR&originHeight=500&originWidth=951&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>所选取的视频所生成的疲劳情况统计图如下图所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4NCY.md.png#height=250&id=kYr7q&originHeight=500&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=331"><br>若选择界面右下角“不保存”按钮，则可以回到软件界面初始化状态；与此同时可以选择软件界面下方“视频设置”框栏下的“关闭视频&#x2F;摄像头”按钮，回到软件界面初始化状态，初始化状态如下图18所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4rnv.md.png#id=hf0xo&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🌀实时监控坐姿分析检测"><a href="#🌀实时监控坐姿分析检测" class="headerlink" title="🌀实时监控坐姿分析检测"></a>🌀实时监控坐姿分析检测</h2><h3 id="🔥连接计算机摄像头检测"><a href="#🔥连接计算机摄像头检测" class="headerlink" title="🔥连接计算机摄像头检测"></a>🔥连接计算机摄像头检测</h3><p>点击软件左下方“连接计算机摄像头”按钮，软件即可自动连接本电脑所带的摄像头开始检测，具体操作如图19所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4ADq.md.png#id=YRCIX&originHeight=500&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当用户点击“连接计算机摄像头”时，软件将当前计算机摄像头所拍摄的画面，添加相应的骨架图并显示在软件主界面左上方，同时检测出此时图中人物的坐姿情况，并在当前坐姿情况处显示“当前坐姿为——正确坐姿&#x2F;左手挠头&#x2F;右手挠头&#x2F;左手托腮&#x2F;右手托腮&#x2F;打哈欠&#x2F;伸懒腰&#x2F;趴写&#x2F;头左倾斜&#x2F;头右倾斜！”。<br>在软件界面下方视频设置区域的当前帧率显示计算机摄像头所获取的帧数的大小——这里为25帧。<br>软件每40毫秒截取一帧图片，并检测当前坐姿情况输出在界面右侧的“当前坐姿情况”处，连接计算机摄像头显示图如下图20所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4K6c.md.png#id=T9bke&originHeight=500&originWidth=814&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>由于此时的检测对象为实时检测，当检测时长不大于60分钟，则输出“当前检测时间过短，无法生成疲劳情况统计图！”。<br>若视频中的人物在短时间内多次出现“伸懒腰&#x2F;左手托腮&#x2F;右手托腮和打哈欠”的坐姿，则软件“疲劳情况”处将会进行相应的提醒，结果展示以多次发生“左手托腮”为例子，如下图13所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4ypM.md.png#id=Ioc7a&originHeight=500&originWidth=815&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>若点击界面下方视频设置的“截取视频图像”功能，则可以截取当前视频的图像，并进入文件保存界面，选择选择文件保存地址并对文件进行命名即可保存图像，截取视频图像和所截取得图像如下图所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4vkr.md.png#id=TPCfX&originHeight=500&originWidth=773&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://i.imgtg.com/2023/07/23/Oh4gYG.md.png#height=250&id=D9gr9&originHeight=500&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=331"><br>当检测的视频时长超过60分钟时，可以选择界面右下角“保存”按钮，生成所检测时间段内的疲劳情况统计图，生成过程如下图24所示：<br><img src="https://i.imgtg.com/2023/07/23/Oh4p51.md.png#id=Qao63&originHeight=500&originWidth=920&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>示例的连接计算机摄像头所生成的疲劳情况统计图如下图所示：<br><img src="https://i2.100024.xyz/2023/07/23/qtc6zi.webp#height=213&id=wV1cY&originHeight=849&originWidth=1122&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=281"><br>若选择界面右下角“不保存”按钮，则可以回到软件界面初始化状态；与此同时可以选择软件界面下方“视频设置”框栏下的“关闭视频&#x2F;摄像头”按钮，回到软件界面初始化状态，初始化状态如下图26所示：<br><img src="https://i2.100024.xyz/2023/07/23/qtc6l3.webp#id=uhXNI&originHeight=782&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🔥链接外部摄像头检测"><a href="#🔥链接外部摄像头检测" class="headerlink" title="🔥链接外部摄像头检测"></a>🔥链接外部摄像头检测</h3><p>点击软件左下方“链接外部摄像头”按钮，软件即可自动连接本电脑所链接的外部摄像头开始检测，当前板块的所有功能都与“连接计算机摄像头”功能相同。<br>当用户点击“链接计算机摄像头”时，软件将当前计算机所链接的外部摄像头所拍摄的画面，添加相应的骨架图并显示在软件主界面左上方，同时检测出此时图中人物的坐姿情况，并在当前坐姿情况处显示“当前坐姿为——正确坐姿&#x2F;左手挠头&#x2F;右手挠头&#x2F;左手托腮&#x2F;右手托腮&#x2F;打哈欠&#x2F;伸懒腰&#x2F;趴写&#x2F;头左倾斜&#x2F;头右倾斜！”。<br>在软件界面下方视频设置区域的当前帧率显示外部摄像头所获取的帧数的大小——这里为25帧。<br>软件每40毫秒截取一帧图片，并检测当前坐姿情况输出在界面右侧的“当前坐姿情况”处。<br>由于此时的检测对象为实时检测，当检测时长不大于60分钟，则输出“当前检测时间过短，无法生成疲劳情况统计图！”。<br>若视频中的人物在短时间内多次出现“伸懒腰&#x2F;左手托腮&#x2F;右手托腮和打哈欠”的坐姿，则软件“疲劳情况”处将会进行相应的提醒。<br>若点击界面下方视频设置的“截取视频图像”功能，则可以截取当前视频的图像，并进入文件保存界面，选择选择文件保存地址并对文件进行命名即可保存图。<br>当检测的视频时长超过60分钟时，可以选择界面右下角“保存”按钮，生成所检测时间段内的疲劳情况统计图。<br>若选择界面右下角“不保存”按钮，则可以回到软件界面初始化状态；与此同时可以选择软件界面下方“视频设置”框栏下的“关闭视频&#x2F;摄像头”按钮，回到软件界面初始化状态。</p><h1 id="🌈坐姿检测规则的制定"><a href="#🌈坐姿检测规则的制定" class="headerlink" title="🌈坐姿检测规则的制定"></a>🌈坐姿检测规则的制定</h1><h2 id="🌀数据集收集骨架图生成"><a href="#🌀数据集收集骨架图生成" class="headerlink" title="🌀数据集收集骨架图生成"></a>🌀数据集收集骨架图生成</h2><p>我们邀请到了200位同学，共拍摄了200组照片，这200组照片是以50组为一个大组，一个大组置于同一条件下，不同大组的光源和拍摄位置不同，相邻大组之间只有一个条件不同，以此为基础进行不同坐姿骨架图的生成，我们从每个大组中选择出了20组识别较为准确的姿态图，生成了相应的骨架图。<br><img src="https://i2.100024.xyz/2023/07/23/qz5eyh.webp#id=n0UIM&originHeight=462&originWidth=1095&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🌀坐姿检测规则的制定"><a href="#🌀坐姿检测规则的制定" class="headerlink" title="🌀坐姿检测规则的制定"></a>🌀坐姿检测规则的制定</h2><p><img src="https://i2.100024.xyz/2023/07/23/qzp9as.webp#id=kDx9V&originHeight=526&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>根据mediapipe官网提供的信息，将人体关键点方分别编号如以上图片，记鼻子的索引点为0，表示为P1点，坐标表示为P1(x1,y1)，以此类推其他各点编号以及坐标。</p><h3 id="🔥伸懒腰"><a href="#🔥伸懒腰" class="headerlink" title="🔥伸懒腰"></a>🔥伸懒腰</h3><p>通过比较关键点13、14和15、16关键点与关键点0在y轴方向上的关系来判断。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> y15&lt;y0 <span class="keyword">and</span> y16&lt;y0 Then</span><br><span class="line"><span class="keyword">if</span> y13&gt;y11 <span class="keyword">and</span> y14&gt;y12 Then</span><br><span class="line">    伸懒腰</span><br></pre></td></tr></table></figure><h3 id="🔥左右手托腮"><a href="#🔥左右手托腮" class="headerlink" title="🔥左右手托腮"></a>🔥左右手托腮</h3><p>假设肩膀向量线段表示为l1，l1&#x3D;[x12-x11,y12-y11]；左小臂线段向量表示为l2，l2&#x3D;[x15-x13,y15-y13]，左右手托腮可以根据小臂向量线段和肩膀相连线段是否相交来判断。向量相交用快速排斥实验和叉乘的方法来判断。</p><ol><li><strong>快速排斥：</strong>只要满足P11P12的最大x坐标小于P13P15的最小x坐标，或者P13P15的最大x坐标小于P11P12的最小x坐标，或者P11P12的最大y坐标小于P13P15的最小y坐标，或者P13P15的最大y坐标小于P11P12的最小y坐标，P11P12与P13P15就一定不相交。</li><li><strong>向量叉乘：</strong>判断两个点是否在一条直线或者线段两端，进而判断两条线段是否相交，如果点11和点12在线段P13P15的两端，同时，点P13和点P15在线段P11P12的两端，那么线段P11P12和线段P13P15就相交。</li></ol><p>向量叉乘结果：<br>$l1\times l2&#x3D;(x12-x11)(y15-y13)-(x15-x13)(y12-y11)$</p><h3 id="🔥趴写"><a href="#🔥趴写" class="headerlink" title="🔥趴写"></a>🔥趴写</h3><ol><li>方法一：检测肩膀P11、P12与耳朵P7、P8的距离，小于某个范围就设置输出趴写。</li><li>方法二：计算P15、P13分别和P11的距离，小于某个范围就输出趴写。</li><li>方法三：a. 判断P9、P10两点是否在肩膀P11、P12两点下面，如果在，则输出趴写。</li></ol><p>如果P9P10线段和肩膀向量线段P11P12线段相交，则输出趴写，否则计算P9、P10分别和P11、P12两点之间的竖直距离，如果小于设定范围，则输出趴写。<br>在实际测试发现，方法一会和挠头重合，在趴写时错误输出挠头，测试的准确率灵敏度不是很高。方法二也是同样的问题，和挠头托腮重合度较高。因此运用方法三。方法三是实际输出骨架图时观察的到的，实际测试结果准确率较高，灵敏度也比较高，但是还是有情况会被错误输出为托腮、挠头。</p><h3 id="🔥打哈欠"><a href="#🔥打哈欠" class="headerlink" title="🔥打哈欠"></a>🔥打哈欠</h3><p>考虑到打哈欠动作的多样性，我们采取的判断方法是以关键点20与关键点10、关键点19与关键点9在x、y两方向的距离为判断依据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(x20-x10)&lt;<span class="number">0.05</span> <span class="keyword">and</span> <span class="built_in">abs</span>(y20-y10)&lt;<span class="number">0.05</span> ) <span class="keyword">or</span></span><br><span class="line">(<span class="built_in">abs</span>(x19-x9)&lt;<span class="number">0.05</span> <span class="keyword">and</span> <span class="built_in">abs</span>(y19-y9)&lt;<span class="number">0.05</span>) Then</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打哈欠”)</span></span><br></pre></td></tr></table></figure><h3 id="🔥左右手挠头"><a href="#🔥左右手挠头" class="headerlink" title="🔥左右手挠头"></a>🔥左右手挠头</h3><p>判断小臂向量线段和肩膀向量线段不相交的情况下，判断P19点和P7点之间的距离，P20点和P8点之间的距离，如果小于某个设定范围就输出挠头。<br>两点间距离公式：<br>$\left|P_{19} P_{7}\right|&#x3D;\sqrt{\left(x_{19}-x_{7}\right)^{2}-\left(y_{19}-y_{7}\right)^{2}}$</p><h3 id="🔥头左右倾斜"><a href="#🔥头左右倾斜" class="headerlink" title="🔥头左右倾斜"></a>🔥头左右倾斜</h3><ol><li>方法一：计算P11P12中点坐标的横坐标值，比较中点坐标横坐标和P0点横坐标差值的绝对值，当这个差值超出某个范围时候就判断为头左右倾斜；</li><li>方法二：计算P9P10向量线段的斜率，当斜率超出某个范围的时候，可以判断为头左右倾斜。</li></ol><p>向量斜率计算公式：<br>$k&#x3D;\frac{\left(y10-y9\right)}{(x10-x9)}$<br>对于方法一，实际测试后发现对于每个人来说，0点并非正好位于11、12点的中间，而且每个人的头偏移阈值都不一样，实际测试的时候有错误率很高。因此采用方法二测试。但是在进行测试时候，我们发现处于其他坐姿时，头都会有一定程度的头左右倾斜，因此需要把头左右倾斜优先级放在最后，并且当检测到其他错误坐姿时不检测头左右倾斜。</p><h1 id="🌈项目问题即改进"><a href="#🌈项目问题即改进" class="headerlink" title="🌈项目问题即改进"></a>🌈项目问题即改进</h1><h3 id="🔥关于姿态估计是基于OpenPose还是基于MediaPipe"><a href="#🔥关于姿态估计是基于OpenPose还是基于MediaPipe" class="headerlink" title="🔥关于姿态估计是基于OpenPose还是基于MediaPipe"></a>🔥关于姿态估计是基于OpenPose还是基于MediaPipe</h3><p>在项目立项时我们最初决定使用OpenPose来进行姿态检测，但在后续的对比中，我们发现MediaPipe姿态检测更适合我们的项目，原因有下列几点：</p><ol><li>OpenPose对电脑的硬件系统要求比较高</li><li>OpenPose主要用于多人检测，而MediaPipe用于单人检测，更符合我们的项目需求</li><li>OpenPose检测的时间较长，而MediaPipe更适合实时监测</li><li>OpenPose检测的是二维平面的，而MediaPipe则是基于三维的，对于人体姿态的检测更加准确。</li></ol><h3 id="🔥坐标检测不能满足本项目所需坐姿检测的准确度"><a href="#🔥坐标检测不能满足本项目所需坐姿检测的准确度" class="headerlink" title="🔥坐标检测不能满足本项目所需坐姿检测的准确度"></a>🔥坐标检测不能满足本项目所需坐姿检测的准确度</h3><p>在本项目前期的工作过程中，坐姿检测的方式主要是基于坐标的一些规则来判定的，且初期频频出现问题，在后期的不断优化中，虽然正确率提高了很多，但是仍然会存在判断失误的时候。<br>因此我们在项目后期，计划改变我们的方法，采用以神经网络判定为主，坐标规则为辅的方法，目前我们的计划采用的神经网络主要有三种：①MoblieNet②part-action-network③ST-GCN，在后期的项目实施中，我们会灵活改变。</p><h3 id="🔥软件的图形界面如何更完善"><a href="#🔥软件的图形界面如何更完善" class="headerlink" title="🔥软件的图形界面如何更完善"></a>🔥软件的图形界面如何更完善</h3><p>目前软件的图形界面主要存在三个问题：1.坐姿情况的输出问题2.疲劳情况的可视化展示问题3.软件界面过于简单。</p><ol><li>对于第一个问题，目前软件所采取的是每40毫秒截取一张视频中的图像，并对当前所截取的图像进行骨骼检测并分析坐姿情况，并将这一帧的坐姿情况输出至图形界面的坐姿情况部分。但在实际调试和使用的过程中我们发现，过于频繁的截取视频并判断会导致输出结果卡顿和视频不流畅等问题，且在长时间的检测中会过多占用CPU内存。因此，通过我们的讨论，我们准备每隔一段时间截取视频图像并进行分析，并设定一定的阈值再进行坐姿检测输出。</li><li>对于第二个问题，为了更好的展示用于的疲劳程度，我们对于目前的输出文字提醒的改进方法为对左右手托腮、打哈欠、伸懒腰设定一定的分数，并记录在检测过程中出现的次数，进行可视化图片的生成。</li></ol><p>对于软件界面的美化部分，预计将不同功能划分到不同的界面，并增加背景图片等内容以增加其美观性。</p><h2 id="🌀数据集收集骨架图生成-1"><a href="#🌀数据集收集骨架图生成-1" class="headerlink" title="🌀数据集收集骨架图生成"></a>🌀数据集收集骨架图生成</h2>]]></content>
      
      
      <categories>
          
          <category> 科研项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统硬件综合设计——MIPS五级流水线</title>
      <link href="/2023/01/20/%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94MIPS%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2023/01/20/%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94MIPS%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="⛅设计要求"><a href="#⛅设计要求" class="headerlink" title="⛅设计要求"></a>⛅设计要求</h1><p>基于先修课程，根据系统设计思想，使用硬件描述语言设计实现一款基于MIPS32，ARM，RISC-V或者自定义指令集的微处理器（CPU）。要求：完成单周期CPU设计，或多周期CPU设计，或5级流水线CPU设计（递进式、难度依次提升。所有学生必须至少完成单周期CPU的设计工作），并将设计的CPU下载至FPGA开发板（ego-1）上运行。以此贯穿数字逻辑、计算机组成原理、计算机体系结构课程，实现从逻辑门至完整CPU处理器的设计。</p><h2 id="🌞CPU指令执行流程"><a href="#🌞CPU指令执行流程" class="headerlink" title="🌞CPU指令执行流程"></a>🌞CPU指令执行流程</h2><p>冯·诺伊曼型计算机的CPU将指令和数据不加区分放在存储中，指令的处理过程需要访问存储。如图所示，一条指令的处理通常可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回。<br><img src="https://i.imgtg.com/2023/07/23/OhRrcU.png#height=173&id=CseFv&originHeight=345&originWidth=243&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=122"></p><h3 id="🌟取指阶段-IF-Instruction-Fetch"><a href="#🌟取指阶段-IF-Instruction-Fetch" class="headerlink" title="🌟取指阶段(IF, Instruction Fetch)"></a>🌟取指阶段(IF, Instruction Fetch)</h3><p>在上一个指令周期时，程序计数器PC中记录的是下一条指令的内存地址。因此IF阶段CPU指令寄存器按照PC的地址从主存中取得一条指令，当前指令被取出后，PC更新到下一条指令的地址。</p><h3 id="🌟指令译码阶段-ID-Instruction-Decode"><a href="#🌟指令译码阶段-ID-Instruction-Decode" class="headerlink" title="🌟指令译码阶段(ID, Instruction Decode)"></a>🌟指令译码阶段(ID, Instruction Decode)</h3><p>在ID阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。</p><h3 id="🌟执行指令阶段-EXE-Execute"><a href="#🌟执行指令阶段-EXE-Execute" class="headerlink" title="🌟执行指令阶段(EXE, Execute)"></a>🌟执行指令阶段(EXE, Execute)</h3><p>通过对指令的译码，CPU已经知晓这条指令要如何执行，因此EXE阶段就是通过操作控制器OC，按确定的时序向相应的部件发出微操作控制信号以对指令要求的特定操作进行具体实现。EXE阶段CPU的不同部分(如ALU、寄存器组等)被联合起来，以实现指令所需的操作。</p><h3 id="🌟访存取数阶段-MEM-Memory"><a href="#🌟访存取数阶段-MEM-Memory" class="headerlink" title="🌟访存取数阶段(MEM, Memory)"></a>🌟访存取数阶段(MEM, Memory)</h3><p>根据指令需要可能要访问内存，读取操作数。MEM阶段根据指令地址码(如果有要求的话)得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</p><h3 id="🌟写回阶段-WB-Write-Back"><a href="#🌟写回阶段-WB-Write-Back" class="headerlink" title="🌟写回阶段(WB, Write Back)"></a>🌟写回阶段(WB, Write Back)</h3><p>WB阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：</p><ol><li>写入CPU的内部寄存器中，以便被后续的指令快速地存取</li><li>写入内存</li><li>改变FR中标志位状态(如果需要改变的话)，用来影响接下来程序的动作</li></ol><p>WB阶段结束后，若无意外事件（如结果溢出等）或异常中断发生，计算机就接着从程序计数器PC中取得下一条指令地址，开始新一轮的循环。上述五个阶段在具体实现过程中会引入指令流水线来提高效率。</p><h2 id="🌞MIPS体系结构"><a href="#🌞MIPS体系结构" class="headerlink" title="🌞MIPS体系结构"></a>🌞MIPS体系结构</h2><p>MIPS是RISC处理器中的一种。MIPS即无内部互锁流水线的微处理器（Microprocessor Without Interlocked Piped Stages），其设计机制是尽量避免处理器中流水线上各种相关问题，使得程序指令可以尽量不停顿的执行。可以说，MIPS是为了流水线而生的，这也是本设计选择MIPS作为目标CPU架构的主要原因。接下来介绍与MIPS有关的一些基本概念。</p><h3 id="🌟MPIS指令集"><a href="#🌟MPIS指令集" class="headerlink" title="🌟MPIS指令集"></a>🌟MPIS指令集</h3><p>每一条MIPS指令的长度是32位。MIPS指令集包括三种类型的指令：寄存器类型指令，立即数类型指令和跳转类型指令1B7。寄存器类型指令只有通用寄存器之间的操作，不包含立即数；立即数类型指令是通用寄存器和16位立即数之间的操作；而跳转类型指令包含一个26位的指令地址索引，可以进行大范围绝对地址跳转。MIPS架构这种精简指令集处理器在很大程度上减少指令数目并且极大的简化了指令的译码和执行，程序编译器还可以利用若干个简单的指令合理的组合，形成更加复杂的操作。<br>三种指令类型（分别为 R、I、J 指令格式）如下图所示：<br><img src="https://i.imgtg.com/2023/07/23/OhRKMY.png#height=147&id=WjynH&originHeight=294&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=410"><br>MIPS指令域说明如下：<br><img src="https://i.imgtg.com/2023/07/23/OhRZ7v.png#id=BayLT&originHeight=418&originWidth=1127&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>MIPS32指令分为如下几类：</p><ul><li>存储器访问指令：用于在存储器和通用寄存器之间传递数据。访问存储器的地址是通用寄存器的值和16位有符号立即数相加的值，存储器访问指令都属于立即数类型指令。</li><li>运算指令：完成定点的算术、逻辑、移位等运算操作。操作数据既可以是通用寄存器的值，也可以是16位立即数。运算指令可以是寄存器类型或立即数类型。</li><li>分支跳转指令：可以改变程序指令的顺序执行。分支指令用PC寄存器的值加上16位立即数左移2位指向目的地址。跳转指令把指令中程序索引或者某个通用寄存器的内容写入PC。分支指令属于立即数类型，跳转指令可以是寄存器类型或跳转类型。</li><li>系统协处理器指令：进行系统协处理器寄存器的读写操作。</li></ul><p>特别说明，为了方便与实现，在本次实验中所实现的36条指令与标准 MIPS 指令做出了相应的调整，不同之处如下：</p><ul><li>op-code 为 1-36，直接区分各个指令的不同</li><li>R 指令中 shamt、func-code 均置为 0。</li></ul><h1 id="⛅CPU设计与实现"><a href="#⛅CPU设计与实现" class="headerlink" title="⛅CPU设计与实现"></a>⛅CPU设计与实现</h1><h2 id="🌞指令设计"><a href="#🌞指令设计" class="headerlink" title="🌞指令设计"></a>🌞指令设计</h2><p>为了方便以后在此实验基础上扩展实现基本的MIPS指令集，所以参照MIPS 指令集结构，设计指令位数为 32 位，其中前六位是操作码字段，可以根据此字段判断是何种指令，从而使控制器发出相应的控制信号。</p><h3 id="🌟R型指令"><a href="#🌟R型指令" class="headerlink" title="🌟R型指令"></a>🌟R型指令</h3><p>不同功能的R型指令使用的寄存器数量不一定相同，有一个、两个、三个。R型指令根据操作的寄存器数可以分为三种不同类型：</p><ul><li>带有3个寄存器；</li><li>带有2个寄存器；</li><li>带有1个寄存器。</li></ul><h3 id="🌟I型指令"><a href="#🌟I型指令" class="headerlink" title="🌟I型指令"></a>🌟I型指令</h3><p>操作数中涉及立即数，结果保存到寄存器。I型指令存在4种不同的类型：</p><ul><li>面向运算的I型指令；</li><li>面向访存的I型指令；</li><li>面向数位设置的I型指令；</li><li>面向条件转移（分支）的I型指令。</li></ul><h3 id="🌟J型指令"><a href="#🌟J型指令" class="headerlink" title="🌟J型指令"></a>🌟J型指令</h3><p>J型指令支持无条件跳转指令。</p><h3 id="🌟实验指令"><a href="#🌟实验指令" class="headerlink" title="🌟实验指令"></a>🌟实验指令</h3><p>在本次实验中一共实现了35 指令，包括11 条 R 型指令，23 条 I 型指令和 1 条 J 型指令，特别说明，为了方便与实现，在本次实验中所实现的35条指令与标准 MIPS 指令做出了相应的调整，，实现的指令格式如下：</p><table><thead><tr><th>功能</th><th>指令功能</th><th>指令</th><th>寄存器数量</th><th>31-26</th><th>25-21</th><th>20-16</th><th>15-11</th><th>10-6</th><th>5-0</th></tr></thead><tbody><tr><td>ADD</td><td>寄存器加</td><td>R</td><td>num_3reg</td><td>1</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>ADDI</td><td>寄存器和立即数“加”</td><td>I</td><td>num_2reg_imm</td><td>2</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>SUB</td><td>寄存器减</td><td>R</td><td>num_3reg</td><td>4</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>AND</td><td>寄存器与</td><td>R</td><td>num_3reg</td><td>5</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>ANDI</td><td>寄存器和立即数“与”</td><td>I</td><td>num_2reg_imm</td><td>6</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>OR</td><td>寄存器或</td><td>R</td><td>num_3reg</td><td>7</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>ORI</td><td>寄存器和立即数“或”</td><td>I</td><td>num_2reg_imm</td><td>8</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>NOR</td><td>寄存器与或</td><td>R</td><td>num_3reg</td><td>9</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>NORI</td><td>寄存器和立即数“与或”</td><td>I</td><td>num_2reg_imm</td><td>10</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>XOR</td><td>寄存器异或</td><td>R</td><td>num_3reg</td><td>11</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>XORI</td><td>寄存器和立即数“异或”</td><td>I</td><td>num_2reg_imm</td><td>12</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>BEQ</td><td>寄存器相等则转移</td><td>I</td><td>num_2reg_imm</td><td>13</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>BEQZ</td><td></td><td>I</td><td>num_reg_imm</td><td>14</td><td>Rs</td><td>0</td><td>offset</td><td></td><td></td></tr><tr><td>BNE</td><td>寄存器不相等则转移</td><td>I</td><td>num_2reg_imm</td><td>15</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>BNEZ</td><td></td><td>I</td><td>num_reg_imm</td><td>16</td><td>Rs</td><td>0</td><td>offset</td><td></td><td></td></tr><tr><td>BGT</td><td>大于 (&gt;) 时分支</td><td>I</td><td>num_2reg_imm</td><td>17</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>BGE</td><td>大于等于 (≥) 时分支</td><td>I</td><td>num_2reg_imm</td><td>18</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>BLT</td><td>小于 (&lt;) 时分支</td><td>I</td><td>num_2reg_imm</td><td>19</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>BLE</td><td>小于等于 (≤) 时分支</td><td>I</td><td>num_2reg_imm</td><td>20</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>J</td><td>无条件跳转</td><td>J</td><td>num_imm</td><td>21</td><td>INSTR_INDEX</td><td></td><td></td><td></td><td></td></tr><tr><td>JR</td><td></td><td>R</td><td>num_reg</td><td>22</td><td>Rs</td><td>0</td><td></td><td></td><td></td></tr><tr><td>LB</td><td>加载字节</td><td>I</td><td>num_2reg</td><td>23</td><td>Base</td><td>Rt</td><td>offset</td><td></td><td></td></tr><tr><td>LH</td><td>加载半字</td><td>I</td><td>num_2reg</td><td>24</td><td>Base</td><td>Rt</td><td>offset</td><td></td><td></td></tr><tr><td>LW</td><td>从存储器种读取数据</td><td>I</td><td>num_2reg</td><td>25</td><td>Base</td><td>Rt</td><td>offset</td><td></td><td></td></tr><tr><td>SB</td><td>存储半字</td><td>I</td><td>num_2reg</td><td>26</td><td>Base</td><td>Rt</td><td>offset</td><td></td><td></td></tr><tr><td>SH</td><td>存储半字</td><td>I</td><td>num_2reg</td><td>27</td><td>Base</td><td>Rt</td><td>offset</td><td></td><td></td></tr><tr><td>SW</td><td>把数据保存到存储器</td><td>I</td><td>num_2reg</td><td>28</td><td>Base</td><td>Rt</td><td>offset</td><td></td><td></td></tr><tr><td>SLLI</td><td></td><td>I</td><td>num_2reg_imm</td><td>29</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>SLL</td><td>逻辑左移</td><td>R</td><td>num_3reg</td><td>30</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>SRLI</td><td></td><td>I</td><td>num_2reg_imm</td><td>31</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>SRL</td><td>逻辑右移</td><td>R</td><td>num_3reg</td><td>32</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>SRAI</td><td></td><td>I</td><td>num_2reg_imm</td><td>33</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr><tr><td>SRA</td><td>算数右移</td><td>R</td><td>num_3reg</td><td>34</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>SLT</td><td>算数左移</td><td>R</td><td>num_3reg</td><td>35</td><td>Rs</td><td>Rt</td><td>Rd</td><td>0</td><td>0</td></tr><tr><td>SLTI</td><td></td><td>I</td><td>num_2reg_imm</td><td>36</td><td>Rs</td><td>Rt</td><td>imm</td><td></td><td></td></tr></tbody></table><h3 id="🌟指令进制转换"><a href="#🌟指令进制转换" class="headerlink" title="🌟指令进制转换"></a>🌟指令进制转换</h3><p>为了能够更方便的进行测试，我们编写了python脚本，将MIPS代码转换为十六进制代码。<br>将所有MIPS指令按照R、I、J指令以及寄存器数量分为如上表所示的6类，并根据每一类指令的特点和指令格式按照要求生成所对应的十六进制代码。<br>该脚本有以下好处：</p><ul><li>为后续测试用例的生成提供了便捷性；</li><li>后续增加指令便捷，CPU可扩展性高。</li></ul><p>指令进制转换代码如下：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">def trans_mips2hex(instruction: str):</span><br><span class="line">opList = &#123;</span><br><span class="line">  &#x27;add&#x27;: <span class="number">1</span>, &#x27;addi&#x27;: <span class="number">2</span>, &#x27;sub&#x27;: <span class="number">4</span>, &#x27;<span class="keyword">and</span>&#x27;: <span class="number">5</span>, &#x27;andi&#x27;: <span class="number">6</span>, &#x27;<span class="keyword">or</span>&#x27;: <span class="number">7</span>, &#x27;ori&#x27;: <span class="number">8</span>, &#x27;<span class="keyword">nor</span>&#x27;: <span class="number">9</span>, &#x27;nori&#x27;: <span class="number">10</span>,</span><br><span class="line">  &#x27;<span class="keyword">xor</span>&#x27;: <span class="number">11</span>, &#x27;xori&#x27;: <span class="number">12</span>, <span class="number">&#x27;be</span>q&#x27;: <span class="number">13</span>, <span class="number">&#x27;be</span>qz&#x27;: <span class="number">14</span>, &#x27;bne&#x27;: <span class="number">15</span>, &#x27;bnez&#x27;: <span class="number">16</span>, &#x27;bgt&#x27;: <span class="number">17</span>, &#x27;bge&#x27;: <span class="number">18</span>, &#x27;blt&#x27;: <span class="number">19</span>, &#x27;ble&#x27;: <span class="number">20</span>,</span><br><span class="line">  &#x27;j&#x27;: <span class="number">21</span>, &#x27;jr&#x27;: <span class="number">23</span>, &#x27;lb&#x27;: <span class="number">24</span>, &#x27;lh&#x27;: <span class="number">25</span>, &#x27;lw&#x27;: <span class="number">26</span>, &#x27;sb&#x27;: <span class="number">27</span>, &#x27;sh&#x27;: <span class="number">28</span>, &#x27;sw&#x27;: <span class="number">29</span>, &#x27;slli&#x27;: <span class="number">30</span>,</span><br><span class="line">  &#x27;sll&#x27;: <span class="number">31</span>, &#x27;srli&#x27;: <span class="number">32</span>, &#x27;srl&#x27;: <span class="number">33</span>, &#x27;srai&#x27;: <span class="number">34</span>, &#x27;sra&#x27;: <span class="number">35</span>, &#x27;slt&#x27;: <span class="number">36</span>, &#x27;slti&#x27;: <span class="number">37</span></span><br><span class="line">&#125;</span><br><span class="line">num_3reg = [&#x27;add&#x27;, &#x27;sub&#x27;, &#x27;<span class="keyword">and</span>&#x27;, &#x27;<span class="keyword">or</span>&#x27;, &#x27;<span class="keyword">nor</span>&#x27;, &#x27;<span class="keyword">xor</span>&#x27;, &#x27;sll&#x27;, &#x27;srl&#x27;, &#x27;sra&#x27;, &#x27;slt&#x27;]</span><br><span class="line">num_2reg_imm = [&#x27;addi&#x27;, &#x27;addiu&#x27;, &#x27;andi&#x27;, &#x27;ori&#x27;, &#x27;nori&#x27;, &#x27;xori&#x27;, <span class="number">&#x27;be</span>q&#x27;, &#x27;bne&#x27;, &#x27;bgt&#x27;, &#x27;bge&#x27;, &#x27;blt&#x27;,</span><br><span class="line">                    &#x27;ble&#x27;, &#x27;slli&#x27;, &#x27;srli&#x27;, &#x27;srai&#x27;, &#x27;slti&#x27;]</span><br><span class="line">num_reg_imm = [<span class="number">&#x27;be</span>qz&#x27;, &#x27;bnez&#x27;]</span><br><span class="line">num_imm = [&#x27;j&#x27;]</span><br><span class="line">num_reg = [&#x27;jr&#x27;]</span><br><span class="line">num_2reg = [&#x27;lb&#x27;, &#x27;lh&#x27;, &#x27;lw&#x27;, &#x27;sb&#x27;, &#x27;sh&#x27;, &#x27;sw&#x27;]</span><br><span class="line"></span><br><span class="line">instruction = instruction<span class="variable">.strip</span>()</span><br><span class="line">op = re<span class="variable">.match</span>(r&#x27;([A-Za-z]*)&#x27;, instruction)<span class="variable">.group</span>(<span class="number">0</span>)</span><br><span class="line">reg_imm = instruction<span class="variable">.split</span>(op)[-<span class="number">1</span>]<span class="variable">.strip</span>()<span class="variable">.split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">op_bin = &#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(opList<span class="variable">.get</span>(op)) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">6</span>)</span><br><span class="line">args_bin = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> op in num_3reg:</span><br><span class="line">  regs = [&#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[i]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">5</span>) <span class="keyword">for</span> i in range(<span class="number">3</span>)]</span><br><span class="line">    args_bin += <span class="string">&quot;&quot;</span><span class="variable">.join</span>(regs)</span><br><span class="line">    result_bin = (op_bin + args_bin)<span class="variable">.ljust</span>(<span class="number">32</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">    elif op in num_2reg_imm:</span><br><span class="line">    regs = [&#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[i]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">5</span>) <span class="keyword">for</span> i in range(<span class="number">2</span>)]</span><br><span class="line">      args_bin += <span class="string">&quot;&quot;</span><span class="variable">.join</span>(regs)</span><br><span class="line">      args_bin += &#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[<span class="number">2</span>]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">16</span>)</span><br><span class="line">      result_bin = (op_bin + args_bin)<span class="variable">.ljust</span>(<span class="number">32</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">      elif op in num_reg_imm:</span><br><span class="line">      args_bin = (&#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[<span class="number">0</span>]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">5</span>))<span class="variable">.ljust</span>(<span class="number">10</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">      args_bin += &#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[<span class="number">1</span>]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">16</span>)</span><br><span class="line">      result_bin = (op_bin + args_bin)<span class="variable">.ljust</span>(<span class="number">32</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">      elif op in num_imm:</span><br><span class="line">      args_bin += (&#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[<span class="number">0</span>]) &amp; <span class="number">0</span>xfffffff)<span class="variable">.zfill</span>(<span class="number">26</span>))[-<span class="number">26</span>:]</span><br><span class="line">      result_bin = (op_bin + args_bin)<span class="variable">.ljust</span>(<span class="number">32</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">      elif op in num_reg:</span><br><span class="line">      args_bin += &#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[<span class="number">0</span>]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">5</span>)</span><br><span class="line">      result_bin = (op_bin + args_bin)<span class="variable">.ljust</span>(<span class="number">32</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">      elif op in num_2reg:</span><br><span class="line">      regs = [&#x27;&#123;:b&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(reg_imm[i]) &amp; <span class="number">0</span>xffff)<span class="variable">.zfill</span>(<span class="number">5</span>) <span class="keyword">for</span> i in range(<span class="number">2</span>)]</span><br><span class="line">        args_bin += <span class="string">&quot;&quot;</span><span class="variable">.join</span>(regs)</span><br><span class="line">        result_bin = (op_bin + args_bin)<span class="variable">.ljust</span>(<span class="number">32</span>, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          raise Exception(<span class="string">&quot;指令出错&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> result_bin, &#x27;&#123;:x&#125;&#x27;<span class="variable">.format</span>(<span class="keyword">int</span>(result_bin, <span class="number">2</span>) &amp; <span class="number">0</span>xffffffff)<span class="variable">.zfill</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h2 id="🌞CPU设计"><a href="#🌞CPU设计" class="headerlink" title="🌞CPU设计"></a>🌞CPU设计</h2><h3 id="🌟CPU整体架构"><a href="#🌟CPU整体架构" class="headerlink" title="🌟CPU整体架构"></a>🌟CPU整体架构</h3><p><img src="https://i.imgtg.com/2023/07/23/OhRHOF.md.png#id=oDaV6&originHeight=500&originWidth=1965&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🌟取指模块"><a href="#🌟取指模块" class="headerlink" title="🌟取指模块"></a>🌟取指模块</h3><p>| <img src="https://i.imgtg.com/2023/07/23/OhRELP.png#id=Hmd2e&originHeight=224&originWidth=242&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p> | </p><p><img src="https://i.imgtg.com/2023/07/23/OhRL76.png#id=nGynr&originHeight=113&originWidth=239&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> |<br>| — | — |<br>| if_pc模块 | if_im模块 |</p><p>取指模块主要由if_pc和if_im构成，其主要功能如下所示：</p><ul><li>if_pc——根据PC的值在存储器中取指令</li><li>if_im——指令存储器，根据输入pc得到的地址取指令</li></ul><h3 id="🌟译码模块"><a href="#🌟译码模块" class="headerlink" title="🌟译码模块"></a>🌟译码模块</h3><table><thead><tr><th><img src="https://i.imgtg.com/2023/07/23/OhRc9B.png#id=Jf0LN&originHeight=214&originWidth=250&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th><th><img src="https://i.imgtg.com/2023/07/23/OhRSzl.png#id=kCn51&originHeight=215&originWidth=233&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th><th><img src="https://i.imgtg.com/2023/07/23/OhR0Pg.png#id=IlwCI&originHeight=195&originWidth=225&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></th></tr></thead><tbody><tr><td>id_decode模块</td><td>id_control模块</td><td>reg_file模块</td></tr></tbody></table><p>译码模块主要由id_decode、id_control、reg_file构成，其主要功能如下所示：</p><ul><li>id_decode——将从IM模块取出的指令内容译码，分开操作码、寄存器、立即数和跳转地址。</li><li>id_control——对于id_decode模块译码的各个部分分别进行判断，修改某些后续可能用到的标志，如跳转标志、写回标志、访存标志。</li><li>reg_file——初始化一个32位寄存器，解决寄存器两个端口读写问题。</li></ul><h3 id="🌟执行模块"><a href="#🌟执行模块" class="headerlink" title="🌟执行模块"></a>🌟执行模块</h3><p><img src="https://i.imgtg.com/2023/07/23/OhRVvK.png#id=EiGuX&originHeight=118&originWidth=251&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>执行模块主要由exe_alu构成，该模块所定义的接口如下表所示：</p><table><thead><tr><th>ALU</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>序号</td><td>接口名</td><td>宽度</td><td>输入&#x2F;输出</td><td>作用</td></tr><tr><td>1</td><td>alu_op_s3</td><td>6</td><td>输入</td><td>操作码</td></tr><tr><td>2</td><td>alu_data1_s3</td><td>32</td><td>输入</td><td>源操作数</td></tr><tr><td>3</td><td>alu_data2_s3</td><td>32</td><td>输入</td><td>源操作数</td></tr><tr><td>4</td><td>alu_out_s3</td><td>32</td><td>输出</td><td>运算后的结果</td></tr></tbody></table><p>其对应功能如下：<br>实现运算，针对35条指令分别实现运算。接收来自上一级的寄存器数据和操作码类型，然后根据操作码类型判断做何种运算，将运算结果传给下一级。<br>根据每一种运算的计算过程，计算该运算符所对应的规则并将答案传输到alu_out_s3中给下一级，其具体代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(alu_op_s3)</span><br><span class="line">        <span class="comment">// add addi</span></span><br><span class="line">        <span class="number">6&#x27;d1</span>,<span class="number">6&#x27;d2</span>,<span class="number">6&#x27;d3</span>: alu_out_s3 &lt;= alu_data1_s3 + alu_data2_s3;</span><br><span class="line">        <span class="comment">// sub</span></span><br><span class="line">        <span class="number">6&#x27;d4</span>: alu_out_s3 &lt;= alu_data1_s3 - alu_data2_s3;</span><br><span class="line">        <span class="comment">// and andi</span></span><br><span class="line">        <span class="number">6&#x27;d5</span>,<span class="number">6&#x27;d6</span>: alu_out_s3 &lt;= alu_data1_s3 &amp; alu_data2_s3;</span><br><span class="line">        <span class="comment">// or ori</span></span><br><span class="line">        <span class="number">6&#x27;d7</span>,<span class="number">6&#x27;d8</span>: alu_out_s3 &lt;= alu_data1_s3 | alu_data2_s3;</span><br><span class="line">        <span class="comment">// nor nori</span></span><br><span class="line">        <span class="number">6&#x27;d9</span>,<span class="number">6&#x27;d10</span>: alu_out_s3 &lt;= ~(alu_data1_s3 | alu_data2_s3);</span><br><span class="line">        <span class="comment">// xor xori</span></span><br><span class="line">        <span class="number">6&#x27;d11</span>,<span class="number">6&#x27;d12</span>: alu_out_s3 &lt;= alu_data1_s3 ^ alu_data2_s3;</span><br><span class="line">        <span class="comment">// beq beqz</span></span><br><span class="line">        <span class="number">6&#x27;d13</span>,<span class="number">6&#x27;d14</span>: alu_out_s3 &lt;= (alu_data1_s3 == alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// bne bnez</span></span><br><span class="line">        <span class="number">6&#x27;d15</span>,<span class="number">6&#x27;d16</span>: alu_out_s3 &lt;= (alu_data1_s3 != alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// bgt</span></span><br><span class="line">        <span class="number">6&#x27;d17</span>: alu_out_s3 &lt;= (alu_data1_s3 &gt; alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// bge</span></span><br><span class="line">        <span class="number">6&#x27;d18</span>: alu_out_s3 &lt;= (alu_data1_s3 &gt;= alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// blt</span></span><br><span class="line">        <span class="number">6&#x27;d19</span>: alu_out_s3 &lt;= (alu_data1_s3 &lt; alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// ble</span></span><br><span class="line">        <span class="number">6&#x27;d20</span>: alu_out_s3 &lt;= (alu_data1_s3 &lt;= alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// j </span></span><br><span class="line">        <span class="number">6&#x27;d21</span>: alu_out_s3 &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="comment">// jr</span></span><br><span class="line">        <span class="number">6&#x27;d23</span>: alu_out_s3 &lt;= alu_data1_s3;</span><br><span class="line">        <span class="comment">// lb lh lw</span></span><br><span class="line">        <span class="number">6&#x27;d24</span>,<span class="number">6&#x27;d25</span>,<span class="number">6&#x27;d26</span>: alu_out_s3 &lt;= alu_data1_s3;</span><br><span class="line">        <span class="comment">// sb sh sw</span></span><br><span class="line">        <span class="number">6&#x27;d27</span>,<span class="number">6&#x27;d28</span>,<span class="number">6&#x27;d29</span>: alu_out_s3 &lt;= alu_data2_s3;</span><br><span class="line">        <span class="comment">// slli</span></span><br><span class="line">        <span class="number">6&#x27;d30</span>: alu_out_s3 &lt;= alu_data1_s3 &lt;&lt; alu_data2_s3;</span><br><span class="line">        <span class="comment">// sll</span></span><br><span class="line">        <span class="number">6&#x27;d31</span>: alu_out_s3 &lt;= alu_data1_s3 &lt;&lt; alu_data2_s3[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// srli</span></span><br><span class="line">        <span class="number">6&#x27;d32</span>: alu_out_s3 &lt;= alu_data1_s3 &gt;&gt; alu_data2_s3;</span><br><span class="line">        <span class="comment">// srl</span></span><br><span class="line">        <span class="number">6&#x27;d33</span>: alu_out_s3 &lt;= alu_data1_s3 &gt;&gt; alu_data2_s3[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// srai</span></span><br><span class="line">        <span class="number">6&#x27;d34</span>: alu_out_s3 &lt;= alu_data1_s3 &gt;&gt;&gt; alu_data2_s3;</span><br><span class="line">        <span class="comment">// sra</span></span><br><span class="line">        <span class="number">6&#x27;d35</span>: alu_out_s3 &lt;= alu_data1_s3 &gt;&gt;&gt; alu_data2_s3[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// slt slti</span></span><br><span class="line">        <span class="number">6&#x27;d36</span>,<span class="number">6&#x27;d37</span>: alu_out_s3 &lt;= (alu_data1_s3 &lt; alu_data2_s3)?<span class="number">32&#x27;b1</span>:<span class="number">32&#x27;b0</span>;</span><br><span class="line">    Endcase</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="🌟访存模块"><a href="#🌟访存模块" class="headerlink" title="🌟访存模块"></a>🌟访存模块</h3><p><img src="https://i.imgtg.com/2023/07/23/OhRlOS.png#id=r6ArI&originHeight=174&originWidth=298&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>访存模块主要由mem_dm构成，该模块所定义的接口如下表所示：</p><table><thead><tr><th>mem</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>序号</td><td>接口名</td><td>宽度</td><td>输入&#x2F;输出</td><td>作用</td></tr><tr><td>1</td><td>clk</td><td>1</td><td>输入</td><td>时钟信号</td></tr><tr><td>2</td><td>alu_out_s4</td><td>32</td><td>输入</td><td>写内存的地址</td></tr><tr><td>3</td><td>mem_read_s4</td><td>1</td><td>输入</td><td>读标志</td></tr><tr><td>4</td><td>mem_write_s4</td><td>1</td><td>输入</td><td>写标志</td></tr><tr><td>5</td><td>write_data_s4</td><td>32</td><td>输入</td><td>写内存的数据</td></tr><tr><td>6</td><td>rw_bits_s4</td><td>2</td><td>输入</td><td>读写内存写的位数</td></tr><tr><td>7</td><td>mem_read_data_s4</td><td>32</td><td>输出</td><td>读内存的数据</td></tr></tbody></table><p>其对应功能如下：<br>初始化存储器，根据前面模块传来的标志和数据进行相关操作。<br>当写标志为1时，分为三种情况，即根据要写数据的位数，分为8、16、32位。其主要代码如下所示，根据写入数据的位数不同，将寄存器中的相应位数进行写入：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (mem_write_s4) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(rw_bits_s4)</span><br><span class="line">            <span class="comment">// 8bits</span></span><br><span class="line">            <span class="number">2&#x27;d1</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(alu_out_s4[<span class="number">1</span>:<span class="number">0</span>])</span><br><span class="line">                    <span class="number">2&#x27;b00</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">7</span>:<span class="number">0</span>] &lt;= write_data_s4[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">                    <span class="number">2&#x27;b01</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">15</span>:<span class="number">8</span>] &lt;= write_data_s4[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">                    <span class="number">2&#x27;b10</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">23</span>:<span class="number">16</span>] &lt;= write_data_s4[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">                    <span class="number">2&#x27;b11</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">31</span>:<span class="number">24</span>] &lt;= write_data_s4[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// 16bits</span></span><br><span class="line">            <span class="number">2&#x27;d2</span>:<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(alu_out_s4[<span class="number">1</span>])</span><br><span class="line">                    <span class="number">1&#x27;b0</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">15</span>:<span class="number">0</span>] &lt;= write_data_s4[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                    <span class="number">1&#x27;b1</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">31</span>:<span class="number">16</span>] &lt;= write_data_s4[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// 32bits</span></span><br><span class="line">            <span class="keyword">default</span>:mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]] &lt;= write_data_s4;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当读标志为1时，分为三种情况，即根据要读数据的位数，分为8、16、32位。其主要代码如下所示，根据读入数据的位数不同，将寄存器中的相应位数进行读取，其原理与写入操作相同：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (mem_read_s4) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(mem_write_s4)<span class="keyword">begin</span></span><br><span class="line">                mem_read_data_s4 &lt;= write_data_s4;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                 <span class="keyword">case</span>(rw_bits_s4)</span><br><span class="line">                    <span class="comment">// 8bits</span></span><br><span class="line">                    <span class="number">2&#x27;d1</span>:<span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(alu_out_s4[<span class="number">1</span>:<span class="number">0</span>])</span><br><span class="line">                            <span class="number">2&#x27;b00</span>:mem_read_data_s4&lt;=&#123;<span class="number">24&#x27;b0</span>,mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">7</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                            <span class="number">2&#x27;b01</span>:mem_read_data_s4&lt;=&#123;<span class="number">24&#x27;b0</span>,mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">15</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">                            <span class="number">2&#x27;b10</span>:mem_read_data_s4&lt;=&#123;<span class="number">24&#x27;b0</span>,mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">23</span>:<span class="number">16</span>]&#125;;</span><br><span class="line">                            <span class="number">2&#x27;b11</span>:mem_read_data_s4&lt;=&#123;<span class="number">24&#x27;b0</span>,mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">31</span>:<span class="number">24</span>]&#125;;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// 16bits</span></span><br><span class="line">                    <span class="number">2&#x27;d2</span>:<span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(alu_out_s4[<span class="number">1</span>])</span><br><span class="line">                            <span class="number">1&#x27;b0</span>:mem_read_data_s4&lt;=&#123;<span class="number">16&#x27;b0</span>,mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                            <span class="number">1&#x27;b1</span>:mem_read_data_s4&lt;=&#123;<span class="number">16&#x27;b0</span>,mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]][<span class="number">31</span>:<span class="number">16</span>]&#125;;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>:mem_read_data_s4 &lt;= mem[alu_out_s4[<span class="number">31</span>:<span class="number">2</span>]];</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="🌟锁存模块"><a href="#🌟锁存模块" class="headerlink" title="🌟锁存模块"></a>🌟锁存模块</h3><p><img src="https://i.imgtg.com/2023/07/23/OhR9NN.png#id=orm29&originHeight=137&originWidth=170&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当处理器使用流水线时，相当于执行一条指令时，每完成一个步骤，数据经过一次锁存器（Latch），该模块所定义的接口如下所示：</p><table><thead><tr><th>Latches</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>序号</td><td>接口名</td><td>宽度</td><td>输入&#x2F;输出</td><td>作用</td></tr><tr><td>1</td><td>clk</td><td>1</td><td>输入</td><td>时钟信号</td></tr><tr><td>2</td><td>clear</td><td>1</td><td>输入</td><td>清零标志</td></tr><tr><td>3</td><td>hold</td><td>1</td><td>输入</td><td>等待标志</td></tr><tr><td>4</td><td>in</td><td>N</td><td>输入</td><td>输入</td></tr><tr><td>5</td><td>out</td><td>N</td><td>输出</td><td>输出</td></tr></tbody></table><p>其对应功能如下：<br>用来充当锁存器，起到缓存作用，比如exe和mem冲突时，在模块之间传递数据：当clear为0，将输出清零；当hold为1时，输出不变，hold为0时，输出等于输入。该模块主要代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(clear)</span><br><span class="line">            out &lt;= &#123;N&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hold)</span><br><span class="line">            out &lt;= out;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            out &lt;= in;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="🌟顶层模块"><a href="#🌟顶层模块" class="headerlink" title="🌟顶层模块"></a>🌟顶层模块</h3><p>顶层模块主要将取值、译码、执行、访存、写回这五个阶段进行串联，并解决数据冒险和控制冒险。</p><ul><li>五个阶段的串联<ul><li>第一阶段——对PC进行选择，并获取跳转PC的地址，获取所要进行的指令；</li><li>第二阶段——将第一阶段的数据传入第二阶段，对所得到的指令进行译码输出，若存在跳转指令，计算得到跳转的地址，并定义相应的控制信号；</li><li>第三阶段——将第二阶段的数据传入第三阶段，并进行相应的计算；</li><li>第四阶段——进行写入和读取操作；</li><li>第五阶段——写回寄存器，传递相应的数据。</li></ul></li><li>数据冒险<ul><li>数据冒险，流水线机制中，当一条指令的执行结果还没有写回寄存器而后面的指令要使用前者目标寄存器的值的时候，就会发生数据冒险。</li></ul></li><li><strong>数据前推</strong></li></ul><p>将计算结果从其产生处直接送到其他指令需要处或所有需要的功能单元处，避免流水线暂停，也叫做短接。<br>其主要代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((write_back_s4 == <span class="number">1&#x27;b1</span>) &amp;&amp; (rd_s4 == rs_control_s3)) <span class="keyword">begin</span></span><br><span class="line">            forward_a &lt;= <span class="number">2&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> ((write_back_s5 == <span class="number">1&#x27;b1</span>) &amp;&amp; (rd_s5 == rs_control_s3)) <span class="keyword">begin</span></span><br><span class="line">            forward_a &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">            forward_a &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((write_back_s4 == <span class="number">1&#x27;b1</span>) &amp; (rd_s4 == rt_control_s3)) <span class="keyword">begin</span></span><br><span class="line">            forward_b &lt;= <span class="number">2&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> ((write_back_s5 == <span class="number">1&#x27;b1</span>) &amp;&amp; (rd_s5 == rt_control_s3)) <span class="keyword">begin</span></span><br><span class="line">            forward_b &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">            forward_b &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>停等</strong></li></ul><p>当检测到相关时，在流水线中插入一些暂停周期。数据是访存MEM阶段完成后才产生，但是在这一周期下一条指令就需要作为数据使用，数据无法凭空产生，故此时靠转发解决不了问题。下一条指令暂停一个周期，就可以借助转发解决问题了。<br>其主要代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (mem_read_s3 == <span class="number">1&#x27;b1</span> &amp;&amp; ((rs_control_s2 == rd_s3) || (rt_control_s2 == rd_s3)) ) <span class="keyword">begin</span></span><br><span class="line">        hold &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">        hold &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">if</span>(hold) pcsource_s1 &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>控制冒险</strong></li></ul><p>在遇到条件分支指令时，由于跳转条件是否成立在执行阶段才知道，因此流水线就需要停顿或者冲刷指令才能正确运行。在我们所涉及的CPU中主要存在jump和branch两种跳转。<br>其主要核心代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// default</span></span><br><span class="line">    pcsource_s1 &lt;= <span class="number">2&#x27;b01</span>;</span><br><span class="line">    flush &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    baddr_s1 &lt;= baddr_s4;</span><br><span class="line">    jaddr_s1 &lt;= jaddr_s4;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">1&#x27;b1</span>)</span><br><span class="line">        is_branch_s4: <span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">if</span>(alu_out_s4==<span class="number">32&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                  pcsource_s1 &lt;= <span class="number">2&#x27;b10</span>;</span><br><span class="line">                  flush &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        is_jump_s4: <span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">case</span>(opcode_s4)</span><br><span class="line">                 <span class="number">6&#x27;d23</span>: jaddr_s1 &lt;= alu_out_s4;</span><br><span class="line">             <span class="keyword">endcase</span></span><br><span class="line">             pcsource_s1 &lt;= <span class="number">2&#x27;b11</span>;</span><br><span class="line">             flush &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="⛅实验过程与调试"><a href="#⛅实验过程与调试" class="headerlink" title="⛅实验过程与调试"></a>⛅实验过程与调试</h1><h2 id="🌞实验环境"><a href="#🌞实验环境" class="headerlink" title="🌞实验环境"></a>🌞实验环境</h2><h3 id="🌟硬件"><a href="#🌟硬件" class="headerlink" title="🌟硬件"></a>🌟硬件</h3><p><img src="https://i.imgtg.com/2023/07/23/OhR2uL.png#id=XoNCr&originHeight=455&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="🌟软件"><a href="#🌟软件" class="headerlink" title="🌟软件"></a>🌟软件</h3><p>Vivado 2019.2</p><h2 id="🌞测试"><a href="#🌞测试" class="headerlink" title="🌞测试"></a>🌞测试</h2><p>在完成带 5 级流水的 MIPS CPU 设计与实现后，下面通过实验对本设计所构建CPU进行样例测试与功能测试，样例测试是指检测CPU在运行指定程序时的输出与标准输出以及CPU各时序状态与预期是否一致。本设计所用MIPS测试程序在附录中给出。<br>本设计所构建CPU支持MIPS指令集的35条指令（具体所包含的指令上文已经详细描述，这里重复声明），接下来选择有代表性的指令进行波形测试。</p><h3 id="🌟流水线测试"><a href="#🌟流水线测试" class="headerlink" title="🌟流水线测试"></a>🌟流水线测试</h3><p>测试用例如下所示：<br><img src="https://i.imgtg.com/2023/07/23/OhRCvj.png#id=WsZd2&originHeight=487&originWidth=1014&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>通过进制转换脚本，生成对应的十六进制文件并进行测试。<br>流水线CPU就是指将一条分解为多步，在同一周期内进行多条指令的同时执行。MIPS五级流水线就是将指令分为：取指(IF)，译码(ID)，执行(EX)，访存(MEM)，写回(WB)五个阶段。举个例子：<br><img src="https://i.imgtg.com/2023/07/23/OhRwdp.md.png#id=ymz0i&originHeight=500&originWidth=842&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>第二条指令addi 2，0，5，可以看到在20-30ns的周期里，IF阶段取到08400005指令，30-40ns，这条指令到了ID阶段，而IF阶段执行下一条指令。40-50ns，执行这条指令，ALU的结果为0x00000005，正是指令执行结果，50-60ns由于addi指令不需要访存，60-70ns将结果写回寄存器。与此同时lb 2，3，1指令进行了访存，五段流水线如下所示：<br><img src="https://i.imgtg.com/2023/07/23/OhtOaU.md.png#id=FPPBj&originHeight=500&originWidth=842&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>可以发现当前CPU实现五段流水线，每个时钟上升沿进行下一个步骤。可以知道在执行这条指令的同时，其它的指令也在被执行。而流水线CPU和单周期CPU的区别就在这里。</p><h3 id="🌟数据前推"><a href="#🌟数据前推" class="headerlink" title="🌟数据前推"></a>🌟数据前推</h3><p>我们知道，指令只有在执行到EX阶段才会得出结果，结果到了MEM阶段才会写回寄存器，到了WB阶段才会写回内存，在流水线CPU中，往往会出现前面的指令还未执行完成将结果写回寄存器，后面的指令就需要读取该寄存器的值来进行执行，那就出现了相关现象。我们采取数据前推的方式来解决这一类问题。<br><img src="https://i.imgtg.com/2023/07/23/OhtaNY.md.png#id=xnMIc&originHeight=500&originWidth=842&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>对于ALU操作数A和B，两个数在指令运行到EX阶段才需要访问，有如下情况：<br>当MEM阶段指令是写回寄存器操作，且写回的寄存器不是0号寄存器，并且与EX阶段的指令所要访问的寄存器是同一个，则将MEM阶段的ALU运算结果进行转发。<br>举个例子：在刚才的测试用例中，如下图所示，就发生了数据相关。</p><blockquote><p>addi 3,0,6<br>sub 6,3,1</p></blockquote><p>addi指令要将$t0寄存器的值加上6存到$t3中，而sub指令要用$t3的值减去$t1的值放到$t6，所以$t3就出现了数据相关。由于在设计过程中解决了短链，通过数据前推，短接入上一指令，因而不会对结果产生影响，也不会使流水线暂停。</p><h3 id="🌟停等"><a href="#🌟停等" class="headerlink" title="🌟停等"></a>🌟停等</h3><p>测试用例如下所示：<br><img src="https://i.imgtg.com/2023/07/23/OhtoEv.png#id=EH22K&originHeight=257&originWidth=636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>如下图所示，立即数34存入寄存器3中，立即数7存入寄存器2中。<br><img src="https://i.imgtg.com/2023/07/23/OhtqIq.png#id=hz2YI&originHeight=108&originWidth=2174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>之后会将内存中的数据加载到 4号寄存器，读取数据之后在下一个时钟写入。<br><img src="https://i.imgtg.com/2023/07/23/OhtBFc.md.png#id=y051J&originHeight=500&originWidth=1304&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>之后应该写应该继续高电平，但是 80ns 之后为低电平，是因为从内存读取时，比较慢，故停等了一个时钟周期，在下一个时钟周期才能继续写入。<br><img src="https://i.imgtg.com/2023/07/23/OhtTRr.png#id=ZN2Eb&originHeight=216&originWidth=1714&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>因此完成了停等的操作。</p><h3 id="🌟J和B指令测试"><a href="#🌟J和B指令测试" class="headerlink" title="🌟J和B指令测试"></a>🌟J和B指令测试</h3><p>编写MIPS代码如下所示：<br><img src="https://i.imgtg.com/2023/07/23/OhtbUG.md.png#id=x8aEl&originHeight=500&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>同理，将其转化为16进制代码并进行测试仿真，得到如下所示的结果：<br><img src="https://i.imgtg.com/2023/07/23/OhtiE6.md.png#id=Sf85b&originHeight=500&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>观察查看 PC_source，可以看到确实选择器发生变化，且后续操作指令码变为0，实行跳转指令，并且和代码中的结果一样。<br>具体分析如下：<br>指令1：addi 3，0，23——将立即数23存入寄存器3中<br><img src="https://i.imgtg.com/2023/07/23/OhtxdI.png#id=iTDbA&originHeight=196&originWidth=1908&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令2：addi 2，0，3——将立即数3存入寄存器2中<br><img src="https://i.imgtg.com/2023/07/23/Ohtky1.png#id=yo2Cu&originHeight=255&originWidth=2130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令3：sub 1，3，2——将寄存器3中的数字减去寄存器2中的数字，并将其存入寄存器1中，即23-3&#x3D;20，此时寄存器1中的数字位0x14<br><img src="https://i.imgtg.com/2023/07/23/OhtFaD.png#id=FRj60&originHeight=339&originWidth=2043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令4：jr 1——发生跳转，pc&#x3D;0x14&#x3D;20，pc变成20跳过第5条指令<br><img src="https://i.imgtg.com/2023/07/23/OhtheF.md.png#id=JbPKq&originHeight=500&originWidth=1752&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令5被跳过，指令5：addi 4，0，55，可以发现寄存器4并没有发生变化，指令5被跳过<br><img src="https://i.imgtg.com/2023/07/23/OhtnIP.png#id=HvANq&originHeight=289&originWidth=2053&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令6：add 5，2， 3——寄存器2中的数字加寄存器3中的数字，并将其存入寄存器5中，即寄存器5中的数字为0x17+0x03&#x3D;0x1a<br><img src="https://i.imgtg.com/2023/07/23/Oht7hb.png#id=rgVtZ&originHeight=349&originWidth=2449&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令7：j 8——pc&#x3D;pc+4，跳过指令8<br>指令8：addi 5，0，1——将立即数1存入寄存器5中<br>指令9：addi 5，0，3——将立即数3存入寄存器5中<br>可以发现寄存器5中的数字为3，不为1，指令8被跳过，直接进行指令9<br><img src="https://i.imgtg.com/2023/07/23/OhtNRl.png#id=YzxUm&originHeight=299&originWidth=2327&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令10：blt 5，3，2——寄存器5中的数小于寄存器3中的数，进行跳转下面的第二条指令，即寄存器5中的数字3&lt;寄存器3中的数字0x17成立，则跳转到指令12<br>指令11：addi6，0，1<br>指令12：addi6，0，2<br>可以发现寄存器6中的数字为2，指令11被跳过<br><img src="https://i.imgtg.com/2023/07/23/Ohtejg.png#id=wtz1y&originHeight=365&originWidth=2259&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>指令13：bgt 6，3，16——寄存器6中的数小于寄存器3中的数，则不进行跳转，可以发现pcsource为1，没有进行跳转<br><img src="https://i.imgtg.com/2023/07/23/OhtAWB.png#id=aNYcJ&originHeight=174&originWidth=2211&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>由实验结果可知，当前测试用例的结果与实际相符合。<br>除此之外，我们也对其余指令进行了简单的测试，均符合实际。</p><h1 id="⛅下载到-FPGA-与分析"><a href="#⛅下载到-FPGA-与分析" class="headerlink" title="⛅下载到 FPGA 与分析"></a>⛅下载到 FPGA 与分析</h1><p>这一部分的难度我感觉应该是整个实验中最大的，因为没有任何的教程，所有需要的相关知识都需要我们自己去检索，所以光是研究怎么去下板就花费了我一两天的时间，至于后续成功下板过程中遇到的问题更是数不胜数，虽然在验收的时候，没有烧板成功，但是也有很多下载的心得，这里选有一定价值的部分做介绍。</p><h2 id="🌞下板步骤"><a href="#🌞下板步骤" class="headerlink" title="🌞下板步骤"></a>🌞下板步骤</h2><p>需要解释的是，我没有选择编写约束代码，而是通过可视交互的引脚<br>赋值来是实现的，具体步骤如下：</p><ul><li>运行 SYSTHESIS 下的 Run Synthesis，随后耐心等待即可</li></ul><p><img src="https://i.imgtg.com/2023/07/23/OhtZsK.png#height=72&id=yU2rn&originHeight=143&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=180"></p><ul><li>运行完后，我们选择 Open Synthesis Design 进行引脚分配</li></ul><p><img src="https://i.imgtg.com/2023/07/23/Ohtyoa.png#height=244&id=BlBkF&originHeight=487&originWidth=461&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=231"><br>在随后的 I&#x2F;O ports 界面为了能在 FPGA 上动态的显示，我们可以选择把 LED 灯的引脚分配给alu_out，为了与我们之前仿真波形和指令更好的进行比较和对应，由于指令都是 32 位，但是 FPGA 板上只有 16个 LED 灯，所以我们干脆就将 ins 的低 16 位对应显示在 16 个 LED 灯上，并且调整 I&#x2F;O Std 到 3.3v，对应第一部分对 FPGA 引脚的介绍，<br>最终的分配情况如下：<br><img src="https://i.imgtg.com/2023/07/23/OhtgeS.md.png#id=tzOOZ&originHeight=500&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>将RST按钮复用为时钟信号，也就是给CLK以RST的默认引脚P15，这样就能实现按一次FPGA板上的RST按钮，就运行一个时钟周期，大大方便我们做实验。<br>最后点击Generate Bitstream，进行下板，然后选择Open Hardware Manager。再选择Auto Connect，就已经成功下板了。</p><h2 id="🌞下板结果"><a href="#🌞下板结果" class="headerlink" title="🌞下板结果"></a>🌞下板结果</h2><p>在后续验收过后，多次尝试，发现可以进行烧板，简单的演示如下：<br><img src="https://i.imgtg.com/2023/07/23/OhtKys.png#height=95&id=KG36s&originHeight=190&originWidth=465&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=233"><br>第一个周期时钟未读<br><img src="https://i.imgtg.com/2023/07/23/OhtmGN.md.png#height=250&id=i0WPA&originHeight=500&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=392"><br>第二个周期，执行addi 1，0，2<br><img src="https://i.imgtg.com/2023/07/23/OhtpIC.md.png#height=250&id=uSB7R&originHeight=500&originWidth=834&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=417"><br>第三个周期执行addi 1，1，6<br><img src="https://i.imgtg.com/2023/07/23/OhtPhL.md.png#height=250&id=kFS8X&originHeight=500&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=384"></p><h1 id="⛅总结"><a href="#⛅总结" class="headerlink" title="⛅总结"></a>⛅总结</h1><p>在本次系统硬件综合设计中，我充分将所学到的理论知识与实践相结合起来。并基于Verilog硬件语言亲手制作了一个简单的CPU，真正的掌握了一个CPU设计的全部模块与步骤，对之前学过的很多知识有了更具象，更深刻的理解了，更具体的感悟都穿插在实验报告的每个部分里面，与实验内容是相结合的。<br>由于计算机设计的部件较多、结构原理较复杂，对于我们这样的初设计者来说感到无从下手，所以我们在整个过程中采取由浅入深，由简单到复杂的放法，通过这次设计，使我们能清楚的了解计算机的基本组成、基本原理和设计步骤、设计思路和调试步骤，为独立完成计算机设计奠定了基础。也是通过这次课程设计，使我学会了我的动手能力以及动脑能力的重要性，同时信心也增强了,在课程设计中通过自己动脑子解决遇到的问题，把书本上学到的知识应用到实践中去，这样也巩固和深化了自己的知识结构。<br>虽然在设计的过程中遇到了很多问题不是我自己能够独自解决的，但是通过同学和老师的帮助和指导使我遇到的问题得到清楚的解决，同时也让我学到在遇到问题时如何去解决所遇到的问题。<br>与此同时在与同学进行合作的过程中，我们也从一开始的茫然，不知道从何做起，到后来确定了我们的指令集，设计每一个模块并进行顶层串联，到后面的测试，越来越默契，也完成了本次课设所要求的要求。</p><h1 id="⛅参考文献"><a href="#⛅参考文献" class="headerlink" title="⛅参考文献"></a>⛅参考文献</h1><p>[1]雷思磊. 自己动手写CPU. 北京: 电子工业出版社，2014.<br>[2]唐朔飞. 计算机组成原理（第2版）[M]. 北京：高等教育出版社，2008.<br>[3]张晨曦，王志英等. 计算机体系结构（第2版）[M]. 北京：高等教育出版社<br>[4]王泽坤. MIPS架构CPU设计及SoC系统实现[D]. 沈阳：东北大学，2014.<br>[5]蔡晓燕，袁春风，张泽生. MIPS架构多周期CPU的设计[D]. 计算机教育：第17期：93-96，2014.</p><h1 id="⛅参考代码"><a href="#⛅参考代码" class="headerlink" title="⛅参考代码"></a>⛅参考代码</h1><p>本项目代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1-MIPS%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF">Cassie&#x2F;系统硬件综合设计-MIPS五级流水线 at main · xiayi0409&#x2F;Cassie</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
          <category> 系统硬件综合设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 系统硬件综合设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机类专业创新实践——家乡静态网页制作</title>
      <link href="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B8%93%E4%B8%9A%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%AE%B6%E4%B9%A1%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B8%93%E4%B8%9A%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%AE%B6%E4%B9%A1%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="🥑主要内容"><a href="#🥑主要内容" class="headerlink" title="🥑主要内容"></a>🥑主要内容</h1><h2 id="🍨内容设计"><a href="#🍨内容设计" class="headerlink" title="🍨内容设计"></a>🍨内容设计</h2><ol><li>设计主页面、城市介绍、美食介绍和网站作者四个界面以组成家乡美食介绍网页。</li><li>每个页面上方都配有导航栏，左边“苏州”按键和右边三个分页面的按钮。</li><li>主页面主要由标题、小标题和跳转按钮组成；</li><li>城市介绍页面主要由段落文字和视频组成；</li><li>美食介绍页面主要由六小段文字以及其对应图片和一个音乐播放功能键组成；</li><li>网站作者页面主要由头像图片以及其对应文字组成。</li></ol><h2 id="🍨功能设计"><a href="#🍨功能设计" class="headerlink" title="🍨功能设计"></a>🍨功能设计</h2><ol><li>导航栏由左侧“苏州”按钮——可实现跳转到主页面的动作，右侧三个按钮可实现对各页面之间的跳转。</li><li>主页面点击圆形按钮即可跳转至第一个分页面——城市介绍，同时也可通过导航栏右侧的三个按钮跳转至对应的页面；</li><li>城市页面——刚点进该页面时对左侧图片实现压缩弹跳功能，并在其右侧附加一段介绍文字；下方增加视频播放功能，链接至bilibili苏州介绍视频；最后一个板块实现该页面向外界网站如微博、百度、bilibili中有关苏州介绍的网址链接；</li><li>美食页面——由六个小方框构成，每个小方框都实现左图加文字的展现形式，并对图片加以弹跳动作；在导航栏中间添加视频播放按钮；</li><li>网站作者——由圆角框构成文字以及图片展示平台，并在刚点进该页面时对头像logo实现缩小放大跳跃功能。</li></ol><h1 id="🥑题目"><a href="#🥑题目" class="headerlink" title="🥑题目"></a>🥑题目</h1><p>前端页面设计（HTML CSS）——家乡风土习俗介绍等（在制作过程中主要侧重家乡美食）</p><h1 id="🥑需求分析与设计"><a href="#🥑需求分析与设计" class="headerlink" title="🥑需求分析与设计"></a>🥑需求分析与设计</h1><h2 id="🍨需求分析"><a href="#🍨需求分析" class="headerlink" title="🍨需求分析"></a>🍨需求分析</h2><h3 id="🍵内容分析"><a href="#🍵内容分析" class="headerlink" title="🍵内容分析"></a>🍵内容分析</h3><ol><li>应设计主页界面主要介绍本网页所介绍的城市，同时增加导入按钮增加美观性；</li><li>在每个网页的上方设置导航栏，点击即可跳转到相应的网页，使交互更加快捷；</li><li>增加网站作者网页，使网页整体化。</li></ol><h3 id="🍵功能分析"><a href="#🍵功能分析" class="headerlink" title="🍵功能分析"></a>🍵功能分析</h3><ol><li>应设置导航栏，点击即可跳转到相应的模块；</li><li>在城市介绍部分插入相关视频，使界面更生动，表达形式更丰富；</li><li>对页面上的图片可以设计抖动等行为，在页面适当增加音乐模块，使页面更生动；</li><li>整体界面应该简洁美观，便于观看。</li></ol><h2 id="🍨系统设计"><a href="#🍨系统设计" class="headerlink" title="🍨系统设计"></a>🍨系统设计</h2><h3 id="🍵内容设计"><a href="#🍵内容设计" class="headerlink" title="🍵内容设计"></a>🍵内容设计</h3><ol><li>设计主页面、城市介绍、美食介绍和网站作者四个界面以组成家乡美食介绍网页。</li><li>每个页面上方都配有导航栏，左边“苏州”按键和右边三个分页面的按钮。</li><li>主页面主要由标题、小标题和跳转按钮组成；</li><li>城市介绍页面主要由段落文字和视频组成；</li><li>美食介绍页面主要由六小段文字以及其对应图片和一个音乐播放功能键组成；</li><li>网站作者页面主要由头像图片以及其对应文字组成。</li></ol><h3 id="🍵功能设计"><a href="#🍵功能设计" class="headerlink" title="🍵功能设计"></a>🍵功能设计</h3><ol><li>导航栏由左侧“苏州”按钮——可实现跳转到主页面的动作，右侧三个按钮可实现对各页面之间的跳转。</li><li>主页面点击圆形按钮即可跳转至第一个分页面——城市介绍，同时也可通过导航栏右侧的三个按钮跳转至对应的页面；</li><li>城市页面——刚点进该页面时对左侧图片实现压缩弹跳功能，并在其右侧附加一段介绍文字；下方增加视频播放功能，链接至bilibili苏州介绍视频；最后一个板块实现该页面向外界网站如微博、百度、bilibili中有关苏州介绍的网址链接；</li><li>美食页面——由六个小方框构成，每个小方框都实现左图加又文字的展现形式，并对图片加以弹跳动作；在导航栏中间添加视频播放按钮；</li><li>网站作者——由圆角框构成文字以及图片展示平台，并在刚点进该页面时对头像logo实现缩小放大跳跃功能。</li></ol><h3 id="🍵代码设计"><a href="#🍵代码设计" class="headerlink" title="🍵代码设计"></a>🍵代码设计</h3><ol><li>HTML是用来在内容组织上告诉浏览器该如何显示其中的内容。</li><li>CSS是用来对内容样式美化展示上，负责HTML页面中元素的展现及排版。</li><li>JS使静态的HTML具有一定的交互行为动画特效等。</li></ol><h1 id="🥑系统实现与使用方法"><a href="#🥑系统实现与使用方法" class="headerlink" title="🥑系统实现与使用方法"></a>🥑系统实现与使用方法</h1><h2 id="🍨系统开发环境"><a href="#🍨系统开发环境" class="headerlink" title="🍨系统开发环境"></a>🍨系统开发环境</h2><h3 id="🍵处理器及设备"><a href="#🍵处理器及设备" class="headerlink" title="🍵处理器及设备"></a>🍵处理器及设备</h3><p><img src="https://s2.loli.net/2023/05/23/RuFmcfN4lBOvw3r.png#height=271&id=JtDJA&originHeight=542&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=552"></p><h3 id="🍵开发软件"><a href="#🍵开发软件" class="headerlink" title="🍵开发软件"></a>🍵开发软件</h3><p><img src="https://s2.loli.net/2023/05/23/4eLUWSZkhGRlPXo.png#height=185&id=wSInn&originHeight=369&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=474"></p><h2 id="🍨系统界面简介"><a href="#🍨系统界面简介" class="headerlink" title="🍨系统界面简介"></a>🍨系统界面简介</h2><p>主界面——由标题、小标题和跳转按钮和上方导航栏组成；<br><img src="https://s2.loli.net/2023/05/23/zco1P7S9pMVjvrX.png#height=609&id=N7YVr&originHeight=1217&originWidth=1816&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=908"><br>城市介绍界面——城市介绍页面主要分为三个部分；介绍、视频、网页链接；<br><img src="https://s2.loli.net/2023/05/23/JbGPtmj31RdZ2Is.png#height=1012&id=JMAot&originHeight=2023&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br>美食介绍界面——由六小段文字以及其对应图片和一个音乐播放功能键组成；<br><img src="https://s2.loli.net/2023/05/23/TO132nvUCJVHNoG.jpg#height=751&id=EFGij&originHeight=1500&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br>网站作者页面——由头像图片以及其对应文字组成。<br><img src="https://s2.loli.net/2023/05/23/JLg98X5nMA1yafZ.png#height=491&id=UVCNg&originHeight=982&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"></p><h2 id="🍨系统功能模块简介"><a href="#🍨系统功能模块简介" class="headerlink" title="🍨系统功能模块简介"></a>🍨系统功能模块简介</h2><ol><li>导航栏由左侧“苏州”按钮——可实现跳转到主页面的动作，右侧三个按钮可实现对各页面之间的跳转。</li><li>主页面点击圆形按钮即可跳转至第一个分页面——城市介绍，同时也可通过导航栏右侧的三个按钮跳转至对应的页面；</li><li>城市页面——刚点进该页面时对左侧图片实现压缩弹跳功能，并在其右侧附加一段介绍文字；下方增加视频播放功能，链接至bilibili苏州介绍视频；最后一个板块实现该页面向外界网站如微博、百度、bilibili中有关苏州介绍的网址链接；</li><li>美食页面——由六个小方框构成，每个小方框都实现左图加又文字的展现形式，并对图片加以弹跳动作；在导航栏中间添加视频播放按钮；</li><li>网站作者——由圆角框构成文字以及图片展示平台，并在刚点进该页面时对头像logo实现缩小放大跳跃功能。</li></ol><h2 id="🍨使用手册"><a href="#🍨使用手册" class="headerlink" title="🍨使用手册"></a>🍨使用手册</h2><p>通过“index.html”文件即可进入家乡主页，通过选择各个按钮即可实现页面之间的跳转，具体操作细则见功能模块介绍。</p><h1 id="🥑运行实例与系统功能测试"><a href="#🥑运行实例与系统功能测试" class="headerlink" title="🥑运行实例与系统功能测试"></a>🥑运行实例与系统功能测试</h1><h2 id="🍨系统功能测试"><a href="#🍨系统功能测试" class="headerlink" title="🍨系统功能测试"></a>🍨系统功能测试</h2><h2 id="🍨系统功能测试-1"><a href="#🍨系统功能测试-1" class="headerlink" title="🍨系统功能测试"></a>🍨系统功能测试</h2><h3 id="🍵"><a href="#🍵" class="headerlink" title="🍵****"></a>🍵**<meta name="viewport" content="width=device-width,initial-scale=1.0">**</h3><p>content属性值 :<br>width:可视区域的宽度，值可为数字或关键词device-width<br>height:同width<br>intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放<br>maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0;可视区域的缩放级别，<br>maximum-scale用户可将页面放大的程序，1.0将禁止用户放大到实际尺寸之上。<br>user-scalable:是否可对页面进行缩放，no 禁止缩放</p><h3 id="🍵导航栏功能介绍"><a href="#🍵导航栏功能介绍" class="headerlink" title="🍵导航栏功能介绍"></a>🍵导航栏功能介绍</h3><p><img src="https://s2.loli.net/2023/05/23/v7F2gAYmr8PJC6f.png#height=363&id=tzBaj&originHeight=726&originWidth=1722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=861"><br>导航栏总体——使用.navbar类来创建一个标准的导航栏，后面紧跟: .navbar -expand -xl | lg | md | sm类来创建响应式的导航栏 (大屏幕水平铺开，小屏幕垂直堆叠)。通过style改变导航栏颜色和高度，<div class="container">实现对导航栏的大小设置。<br>Logo跳转主页部分——“navbar-brand js-scroll-trigger”设置logo自适应导航栏，对链接最有效，将链接链接到图片上，并设置图片的大小。<br>要创建折叠导航栏，需要在按钮上添加navbar-toggler, data-toggle&#x3D;”collapse”与data-target&#x3D;”#id”，然后在设置了class&#x3D;”collapse navbar-collapse”类的div上包裹导航内容（链接），div元素上的id匹配按钮data-target的上指定的id。将导航栏项目放置在右侧，并设置通过class&#x3D;”nav-item nav-link js-scroll-trigger”设置不同的链接导航，相同的导航栏，插入和链接三个分页面。</p><h3 id="🍵主页面"><a href="#🍵主页面" class="headerlink" title="🍵主页面"></a>🍵主页面</h3><p><img src="https://s2.loli.net/2023/05/24/kn2GfNW6zSZPRtb.png#height=364&id=aLeuq&originHeight=728&originWidth=1958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=979"><br>设置块并在其中插入背景图片并实现左右居中，在上方加入文字并设置相应颜色和大小，通过<br>控制换行。与此同时通过调用bootstrap中的圆形按钮模块，并在其上链接城市介绍页面以用来实现页面之间的跳转。</p><h3 id="🍵城市介绍——介绍板块"><a href="#🍵城市介绍——介绍板块" class="headerlink" title="🍵城市介绍——介绍板块"></a>🍵城市介绍——介绍板块</h3><p><img src="https://s2.loli.net/2023/05/24/HDZTtKWoYemUXdM.png#height=369&id=KpjMc&originHeight=738&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br>设置块状元素并通过Bootstrap中的响应式栅格布局对将要存入的图片和文字进行位置的布局安排。插入图片并通过设置入场动画，即进入页面，就执行动画——要给需要执行动画的元素直接加上如rubberBand的动画对应的css。<br>同时继续添加块状元素添加文字以及改变其所在框的大小和文字颜色。</p><h3 id="🍵城市介绍——视频模块"><a href="#🍵城市介绍——视频模块" class="headerlink" title="🍵城市介绍——视频模块"></a>🍵城市介绍——视频模块</h3><p><img src="https://s2.loli.net/2023/05/24/oZ2lVNWxneLj4OT.png#height=231&id=pGaDS&originHeight=461&originWidth=1935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=968"><br>设置download块，同时设置视频与背景部分居中显示，作为将要存放视频的底部，设置大小和背景图片。在该底部上设置导入外部视频链接的框的大小，视频外链部分直接复制所要使用视频链接即可。</p><h3 id="🍵城市介绍——了解更多模块"><a href="#🍵城市介绍——了解更多模块" class="headerlink" title="🍵城市介绍——了解更多模块"></a>🍵城市介绍——了解更多模块</h3><p><img src="https://s2.loli.net/2023/05/24/Jf2P6mjguoCOVKl.png#height=458&id=UoHZi&originHeight=916&originWidth=1938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=969"><br>设置contract块作为外链块，与上面相同设置当前块内容居中。设置文本内容偏移量以确定在网页中的所在位置，通过添加相应logo标志和相应链接，完成向外链接的功能。</p><h3 id="🍵美食介绍"><a href="#🍵美食介绍" class="headerlink" title="🍵美食介绍"></a>🍵美食介绍</h3><p><img src="https://s2.loli.net/2023/05/24/mWn47p9tG1VZFoM.png#height=324&id=T4wa3&originHeight=647&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=910"><br>这一页面有了前两个页面的支持，整体实现较为简单，所实现的功能也很简单，主要通过col-sm-6 item定位每个小块的位置，在每个小块中再通过col-md-12 col-lg-5实现左图右文字的功能，其中<b><b/>用于设置文字的加粗，&amp;nbsp;实现空一个字符的距离。最后为了让界面看起来好看一点，所以在鼠标挪动到图片上时看，图片可以实现上下跳动，通过data-bs-hover-animate&#x3D;”bounce”调用即可。</p><h3 id="🍵网页作者"><a href="#🍵网页作者" class="headerlink" title="🍵网页作者"></a>🍵网页作者</h3><p><img src="https://s2.loli.net/2023/05/24/ZD62BhgptI4bzNs.png#height=427&id=FtYFY&originHeight=854&originWidth=1888&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=944"></p><h2 id="🍨运行实例"><a href="#🍨运行实例" class="headerlink" title="🍨运行实例"></a>🍨运行实例</h2><p>见前面运行界面截图</p><h1 id="🥑总结与进一步改进"><a href="#🥑总结与进一步改进" class="headerlink" title="🥑总结与进一步改进"></a>🥑总结与进一步改进</h1><h2 id="🍨总结（心得体会）"><a href="#🍨总结（心得体会）" class="headerlink" title="🍨总结（心得体会）"></a>🍨总结（心得体会）</h2><p>在高中的时候就有了解过网页，在上大学之前对网页这部分就较为感兴趣，所以也有有事没事去跟着视频和菜鸟教程学习有关前端的知识，所以这次在之前就对html和css有一定的了解的基础上，在学习的过程中看到了bootstrap，就想能不能使用它，正好学习一下相关的知识，但是由于基础掌握的不是太牢固，所以还是出了挺多问题，最后由于临近考试，花在这个作业上的时间也不算特别的多。<br>在编写的过程中基本就是想要实现什么功能就去菜鸟教程上查和找网上有没有相似的网站F12看他的代码，看看能不能套用他的模板，特别是在实现需要设置位置的时候，基本就是每改一次数字运行看一次，来一次次把图片或者框放在所想放的位置。特别是在写城市介绍的时候，对代码极为不熟悉，在写的时候用了很多的时间边写边查，后面几个页面相对就比较轻松了。<br>其次在编写的时候还有一大难点就是让界面看起来怎么好看之类的排版太难了，好多时候选一张图片就要选好久，虽然合理也运用空间，让自己的网页井然有序，留下合适空间这句话看起来挺简单，但实践起来就还是没有什么头绪，基本就是走一步看一步，先排起来，觉得这样排版有点丑就换排版，在制作界面的时候不只是代码，设计也是一个很大的学问。<br>总体来说，通过今对网页设计的学习，还是有很多的收获，通过大作业程序的编写也锻炼了我对界面中各种标签，图片的浮动操作的使用以及点击文字跳转到指定位置的代码运用的能力，让我对他们的实现有了更生动地体会。</p><h2 id="🍨进一步改进"><a href="#🍨进一步改进" class="headerlink" title="🍨进一步改进"></a>🍨进一步改进</h2><p>若后续还需要对当前网页进行改进，主要由以下几个方向进行：</p><ol><li>增加城市景点介绍页面（本来想做这一部分的，后面考试就来不及增加了；</li><li>界面部分文字和图片没有完全对其，由于空行等导致的没有对齐的问题也需要更完善；</li><li>导航栏在最后改进的时候只改进了其中一个界面的高度，导致后面颜色和高度有些不统一；</li><li>在编写的时候很多字体颜色、方框版式等虽然运用到了bootstrap中的东西，但对这一部分还不是了解的特别全面，后面还需要更多地学习。</li></ol><h1 id="🥑对课程设计的建议"><a href="#🥑对课程设计的建议" class="headerlink" title="🥑对课程设计的建议"></a>🥑对课程设计的建议</h1><p>线上上课的时候希望可以增加课程提醒和签到提醒，有一周不小心忘记这周有直播课程了，最后晚进去了，还有的时候中途会因为本来电脑听课后来想换到手机听课，电脑自己拿代码试一试，退出一会儿，实在是不知道有没有签上到。别的都挺好的，在高中的时候就学过网页，没想到到大学还能用上这些知识还是挺开心的。</p><h1 id="🥑源代码"><a href="#🥑源代码" class="headerlink" title="🥑源代码"></a>🥑源代码</h1><p>课程代码已开源至Github</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B8%93%E4%B8%9A%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5-%E5%AE%B6%E4%B9%A1%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C">Cassie&#x2F;计算机类专业创新实践-家乡静态网页制作 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
          <category> 创新实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 创新实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计——将WHILE语句转换成四元式的程序实现</title>
      <link href="/2022/06/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%B0%86WHILE%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%9B%E5%85%83%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/06/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%B0%86WHILE%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%9B%E5%85%83%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="💐设计目的及设计要求"><a href="#💐设计目的及设计要求" class="headerlink" title="💐设计目的及设计要求"></a>💐设计目的及设计要求</h1><h2 id="🌼设计内容"><a href="#🌼设计内容" class="headerlink" title="🌼设计内容"></a>🌼设计内容</h2><p>设计一个语法制导翻译器,将WHILE语句翻译成四元式。</p><h2 id="🌼要求"><a href="#🌼要求" class="headerlink" title="🌼要求"></a>🌼要求</h2><p>先确定一个定义WHILE语句的文法，为其设计一个语法分析程序,为每条产生式配备一个语义子程序,按照一遍扫描的语法制导翻译方法,实现翻译程序。对用户输入的任意一个正确的WHILE 语句,程序将其转换成四元式输出(可按一定格式输出到指定文件中)。</p><h1 id="💐开发环境描述"><a href="#💐开发环境描述" class="headerlink" title="💐开发环境描述"></a>💐开发环境描述</h1><h2 id="🌼开发工具"><a href="#🌼开发工具" class="headerlink" title="🌼开发工具"></a>🌼开发工具</h2><p>JAVA</p><h2 id="🌼开发环境"><a href="#🌼开发环境" class="headerlink" title="🌼开发环境"></a>🌼开发环境</h2><p><img src="https://s2.loli.net/2023/05/24/Jio9VcNSuTYpMAd.png#height=146&id=k8ahO&originHeight=292&originWidth=621&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=311"></p><h1 id="💐设计内容、主要算法描述"><a href="#💐设计内容、主要算法描述" class="headerlink" title="💐设计内容、主要算法描述"></a>💐设计内容、主要算法描述</h1><h2 id="🌼问题描述"><a href="#🌼问题描述" class="headerlink" title="🌼问题描述"></a>🌼问题描述</h2><p>根据题目要求，需要设计一个语法制导翻译器，将while语句翻译成四元式。</p><h2 id="🌼背景介绍"><a href="#🌼背景介绍" class="headerlink" title="🌼背景介绍"></a>🌼背景介绍</h2><h3 id="🌸文法介绍"><a href="#🌸文法介绍" class="headerlink" title="🌸文法介绍"></a>🌸文法介绍</h3><ol><li><strong>While语句的初始文法描述描述</strong></li></ol><p>while语句：A→w(P){B:}<br>赋值语句： B→g&#x3D;C<br>表达式：   C→CHD<br>项：       D→DIE<br>因子：     E→f | g | (C)<br>加法运算符：H→+|-<br>乘法运算符：I→*|&#x2F;<br>比较运算符：J→&lt; | &gt; | &gt;&#x3D; | &lt;&#x3D;<br>关系表达式：P→CJC<br>无符号整数：f<br>标识符：   g</p><ol start="2"><li><strong>改进为LL(1)文法之后的文法描述</strong></li></ol><p>while语句：A→w(P){B:}<br>赋值语句： B→g&#x3D;C<br>表达式：   C→DM<br>  M→HDM | ℇ<br>项：       D→EN<br>  N→IEN | ℇ<br>因子：     E→f | g | (C)<br>加法运算符：H→+|-<br>乘法运算符：I→*|&#x2F;<br>比较运算符：J→&lt; | &gt; | &gt;&#x3D; | &lt;&#x3D;<br>关系表达式：P→CJC<br>无符号整数：f<br>标识符：   g<br><strong>说明：</strong><br>以上文法中使用w代替while关键字，M和N分别是为了消除左递归引入的符号，无具体对应含义。</p><h3 id="🌸属性文法"><a href="#🌸属性文法" class="headerlink" title="🌸属性文法"></a>🌸属性文法</h3><ol><li>属性文法定义形式</li></ol><p>属性文法是在上下文无关文法的基础上，为每个文法符号（终结符或者非终结符）配备若干相关的“值”（与文法符号相关的属性）。<br>在一个属性文法中，对应于每个产生式A→a都有一套与之相关联的语义规则，每规则的形式为：b:&#x3D;f(c1,c2,…，ck)其中f是一个函数，而且或者b是A的一个综合属性并且c1,c2,…，ck是产生式右边文法符号的属性；或者非终结符既可有综合属性也可有继属性，文法开始符号的所有继承属性作为属性计算前的初始值。</p><ol start="2"><li>while语句的属性文法</li></ol><p>while语句：</p><ul><li>A→w {X1 &#x3D; gotostm} (P) {X2 &#x3D; gotostm}{B;} </li><li>{ backpatch(Ptruelist, M2gotostm);</li><li>backpatch(Pfalselist, tacIndex-1);</li><li>gen(‘J’,  ,  , X1);</li><li>gen( , , ,tacIndex);}</li></ul><p>赋值语句：</p><ul><li>B→g&#x3D;C{B.val&#x3D;C.val; gen(‘&#x3D;’,C.val, ,g.val);}</li></ul><p>表达式：</p><ul><li>C→D{M.i&#x3D;D.val}M{C.val&#x3D;M.s}</li><li>M→HD{ M1.i&#x3D;newtemp; gen(H.val,M.i,D.val, M1.i);}</li><li>M1{M.s&#x3D; M1.s}</li><li>M→ℇ{ M.s&#x3D; M.i}</li></ul><p>项：</p><ul><li>D→E{N.i&#x3D;E.val}N{D.val&#x3D;N.s}</li><li>N→IE{ N1.i&#x3D;newtemp; gen(I.val,N.i,D.val, N1.i);} N1{N.s&#x3D; N1.s}</li><li>N→ℇ{N.s&#x3D; N.i}</li></ul><p>因子：</p><ul><li>E→f{ E.val&#x3D; f.val}</li><li>E→g{ E.val&#x3D; g.val}</li><li>E→(C) { E.val&#x3D; C.val}</li></ul><p>加法运算符：</p><ul><li>H→+|-{H.val&#x3D;+ | H.val&#x3D;-;}</li></ul><p>乘法运算符：</p><ul><li>I→*|&#x2F;{I.val&#x3D;+ | I.val&#x3D;-;}</li></ul><p>比较运算符：</p><ul><li>J→&lt; | &gt; | &gt;&#x3D; | &lt;&#x3D;{J.val &#x3D; &gt; | J.val &#x3D;&lt; |J.val &#x3D; &lt;&#x3D; | J.val &#x3D; &gt;&#x3D;;}</li></ul><p>关系表达式：</p><ul><li>P→C1JC2{P.val&#x3D;newtemp;</li><li>gen(J.val, C1.val,C2.val,P.val);}</li></ul><p>无符号整数：</p><ul><li>f</li></ul><p>标识符：</p><ul><li>g</li></ul><p><strong>说明：</strong><br>上述属性文法中gen(op,arg1,arg2,result)生成四元式，newtemp产生一个未使用过的名字，val表示符号的值，f和g的值由输入时直接确定，tacIndex为生成四元式的标号。X1和X2是为了后续拉链回填添加的符号，无具体对应含义，backpatch(p,i)为拉链回填，将链表P中的每个元素指向i。</p><h3 id="🌸中间代码形成的描述"><a href="#🌸中间代码形成的描述" class="headerlink" title="🌸中间代码形成的描述"></a>🌸中间代码形成的描述</h3><p>四元式是一种比较普遍采用的中间代码形式。<br>它的一般形式为：(op,arg1,arg2,result)。其中， op为一个二元 (也可是一元或零元)运算符；arg1,arg2分别为它的两个运算 (或操作)对象，它们可以是变量、常数或系统定义的临时变量名；运算的结果将放入result中。运算对象和运算结果有时指用户自己定义的变量，有时指编译程序引进的临时变量。需要指出的是，每个四元式只能有一个运算符，所以，一个复杂的表达式须由多个四元式构成的序列来表示。例如，表达式A+B*C可写为序列</p><ol><li><ul><li>B C T1</li></ul></li><li><ul><li>A T1 T2</li></ul></li></ol><p>其中，T1，T2是编译系统所产生的临时变量名。当op为一元、零元运算符 (如无条件转移)时，arg2甚至arg1应缺省，即result∶&#x3D;op arg1或 op result ；对应的一般形式为： (op,arg1,,result)或 (op,,,result)<br>在实际产生的四元式中，op往往用一整型数表示 (操作符的代码)，它可能附带有不止一种属性。</p><h2 id="🌼解决方案"><a href="#🌼解决方案" class="headerlink" title="🌼解决方案"></a>🌼解决方案</h2><p>根据背景介绍的方法，可以将while语句转化为四元式。大致分为以下几个步骤：</p><ol><li>将while语句转换为四元式的第一步为对读入的表达式进行处理，即删除不必要的空格、回车、换行等，保证之后的步骤能够顺利进行。</li><li>通过词法分析判断语句中的每个字符的类型，如：常数、标识符、判断符、界符等。</li><li>分析while语句的文法并将其消除左递归和回溯。</li><li>在语法分析正确的情况下，通过语法分析的中间过程的符号栈输出四元式，四元式的形式为：（op   arg1   arg2   result）。</li></ol><h3 id="🌸程序模块分析"><a href="#🌸程序模块分析" class="headerlink" title="🌸程序模块分析"></a>🌸程序模块分析</h3><p>编译过程一般分为六个阶段的过程，可以由六个模块完成，它们称为词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、代码优化程序、目标代码生成程序，此外，一个完整编译程序还必须包括“表格管理程序”和“出错处理程序”。</p><h3 id="🌸使用的分析法"><a href="#🌸使用的分析法" class="headerlink" title="🌸使用的分析法"></a>🌸使用的分析法</h3><p>在对当前while语句进行语法分析的过程中，由于对自下而上的分析方法的掌握不是很熟练，因此最终决定采用的是递归下降分析法，但由于所用的while语句文法并不符合这一要求，所以要首先对文法进行修改，消除左递归，使得文法符合要求。</p><h3 id="🌸词法分析和语法分析"><a href="#🌸词法分析和语法分析" class="headerlink" title="🌸词法分析和语法分析"></a>🌸词法分析和语法分析</h3><p>这次实验涉及到词法分析、语法分析、语义分析及表格管理和出错管理。<br>其中，词法分析至少要能识别关键字“while”，标识符（即自定义变量），数字，运算符和界符等等；<br>语法分析要分析程序结构的合法性，即是否为文法的句子；<br>语义分析要能够语法制导翻译出中间代码四元式并将其输出；<br>表格管理是指符号表；<br>出错处理是指在语法分析时，所有非文法句子的错误类型处理。</p><h3 id="🌸语义分析和中间代码生成"><a href="#🌸语义分析和中间代码生成" class="headerlink" title="🌸语义分析和中间代码生成"></a>🌸语义分析和中间代码生成</h3><p>根据输入的语义动作进行语法制导翻译，当遇到语义动作的非终结符时，执行相应的语义动作，同时将产生的四元式输出并存储到相应的结构中，作为下一阶段四元式优化的输入部分。<br>对于while语句，由于进行了关系表达式的判断所以要进行语句的跳转，存在三处跳转：<br>第一，while语句的循环条件成立时，则跳转到循环体执行的第一条语句；第二，while语句的循环条件不成立时，则跳转到while语句的下一条语句；第三，循环体执行完毕时，则跳转到循环条件判断处，进行判断。对于跳转，采用拉链回填的方式进行处理。</p><h1 id="💐主要算法描述包括流程图"><a href="#💐主要算法描述包括流程图" class="headerlink" title="💐主要算法描述包括流程图"></a>💐主要算法描述包括流程图</h1><h2 id="🌼词法分析部分"><a href="#🌼词法分析部分" class="headerlink" title="🌼词法分析部分"></a>🌼词法分析部分</h2><p><img src="https://s2.loli.net/2023/05/24/gpaeH4qUfwDlW1C.png#height=327&id=V60DR&originHeight=653&originWidth=1353&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Lexer%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=677" alt="Lexer函数分析" title="Lexer函数分析"><br>Lexer.java主要作用为词法分析器，可以对当前输入源程序进行词法分析。主要过程如下：</p><ul><li>获取当前字符，若当前字母为英文则继续判断下一字符，直到不为英文或数字，则标记为标识符。</li><li>若当前字符为数字则继续判断下一字符直到不为数字，标记为常数。</li><li>若当前字符不为空，则根据字符判断当前为界符或分隔符或运算符。</li></ul><p><img src="https://s2.loli.net/2023/05/24/xlCDTZLhjgrdeyN.png#height=454&id=aIDIK&originHeight=907&originWidth=1379&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE&width=690" alt="词法分析流程图" title="词法分析流程图"></p><h2 id="🌼语法分析部分"><a href="#🌼语法分析部分" class="headerlink" title="🌼语法分析部分"></a>🌼语法分析部分</h2><p><img src="https://s2.loli.net/2023/05/24/F8Lj6ArstMXPB4w.png#height=440&id=Erxzw&originHeight=880&originWidth=1375&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Parsing%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=688" alt="Parsing函数分析" title="Parsing函数分析"><br>Parsing.java主要作用为语法分析器，可以对当前词法分析部分所标定的各个符号根据While语句的初始文法根据消除左递归后的文法进行相应的改进。<br>主要过程如下：</p><ul><li>前半部分首先对当前while句型进行正误判断，定义cut函数用于删去当前位置的值；首先判断while字符是否相等，其次根据while(){}来判断当前当前句型是否有{、}、(、)是否有缺失，若当前语句不为while句型，则输出错误语句，反之进入下一阶段。</li><li>后半部分为文法的改进，根据消除左递归的方法来对while语句文法进行改进，改进方式如下：<table><thead><tr><th>While语句初始文法描述</th><th>消除左递归后的文法描述</th></tr></thead><tbody><tr><td><img src="https://s2.loli.net/2023/05/24/A2L9DZ6CGp4eiKP.png#height=280&id=PVzK7&originHeight=558&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=277"></td><td><img src="https://s2.loli.net/2023/05/24/ZUqSMg8wHnsVLc4.png#height=335&id=f9eXw&originHeight=670&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=273"></td></tr></tbody></table></li></ul><h2 id="🌼定义四元式部分部分"><a href="#🌼定义四元式部分部分" class="headerlink" title="🌼定义四元式部分部分"></a>🌼定义四元式部分部分</h2><p><img src="https://s2.loli.net/2023/05/24/PRFopi6yvsLXQAx.png#height=418&id=h15qS&originHeight=835&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Quaternion%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=442" alt="Quaternion函数分析" title="Quaternion函数分析"><br>在这一部分对四元式进行定义，并设计相应的函数对四元式进行储存、获取以及输出。四元式定义如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quaternion</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String table;<span class="comment">//四元式表号，方面查找</span></span><br><span class="line">    <span class="keyword">private</span> String op;<span class="comment">//操作符</span></span><br><span class="line">    <span class="keyword">private</span> String arg1;<span class="comment">//运算对象1</span></span><br><span class="line">    <span class="keyword">private</span> String arg2;<span class="comment">//运算对象2</span></span><br><span class="line">    <span class="keyword">private</span> String result;<span class="comment">//运算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Quaternion存储四元式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Quaternion</span><span class="params">(String table,String op,String arg1,String arg2,String result)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.table = table;</span><br><span class="line">        <span class="built_in">this</span>.op = op;</span><br><span class="line">        <span class="built_in">this</span>.arg1 = arg1;</span><br><span class="line">        <span class="built_in">this</span>.arg2 = arg2;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🌼语义分析和四元式的生成"><a href="#🌼语义分析和四元式的生成" class="headerlink" title="🌼语义分析和四元式的生成"></a>🌼语义分析和四元式的生成</h2><p><img src="https://s2.loli.net/2023/05/24/zNvX1ubWHPdGwJc.png#height=461&id=oXxUJ&originHeight=922&originWidth=1369&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=ConstructQuaternion%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=685" alt="ConstructQuaternion函数分析" title="ConstructQuaternion函数分析"><br>首先将txt文件中的内容读取到字符串中，并对每一行的信息进行词法分析和语法分析，以便更好的进行递归下降法进行分析。<br>从while（后开始分析，若当前词语为常数或标识符则将当前词语入栈，、反之且当前操作码为空则将操作码入栈，若当前操作码不为空，则比较栈顶位置的操作符和当前所指的优先级进行比较，若当前操作符的优先级大于栈顶操作符，则生成四元式出栈，，反之则将其入栈。<br>当对while（）括号内的预计进行分析完后，将对{}中的语句进行分析，主要分析方法和上述相同，除此以外需要对最后一句四元式进行特殊处理。<br>对于生成四元式的流程图如下所示：<br><img src="https://s2.loli.net/2023/05/24/bmGMDL6PRBxs9zN.jpg#height=407&id=TJ7BW&originHeight=814&originWidth=1418&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=709"><br><img src="https://s2.loli.net/2023/05/24/CTz6Oq3JpEuM5fx.png#id=Mxwbj&originHeight=875&originWidth=1282&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=ConstructQuaternion%E6%B5%81%E7%A8%8B%E5%9B%BE" alt="ConstructQuaternion流程图" title="ConstructQuaternion流程图"></p><h2 id="🌼四元式的输出和图形界面"><a href="#🌼四元式的输出和图形界面" class="headerlink" title="🌼四元式的输出和图形界面"></a>🌼四元式的输出和图形界面</h2><p>这一部分较为简单，主要就是通过调用java的各个图形界面对while转为四元式的项目进行界面的设计，同时通过文件调用命令读取计算机中的txt文件，通过调用之前的函数，对txt中的源程序进行分析，将分析生成的四元式输出在图形界面中，同时在本项目中还生成了当前源程序中的词语和其对应的类型。<br>生成图形界面如下所示：<br><img src="https://s2.loli.net/2023/05/24/eJwDchCKmYnub67.png#height=295&id=mK67v&originHeight=589&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA&width=414" alt="图形界面展示" title="图形界面展示"></p><h1 id="💐设计的输入和输出形式"><a href="#💐设计的输入和输出形式" class="headerlink" title="💐设计的输入和输出形式"></a>💐设计的输入和输出形式</h1><h2 id="🌼输入"><a href="#🌼输入" class="headerlink" title="🌼输入"></a>🌼输入</h2><p>根据题目要求，本程序的输入均为语句或者表达式，由于每次测试程序均输入表达式，则会需要输入大量式子，浪费时间且同意出错。<br>因此本程序采用文件读入的形式，只需要选定在指定位置的文件即可。<br><img src="https://s2.loli.net/2023/05/24/uXO7cSyv2z5PRIf.png#height=109&id=S1NDa&originHeight=217&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=223"></p><h2 id="🌼输出"><a href="#🌼输出" class="headerlink" title="🌼输出"></a>🌼<strong>输出</strong></h2><p>根据题目的要求，针对输入的txt文件中的源文件，对其进行分析后输出词法分析得到的各个词语以及相应的类型，与此同时会输出对应的四元式。具体形式如下所示：<br><img src="https://s2.loli.net/2023/05/24/NaTMIvrVgEwOcnK.png#height=346&id=BLL9U&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></p><h1 id="💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）"><a href="#💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）" class="headerlink" title="💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）"></a>💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）</h1><p>为了更好的测试程序，在模拟测试阶段共定义了5个while语句。</p><table><thead><tr><th>输入的while语句</th><th>运行截图</th></tr></thead><tbody><tr><td><img src="https://s2.loli.net/2023/05/24/DUGO6EH41wAfQM3.png#height=121&id=BE9Wy&originHeight=241&originWidth=485&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=243"></td><td><img src="https://s2.loli.net/2023/05/24/8aOFQnfGU6ye921.png#height=346&id=FC69Q&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/LxMzbrvDfcSnmO3.png#id=BxqT1&originHeight=373&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td><td><img src="https://s2.loli.net/2023/05/24/VSvcOeHtiBClYXE.png#id=g7H3f&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td></tr><tr><td>While语句报错</td><td></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/mZYrFV96zJnAsgl.png#height=140&id=jGfhc&originHeight=279&originWidth=486&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=243"></td><td><img src="https://s2.loli.net/2023/05/24/2Fyb5Pw7gW6J4te.png#height=346&id=Koejy&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr><tr><td>无右括号报错</td><td></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/VwFpCPD4zUS8c3a.png#height=144&id=hYKjr&originHeight=287&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=237"></td><td><img src="https://s2.loli.net/2023/05/24/hcPi6sEwFfog9nS.png#height=346&id=ltgAp&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr><tr><td>多语句分析</td><td></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/K2nHCVUNOu4GLip.png#height=134&id=fLNxW&originHeight=267&originWidth=501&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=251"></td><td><img src="https://s2.loli.net/2023/05/24/ZNQKMv4iCdmegYW.png#height=346&id=BoIz7&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr></tbody></table><h1 id="💐总结（体会）"><a href="#💐总结（体会）" class="headerlink" title="💐总结（体会）"></a>💐总结（体会）</h1><p>编译过程一般分为六个阶段的过程，可以由六个模块完成，它们称为词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、代码优化程序、目标代码生成程序，此外，一个完整编译程序还必须包括“表格管理程序”和“出错处理程序”。<br>这次实验采用的方法对文法有一定的要求，要求文法必须是不为左递归和无回溯的文法，由于所用的while语句文法并不符合这一要求，所以要首先对文法进行修改，消除左递归。同时，这次实验涉及到词法分析、语法分析、语义分析及表格管理和出错管理。其中，词法分析至少要能识别关键字“while”，标识符（即自定义变量），数字，运算符和界符等等；语法分析要分析程序结构的合法性，即是否为文法的句子；语义分析要能够语法制导翻译出中间代码四元式并将其输出；表格管理是指符号表；出错处理是指在语法分析时，所有非文法句子的错误类型处理。<br>以下主要叙述我再编写程序过程中遇到的几个难点。</p><ol><li>在刚开始看到这个题目的时候首先想到的是通过while句型的翻译进行手动生成四元式，但手写完成while句型到四元式的转化与通过编程解决还是有一定的差距，由于在之前的学习中我对于递归下降的方法较为熟悉，因此试想能否通过该方法进行四元式的转化。因此我先对while的文法进行的书写，将各个部分通过字母代表的形式，进行了相应的转化，由于该while语句的文法不符合递归下降文法的要求，因此对此进行消除左递归。</li><li>在进行编程时，按照所学将整个文件分为词法分析、语法分析、语义分析和中间代码的生成，在词法分析阶段有了实验一的经验，整体编写过程还是非常通顺的，基本没有遇到问题。语法分析阶段主要根据所定义的while语句文法和相应转化后的文法进行转化，由于文法较为复杂，所定义的参数较多，因此编写过程中只要一不注意就会忘记自己到了那一部分，这一部分在最后运行过程中出现的问题还是比较多的，花了较长的时间来debug。在语义分析和四元式的生成部分，由于吸取了之前编写的经验，首先我先进行了流程图的绘制，对每一部分要进行的代码编写进行了分块和大概的伪代码处理，在这一基础上再进行代码的编写，由于对（）和{}中语句分四元式生成方法基本相同，因此除了对（）内的比较语句和{}最后语句语句的特殊处理，其余部分都只需要按照优先关系的比较进行相应的出栈和入栈操作即可。最后再通过图形界面进行输出即可，由于对于java的图形界面的学习较为少，因此这一次采取了对之前实验中设计的图形界面的改进的方法来进行生成。</li></ol><p>编写本次课程设计的感想是：<br>必需要理清正确的优先级顺序才可以编写程序；要创建好适当的结构体，合适的结构体会使程序的思路更加清晰。同时也要自己多加思考，寻找适合自己的编写代码方法来提高编写效率。<br>这次编译原理课程设计让我受益匪浅，不仅巩固了我平时在课堂上学到的知识，还为接下来的考试打下了坚实的基础。最后衷心的感谢老师们在实验过程中对我们的悉心指导，没有老师的耐心答疑我们很难这么顺利地完成课程设计。</p><h1 id="💐源程序清单"><a href="#💐源程序清单" class="headerlink" title="💐源程序清单"></a>💐源程序清单</h1><table><thead><tr><th>程序名称</th><th>作用</th></tr></thead><tbody><tr><td>Lexer.java</td><td>用于对输出源程序的词法分析</td></tr><tr><td>Prasing.java</td><td>用于对while句型能够进行语法分析</td></tr><tr><td>若不符合句型规则则发出相应报错</td><td></td></tr><tr><td>Quaternion.java</td><td>对四元式进行定义</td></tr><tr><td>ConstructQuaternion.java</td><td>用于进行语义分析和四元式的生成</td></tr><tr><td>Quat_GUI.java</td><td>设计GUI界面并对结果进行相应输出展示</td></tr></tbody></table><p>源程序代码已开源至GitHub</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%B0%86WHILE%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%9B%E5%85%83%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">Cassie&#x2F;编译原理课程设计-将WHILE语句转换成四元式的程序实现 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——单周期 CPU 设计与实现—十条指令 CPU</title>
      <link href="/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%81%E6%9D%A1%E6%8C%87%E4%BB%A4-CPU/"/>
      <url>/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%81%E6%9D%A1%E6%8C%87%E4%BB%A4-CPU/</url>
      
        <content type="html"><![CDATA[<h1 id="🍐设计要求"><a href="#🍐设计要求" class="headerlink" title="🍐设计要求"></a>🍐设计要求</h1><p>通过设计并实现支持 10 条指令的 CPU，进一步理解和掌握 CPU 设计的基本原理和过程。</p><h1 id="🍐方案设计"><a href="#🍐方案设计" class="headerlink" title="🍐方案设计"></a>🍐方案设计</h1><p>设计和实现一个支持如下十条指令的单周期 CPU。</p><ol><li>非访存指令</li></ol><ul><li>清除累加器指令 CLA</li><li>累加器取反指令 COM</li><li>算术右移一位指令 SHR：将累加器 ACC 中的数右移一位，结果放回 ACC</li><li>循环左移一位指令 CSL：对累加器中的数据进行操作</li><li>停机指令 STP</li></ul><ol start="2"><li>访存指令</li></ol><ul><li>加法指令 ADD X：[X] + [ACC] –〉ACC，X 为存储器地址，直接寻址</li><li>存数指令 STA X，采用直接寻址方式</li><li>取数指令 LDA X，采用直接寻址</li></ul><ol start="3"><li>转移类指令</li></ol><ul><li>无条件转移指令 JMP imm：signExt(imm) -&gt; PC</li><li>有条件转移（负则转）指令 BAN X：ACC 最高位为 1 则（PC）+ X -&gt; PC,否则 PC不变</li></ul><h2 id="🍑方案原理"><a href="#🍑方案原理" class="headerlink" title="🍑方案原理"></a>🍑方案原理</h2><p>单周期 CPU（Single Cycle Processor）是指一条指令在一个时钟周期内完成并开始下一条指令的执行。它是由数据通路及其控制部件两部分构成。因此，在设计该 CPU 是需要从这两方面入手：</p><ol><li>一是根据指令的功能和格式设计好数据通路并连接；</li><li>二是设计好控制部件。</li></ol><p>CPU 在处理指令时，一般需要经过以下几个步骤：</p><table><thead><tr><th><strong>步骤</strong></th><th><strong>行为</strong></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>取指令</strong> | CPU 根据 PC（程序计数器 - Program Counter）中的指令地址，在指令存储器中获取相应的指令，之后 PC的值会自动改变移动到下一条指令的地址 |<br>| <strong>指令译码</strong> | 对获取的指令进行分析，确定这个指令要完成什么操作，改变相应的控制信号 |<br>| <strong>指令执行</strong> | 相关组件获取控制信号，执行相应操作，并将结果反馈 |<br>| <strong>存储器访问</strong> | 如果指令设计读取、存储内存，则需要对存储器中相应地址进行读取或者写入 |<br>| <strong>结果写回</strong> | 将得到的数据（访问存储器或者修改其它寄存器的值获得）写回相应的寄存器 |</p><h2 id="🍑指令格式定义"><a href="#🍑指令格式定义" class="headerlink" title="🍑指令格式定义"></a>🍑指令格式定义</h2><p>本次实验设计的是一个 16 位的十指令单周期 CPU。</p><ol><li>非访存指令</li></ol><p>清除累加器指令 CLA­——0 —-&gt; ACC<br><img src="https://s2.loli.net/2023/05/26/WBwoi8AJSf1IMc2.png#height=30&id=ZN1qc&originHeight=59&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CLA%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=190" alt="CLA字段分配图" title="CLA字段分配图"><br>累加器取反指令 COM——~ACC→ACC<br><img src="https://s2.loli.net/2023/05/26/KYUNFdaGvzIMj5h.png#height=30&id=AKnpG&originHeight=60&originWidth=384&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=COM%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=192" alt="COM字段分配图" title="COM字段分配图"><br>算术右移一位指令 SHR：将累加器 ACC 中的数右移一位，结果放回 ACC<br><img src="https://s2.loli.net/2023/05/26/UfjGKFiNYgPaWXx.png#height=31&id=Bn5qs&originHeight=61&originWidth=391&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SHR%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=196" alt="SHR字段分配图" title="SHR字段分配图"><br>循环左移一位指令 CSL：对累加器中的数据进行操作<br><img src="https://s2.loli.net/2023/05/26/D3ifS8MBQEpdKou.png#height=31&id=ZWqzo&originHeight=62&originWidth=393&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CSL%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=197" alt="CSL字段分配图" title="CSL字段分配图"><br>停机指令 STP<br><img src="https://s2.loli.net/2023/05/26/NFcIhjGbRKAQJp2.png#height=31&id=aq3NF&originHeight=62&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=STP%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=197" alt="STP字段分配图" title="STP字段分配图"></p><ol start="2"><li>访存指令</li></ol><p>加法指令 ADD X：[X] + [ACC] –〉ACC，X 为存储器地址，直接寻址<br>M(X)→MDR(ACC)+MDR→ACC<br><img src="https://s2.loli.net/2023/05/26/JZEmdfsRtY5wFWb.png#height=31&id=kdwj9&originHeight=61&originWidth=390&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=ADD%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=195" alt="ADD字段分配图" title="ADD字段分配图"><br>存数指令 STA X，采用直接寻址方式<br>ACC→MDR MDR→M(X)<br><img src="https://s2.loli.net/2023/05/26/IWRgPz8S9lLQFpc.png#height=31&id=y5Mb2&originHeight=61&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=STA%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=199" alt="STA字段分配图" title="STA字段分配图"><br>取数指令 LDA X，采用直接寻址<br>M(X)→MDR  MDR→ACC<br><img src="https://s2.loli.net/2023/05/26/dt5lfzvmKP1UQcH.png#height=30&id=uZukf&originHeight=60&originWidth=395&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=LDA%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=198" alt="LDA字段分配图" title="LDA字段分配图"></p><ol start="3"><li>转移类指令</li></ol><p>无条件转移指令 JMP imm：signExt(imm) -&gt; PC<br><img src="https://s2.loli.net/2023/05/26/J4kulcr6MwnXy51.png#height=32&id=O5Esz&originHeight=63&originWidth=405&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=JMP%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=203" alt="JMP字段分配图" title="JMP字段分配图"><br>有条件转移（负则转）指令 BAN X: ACC 最高位为 1 则（PC）+ X -&gt; PC,否则 PC不变<br><img src="https://s2.loli.net/2023/05/26/V7LDlYxdIWXZBQn.png#height=31&id=udD08&originHeight=61&originWidth=401&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=BAN%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=201" alt="BAN字段分配图" title="BAN字段分配图"></p><h2 id="🍑数据通路设计"><a href="#🍑数据通路设计" class="headerlink" title="🍑数据通路设计"></a>🍑数据通路设计</h2><ul><li><strong>非访存指令</strong></li></ul><p>由上述分析可知，非访存指令的功能是对ACC中的值进行相应的操作以及变化，则可以得到大概的非访存指令数据通路图：<br><img src="https://s2.loli.net/2023/05/26/NzbXUtWm6uFVJnf.png#height=281&id=tH6Wc&originHeight=561&originWidth=1369&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E9%9D%9E%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%9B%BE&width=685" alt="非访存指令数据通路图" title="非访存指令数据通路图"></p><ul><li><strong>访存指令</strong></li></ul><p>根据上述分析可知，访存指令需要根据操作数中的地址码访问相应的存储单元。在直接寻址下，相对于非访存指令，多了一步从数据寄存器取数的过程，根据分析可以画出相对应的数据通路图：<br><img src="https://s2.loli.net/2023/05/26/cO2olnKHQPGVmIR.png#height=425&id=y9vo3&originHeight=849&originWidth=1368&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%9B%BE&width=684" alt="访存指令的数据通路图" title="访存指令的数据通路图"></p><ul><li><strong>转移类指令</strong></li></ul><p>无条件转移：将操作数中的立即数赋给 pc，由 pc 作为 addr 输出<br>有条件跳转：将 ACC 中的数据传入 ALU 进行判断，再根据判断结果传入pc，再由 pc 传出。</p><h2 id="🍑控制单元设计"><a href="#🍑控制单元设计" class="headerlink" title="🍑控制单元设计"></a>🍑控制单元设计</h2><p><img src="https://s2.loli.net/2023/05/26/HKthNxwv5JLiS8j.png#height=246&id=CIRji&originHeight=491&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8F%82%E8%80%83%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1%E5%9B%BE&width=517" alt="参考控制单元设计图" title="参考控制单元设计图"><br><img src="https://s2.loli.net/2023/05/26/1fmeGlH6yW5hijd.png#height=343&id=f7VmN&originHeight=685&originWidth=1436&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1%E5%9B%BE&width=718" alt="控制单元设计图" title="控制单元设计图"><br>根据上述指令功能和数据通路的设计可以得出相关的控制单元设计图，如上图所示。<br>ModelSim仿真所得的相应控制单元连线图如下所示：<br><img src="https://s2.loli.net/2023/05/26/uEGJfdmtSbjnyB9.png#height=221&id=RsL4n&originHeight=442&originWidth=1370&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=modelsim%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%BF%9E%E7%BA%BF%E5%9B%BE&width=685" alt="modelsim控制单元连线图" title="modelsim控制单元连线图"></p><h2 id="🍑控制单元设计-1"><a href="#🍑控制单元设计-1" class="headerlink" title="🍑控制单元设计"></a>🍑控制单元设计</h2><p>指令与操作码对应表如下所示：</p><table><thead><tr><th>指令</th><th>操作码</th><th>指令</th><th>操作码</th></tr></thead><tbody><tr><td>CAL</td><td>0000</td><td>CSL</td><td>0101</td></tr><tr><td>LDA</td><td>0001</td><td>STA</td><td>0110</td></tr><tr><td>ADD</td><td>0010</td><td>BAN</td><td>0111</td></tr><tr><td>COM</td><td>0011</td><td>JMP</td><td>1000</td></tr><tr><td>SHR</td><td>0100</td><td>STOP</td><td>1001</td></tr></tbody></table><h1 id="🍐实验步骤"><a href="#🍐实验步骤" class="headerlink" title="🍐实验步骤"></a>🍐实验步骤</h1><p>在第三部分通过对该 CPU 实现细节的分析、设计，并得到该 CPU 的原理图后，就可以依次实现各个模块，并进行仿真验证了。</p><h2 id="🍑CPU各模块Verilog实现"><a href="#🍑CPU各模块Verilog实现" class="headerlink" title="🍑CPU各模块Verilog实现"></a>🍑CPU各模块Verilog实现</h2><p>在前面实验中，已经分别设计和实现了 PC、指令存储器、寄存器组和 ALU，这里只给出各个模块的功能描述及其接口定义，具体实现可以直接使用或者调整前面试验的实现代码。</p><ul><li><strong>PC模块</strong></li></ul><p>PC模块功能描述如下所示：</p><p>| <strong>输入</strong> | 时钟信号 clk，复位信号 rst<br>有条件转移信号 wr，无条件转移信号</p><p>wr_none,停机信号 stop，输入 data_in |<br>| — | — |<br>| <strong>输出</strong> | 12 位指令地址 data_out |<br>| <strong>功能</strong> | 遇到复位指令清零，遇到停机指令停止，跳转指令按照设置写入，<br>其他正常情况 data_out&#x3D;data_out+1,即 pc&#x3D;pc+1 |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_pc(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> rst,<span class="comment">//复位信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr,<span class="comment">//有条件转移信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr_none,<span class="comment">//无条件转移信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> stop,<span class="comment">//停机信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">reg</span>[<span class="number">11</span>:<span class="number">0</span>] data_in,<span class="comment">//输入的12位跳转所加的数</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">11</span>:<span class="number">0</span>] data_out<span class="comment">//12位指令地址</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    data_out = <span class="number">0</span>; <span class="comment">//初始化data_out</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span> <span class="comment">//下降沿</span></span><br><span class="line">    <span class="keyword">if</span>(stop == <span class="number">1</span>) <span class="comment">//停机信号生效</span></span><br><span class="line">      data_out = data_out; <span class="comment">//即pc的值不变</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rst == <span class="number">1</span>) <span class="comment">//复位信号生效</span></span><br><span class="line">      data_out = <span class="number">0</span>; <span class="comment">//即pc的值变为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      data_out = data_out + <span class="number">1</span>; <span class="comment">//pc=pc+1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span><span class="comment">//上升沿</span></span><br><span class="line">    <span class="keyword">if</span>(wr == <span class="number">1</span>) <span class="comment">//有条件跳转信号生效</span></span><br><span class="line">      data_out = data_out + data_in;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(wr_none == <span class="number">1</span>)<span class="comment">//无条件跳转信号生效</span></span><br><span class="line">      data_out = <span class="number">12&#x27;b000000000011</span>;<span class="comment">//跳转至3指令</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>指令存储器模块</strong></li></ul><p>指令存储器模块功能描述如下所示：</p><table><thead><tr><th><strong>输入</strong></th><th>12 位指令地址 Addr</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>16 位指令码 Ins</td></tr><tr><td><strong>功能</strong></td><td>设置并存放待执行的指令，然后根据地址输出指令</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_imemory (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] Addr,<span class="comment">//12为指令地址</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Ins <span class="comment">//16位指令码</span></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] RAM[<span class="number">255</span>:<span class="number">0</span>]; <span class="comment">//设置数组</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        RAM[<span class="number">0</span>] = <span class="number">16&#x27;h0000</span>;<span class="comment">//清除累加器指令CLA</span></span><br><span class="line">        RAM[<span class="number">1</span>] = <span class="number">16&#x27;h1002</span>;<span class="comment">//取数指令LDA,直接寻址，取出地址为2的内存单元中的数</span></span><br><span class="line">        RAM[<span class="number">2</span>] = <span class="number">16&#x27;h2003</span>;<span class="comment">//加法指令ADD,直接寻址，与地址为3的数相加放入ACC中</span></span><br><span class="line">        RAM[<span class="number">3</span>] = <span class="number">16&#x27;h3000</span>;<span class="comment">//累加器取反指令COM</span></span><br><span class="line">        RAM[<span class="number">4</span>] = <span class="number">16&#x27;h4000</span>;<span class="comment">//算数右移一位指令SHR：将累加器ACC中的数右移一位，结果放回ACC</span></span><br><span class="line">        RAM[<span class="number">5</span>] = <span class="number">16&#x27;h5000</span>;<span class="comment">//循环左移一位指令CSL：对累加器中的数据进行操作</span></span><br><span class="line">        RAM[<span class="number">6</span>] = <span class="number">16&#x27;h6004</span>;<span class="comment">//存数指令STA，直接寻址,放入地址为4的内存单元</span></span><br><span class="line">        RAM[<span class="number">7</span>] = <span class="number">16&#x27;h7001</span>;<span class="comment">//有条件转移指令BAN</span></span><br><span class="line">        RAM[<span class="number">8</span>] = <span class="number">16&#x27;h8000</span>;<span class="comment">//无条件转移指令JMP,转移至第三条指令</span></span><br><span class="line">        RAM[<span class="number">9</span>] = <span class="number">16&#x27;h9000</span>;<span class="comment">//停机指令stop</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    Ins = RAM[Addr];</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>数据存储器模块</strong></li></ul><p>数据存储器模块功能描述如下所示：</p><p>| <strong>输入</strong> | 输入数据存储器写信号 wr_dmemory<br>12 位指令地址 Addr</p><p>16 位输入数据in_dmemory |<br>| — | — |<br>| <strong>输出</strong> | 16 位输出数据 out_dmemory |<br>| <strong>功能</strong> | 用于存放题目要求的数据，在加法等指令中使用 |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_dmemory(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr_dmemory,<span class="comment">//数据寄存器写信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] Addr,<span class="comment">//12为指令地址</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in_dmemory,<span class="comment">//16位输入数据</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_dmemory<span class="comment">//16位输出数据</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] regfile[<span class="number">12&#x27;b111111111111</span>:<span class="number">0</span>]; <span class="comment">//定义为一个数组</span></span><br><span class="line">  <span class="keyword">assign</span> out_dmemory = regfile[Addr];</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">      regfile[<span class="number">0</span>] = <span class="number">16&#x27;h0002</span>; </span><br><span class="line">      regfile[<span class="number">1</span>] = <span class="number">16&#x27;h4df8</span>;</span><br><span class="line">      regfile[<span class="number">2</span>] = <span class="number">16&#x27;h0003</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(wr_dmemory)</span><br><span class="line">     regfile[Addr] = in_dmemory;</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>ALU模块</strong></li></ul><p>ALU模块功能描述如下所示：</p><p>| <strong>输入</strong> | 操作数 in1,in2</p><p>操作选择信号 alu_op |<br>| — | — |<br>| <strong>输出</strong> | 运算结果输出 Z<br>有条件跳转指令的所加大小 ban_len |<br>| <strong>功能</strong> | 根据 alu_op 对 in1，in2 进行计算，并输出 Z |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_ALU(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in1,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in2,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] alu_op,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Z,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] ban_len</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Z=<span class="number">0</span>;</span><br><span class="line">    ban_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">always</span> @*<span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">case</span>(alu_op)</span><br><span class="line">      <span class="number">4&#x27;b0000</span>:Z = <span class="number">0</span>;<span class="comment">//CLA</span></span><br><span class="line">      <span class="number">4&#x27;b0011</span>:Z = ~in1;<span class="comment">//COM</span></span><br><span class="line">      <span class="number">4&#x27;b0100</span>:Z = in1[<span class="number">15</span>] == <span class="number">1</span>?&#123;<span class="number">1&#x27;b1</span>,in1[<span class="number">15</span>:<span class="number">1</span>]&#125;:&#123;<span class="number">1&#x27;b0</span>,in1[<span class="number">15</span>]&#125;;<span class="comment">//SHR </span></span><br><span class="line">      <span class="number">4&#x27;b0101</span>:Z = &#123;in1[<span class="number">14</span>:<span class="number">0</span>],in1[<span class="number">15</span>]&#125;;<span class="comment">//CSL</span></span><br><span class="line">      <span class="number">4&#x27;b0010</span>:Z = in1+in2;<span class="comment">//ADD</span></span><br><span class="line">      <span class="number">4&#x27;b0110</span>:Z = in1;<span class="comment">//STA</span></span><br><span class="line">      <span class="number">4&#x27;b0001</span>:Z = in2;<span class="comment">//LDA</span></span><br><span class="line">      <span class="number">4&#x27;b0111</span>:<span class="keyword">begin</span> <span class="comment">//BAN</span></span><br><span class="line">        <span class="keyword">if</span>(in1[<span class="number">15</span>] == <span class="number">1</span>)</span><br><span class="line">          ban_len = <span class="number">12&#x27;b000000000010</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ban_len = <span class="number">12&#x27;b000000000000</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="number">4&#x27;b1001</span>: ; <span class="comment">//stop</span></span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>CU控制单元模块</strong></li></ul><p>CU控制单元模块功能描述如下所示：</p><table><thead><tr><th><strong>输入</strong></th><th>指令操作码 opcode</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>wr_pc, wr_none_pc, wr_ACC, wr_dmemory, stop, cu_rst</td></tr><tr><td>操作选择信号alu_op</td><td></td></tr><tr><td><strong>功能</strong></td><td>根据每一条指令的功能，对读写信号进行控制，从而来完成指令的工作</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_CU(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] opcode,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> rst,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> wr_pc,wr_ACC,wr_dmemory,stop,wr_none_pc,cu_rst,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] alu_op</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    wr_pc = <span class="number">0</span>;</span><br><span class="line">    wr_ACC = <span class="number">0</span>;</span><br><span class="line">    wr_dmemory = <span class="number">0</span>;</span><br><span class="line">    stop = <span class="number">0</span>;</span><br><span class="line">    wr_none_pc = <span class="number">0</span>;</span><br><span class="line">    alu_op = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    cu_rst = rst;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//0000为CLA pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0000</span>) <span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">1</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0001为LDA pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0001</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0010为ADD pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0010</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0011为COM pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0011</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0011</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0100为SHR pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0100</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0100</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0101为CSL pc=0 acc=0 mdr=0 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0101</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0101</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0110为STA pc=0 acc=0 mdr=1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0110</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">0</span>;</span><br><span class="line">      wr_dmemory = <span class="number">1</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0110</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0111为BAN pc=1 acc=0 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0111</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">1</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//1000为JMP pc=1 acc=0 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b1000</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_none_pc=<span class="number">1</span>;</span><br><span class="line">      wr_ACC = <span class="number">0</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//1001为STOP pc=1 acc=0 mdr=0 stop=1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b1001</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">0</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//alu_op = 4&#x27;b1001;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>ACC模块</strong></li></ul><p>ACC模块功能描述如下所示：</p><p>| <strong>输入</strong> | 时钟信号 clk</p><p>ACC 写信号 wr_ACC，ACC 输入 in_ACC |<br>| — | — |<br>| <strong>输出</strong> | ACC 输出 out_ACC |<br>| <strong>功能</strong> | 将非访存指令的操作数暂时存放在累加器中 |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_ACC(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr_ACC,<span class="comment">//ACC写信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] in_ACC,<span class="comment">//ACC输入</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] out_ACC<span class="comment">//ACC输出</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] ACC; <span class="comment">//定义数组</span></span><br><span class="line">  <span class="keyword">assign</span> out_ACC = ACC; <span class="comment">//用assign对out_ACC赋值</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ACC = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(wr_ACC)</span><br><span class="line">      ACC = in_ACC;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🍑CPU顶层文件封装实现"><a href="#🍑CPU顶层文件封装实现" class="headerlink" title="🍑CPU顶层文件封装实现"></a>🍑CPU顶层文件封装实现</h2><p>通过根据以上定义的模块进行连接、封装就得到了目标 CPU，该 CPU 的输入为系统时钟信号 clk 和重置信号 reset。<br>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_CPU(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst<span class="comment">//复位信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> stop,pc_wr,ACC_wr,dmemory_wr,pc_wr_none;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] alu_op;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] Addr;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] pc_in;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] opcode,in1,in2,Z;</span><br><span class="line"></span><br><span class="line">five_pc pc(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.stop</span>(stop),</span><br><span class="line">    <span class="variable">.wr</span>(pc_wr),</span><br><span class="line">    <span class="variable">.data_in</span>(pc_in),</span><br><span class="line">    <span class="variable">.data_out</span>(Addr),</span><br><span class="line">    <span class="variable">.wr_none</span>(pc_wr_none)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_imemory imemory(</span><br><span class="line">    <span class="variable">.Addr</span>(Addr),</span><br><span class="line">    <span class="variable">.Ins</span>(opcode)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_dmemory dmemory(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.wr_dmemory</span>(dmemory_wr),</span><br><span class="line">    <span class="variable">.Addr</span>(Addr),</span><br><span class="line">    <span class="variable">.in_dmemory</span>(Z),</span><br><span class="line">    <span class="variable">.out_dmemory</span>(in2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_ACC acc(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.wr_ACC</span>(ACC_wr),</span><br><span class="line">    <span class="variable">.in_ACC</span>(Z),</span><br><span class="line">    <span class="variable">.out_ACC</span>(in1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_CU cu(</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.opcode</span>(opcode[<span class="number">15</span>:<span class="number">12</span>]),</span><br><span class="line">    <span class="variable">.stop</span>(stop),</span><br><span class="line">    <span class="variable">.wr_pc</span>(pc_wr),</span><br><span class="line">    <span class="variable">.wr_ACC</span>(ACC_wr),</span><br><span class="line">    <span class="variable">.wr_dmemory</span>(dmemory_wr),</span><br><span class="line">    <span class="variable">.alu_op</span>(alu_op),</span><br><span class="line">    <span class="variable">.wr_none_pc</span>(pc_wr_none),</span><br><span class="line">    <span class="variable">.cu_rst</span>(rst)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_ALU alu(</span><br><span class="line">    <span class="variable">.in1</span>(in1),</span><br><span class="line">    <span class="variable">.in2</span>(in2),</span><br><span class="line">    <span class="variable">.alu_op</span>(alu_op),</span><br><span class="line">    <span class="variable">.Z</span>(Z),</span><br><span class="line">    <span class="variable">.ban_len</span>(pc_in)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🍑CPU模拟仿真"><a href="#🍑CPU模拟仿真" class="headerlink" title="🍑CPU模拟仿真"></a>🍑CPU模拟仿真</h2><p>为了仿真验证所实现的 CPU，需要定义测试文件并在测试文件中对指令存储器和寄存器堆中的相应寄存器的值进行初始化，并通过仿真波形图查看是否指令得到了正确执行。</p><ul><li><strong>TestBench关键代码：</strong><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_CPU_tb();</span><br><span class="line">  <span class="keyword">reg</span> clk,rst;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      clk=<span class="number">1</span>;</span><br><span class="line">      rst=<span class="number">1</span>;</span><br><span class="line">      #<span class="number">1</span> rst=<span class="number">0</span>;</span><br><span class="line">      #<span class="number">20</span> <span class="built_in">$stop</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">1</span> clk=~clk;</span><br><span class="line"></span><br><span class="line">  five_CPU uut(</span><br><span class="line">      <span class="variable">.clk</span>(clk),</span><br><span class="line">      <span class="variable">.rst</span>(rst)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="🍐实验步骤-1"><a href="#🍐实验步骤-1" class="headerlink" title="🍐实验步骤"></a>🍐实验步骤</h1><ol><li><strong>建立 ModelSim 工程</strong></li></ol><p>打开 ModelSim，选择 File-&gt;New-&gt;Project，出现 Create Project 对话框，填写工程名（Project Name），选择保存目录（Project Location），注意保存目录中不要有中文。<br><img src="https://s2.loli.net/2023/05/26/zhlUjRsEAHtQZVW.png#height=138&id=bRXkF&originHeight=276&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>单击 OK 按钮后，现在可以选 Create New File（新建文件）或者 Add Existing File（添加已存在文件）。这里我们选择 Add Existing File，也就是添加上述所描述的 Verilog 代码。<br>点击 Browse 按钮，添加上述描述的文件。<br>选择要添加的文件后，单击“打开”按钮，即添加完成，在其中选择 copy to project directory，这样就会将 cu.v等文件复制到新的工程目录下，单击OK 按钮。<br>文件添加完成后，ModelSim 主界面会显示所有文件的状态。选中任意一个文件，右键单击，选择 Compile-&gt;Compile All，即开始编辑所有文件。没有出错，文件状态应该都是绿色的对号，否则点击屏幕下方的 Transcript，查看出错信息，直至无误。</p><ol start="2"><li><strong>开始仿真</strong></li></ol><p>切换到 Library，然后展开 work 目录，在 spu_tb.v 文件上单击右键，在弹出菜单中选择 Simulate （without Optimization）。<br>此时会出现一个名为 sim 的界面，展开其中的spu_tb 节点，选择 uut，会在 Objects 窗口显示所有信号：（若没有出现 Objects 窗口，可以通过菜单 View-&gt;Objects调出该窗口）<br>选择 Objects 窗口的所有信号（Ctrl+A），然后单击右键，在弹出菜单中选择 Add to-&gt;Wave-&gt;Selected Signals。<br>单击工具栏中的 Run-All 按钮，便开始仿真，可以得到仿真效果图<br>结束后，请在 Transcript 中输入 quit –sim 命令退出。</p><h1 id="🍐故障与调试"><a href="#🍐故障与调试" class="headerlink" title="🍐故障与调试"></a>🍐故障与调试</h1><h2 id="🍑代码编写问题1"><a href="#🍑代码编写问题1" class="headerlink" title="🍑代码编写问题1"></a>🍑代码编写问题1</h2><p><strong>故障现象：</strong><br>由于本次实验中实验指导书给的提示很少，刚开始接触的时候虽然后实验四的基础，但还是有一点无从下手，所以网上查阅了较多的资料。<br><strong>解决方案：</strong><br>网上查阅了较多资料以及通过学习别人的代码，在实验四的基础上对实验五进行编写，不断尝试下完成本次实验代码的编写。</p><h2 id="🍑实验故障1"><a href="#🍑实验故障1" class="headerlink" title="🍑实验故障1"></a>🍑实验故障1</h2><p><strong>故障现象：</strong><br>只要用到include，编译就出错，爆出Cannot open &#96;include file *.v<br><strong>原因分析：</strong><br>文件调用出现错误。<br><strong>解决方案：</strong><br>将编译文件放在同一个文件夹中，并编译时要在文件区中进行。</p><h2 id="🍑实验故障2"><a href="#🍑实验故障2" class="headerlink" title="🍑实验故障2"></a>🍑实验故障2</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/26/pXoc5mn36GAzkNy.png#height=363&id=nUMDq&originHeight=725&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=465"><br><strong>原因分析：</strong><br>代码中的编码格式系统无法识别.<br><strong>解决方案：</strong><br>所以参考的代码需要手动输入，而且多半问题出在空格和换行符&#x2F;t上，可以利用文本编辑器统一替换。</p><h2 id="🍑实验故障3"><a href="#🍑实验故障3" class="headerlink" title="🍑实验故障3"></a>🍑实验故障3</h2><p>还出现了很多在实验四中遇到过的问题，这里不做过多赘述。</p><h1 id="🍐仿真及分析"><a href="#🍐仿真及分析" class="headerlink" title="🍐仿真及分析"></a>🍐仿真及分析</h1><p>整体模拟波形图如下所示：<br><img src="https://s2.loli.net/2023/05/26/8hd7jpr1gIi5yqS.png#height=353&id=KVQPb&originHeight=705&originWidth=2369&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1185"></p><h2 id="🍑清除累加器CLA指令"><a href="#🍑清除累加器CLA指令" class="headerlink" title="🍑清除累加器CLA指令"></a>🍑清除累加器CLA指令</h2><p>清除累加器CLA指令波形如下所示：</p><p><img src="https://s2.loli.net/2023/05/26/eobWu1kCx9Q58jv.png#height=154&id=kVRYy&originHeight=308&originWidth=606&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>分析：累加器清零指令，即 ACC 清零。in1 操作数表示着 ACC 中的值，可以发现为 0。所以清零成功。</p><h2 id="🍑取数指令LDA"><a href="#🍑取数指令LDA" class="headerlink" title="🍑取数指令LDA"></a>🍑取数指令LDA</h2><p>取数指令 LDA波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/KqiP2CXp8n7ReLv.png#height=133&id=ZKQYx&originHeight=266&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=512"><br>分析：取数指令 LDA：取出地址为 2 的内存单元中的数。<br>该 CPU 中，设置每下降沿 pc 自动加 1，这里变为12’h001，进入取数指令。在数据存储器 dmemory 中，第二内存单元的数设置的是：16’h4df8，即 0100101111111000。又因为在该CPU 中，操作数 in2 可表示 dmemory 中输出的数，z 也输出该数，所以取数成功。</p><h2 id="🍑加法指令ADD"><a href="#🍑加法指令ADD" class="headerlink" title="🍑加法指令ADD"></a>🍑加法指令ADD</h2><p>加法指令ADD波形入下所示：<br><img src="https://s2.loli.net/2023/05/26/rqwvuUlxSA8a6md.png#height=324&id=ehYFs&originHeight=648&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=519"><br>分析：加法指令 ADD。直接寻址，与地址 3 的数相加存入 ACC 中。<br>因为下降沿自动加 1，Addr 至12’h002，所以进入加法指令。首先将上一条指令取出的数，暂存到 ACC 中，可以通过波形看到ACC_wr 为 1，此时 in1变成了所取出的数。Dmemory 中直接寻址到地址为 3 的数，可以通过 in2 验证。相加之后，放入 ACC 中，由于设置的是上升沿写入 ACC  所以在下一个上升沿时，in1 为做加法之后的数，为16’h4dfb。所以，加法指令成功。</p><h2 id="🍑累加器取反指令COM"><a href="#🍑累加器取反指令COM" class="headerlink" title="🍑累加器取反指令COM"></a>🍑累加器取反指令COM</h2><p>累加器取反指令COM波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/3P5c26LnMKqrSQs.png#height=331&id=gQtzg&originHeight=662&originWidth=1040&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=520"><br>分析：累加器取反指令 COM。<br>因为下降沿自动加 1，Addr 至 12’h003，所以进入取反指令。将上一条指令加完的数放入 ACC 中，通过 in1 可以看到。然后对其进行取反操作，变为16’hb204。下一次上升沿写入 ACC，通过 in1 可以看出。所以，取反成功。</p><h2 id="🍑算术右移一位指令SHR"><a href="#🍑算术右移一位指令SHR" class="headerlink" title="🍑算术右移一位指令SHR"></a>🍑算术右移一位指令SHR</h2><p>算术右移一位指令SHR波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/tZIQArTJBc3o8SF.png#height=333&id=uW6ze&originHeight=665&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=418"><br>分析：算术右移一位指令 SHR，将累加器 ACC 中的数右移一位，结果放回 ACC。下降沿自动加 1，Addr 至12’h004，所以进入算术右移指令。In1 右移过后，再存入 ACC，此时 in1 表示的是右移过后的数。由图可以看出，in1 由16’hb204 变为16’hd902，算术右移成功。</p><h2 id="🍑循环左移一位指令CSL"><a href="#🍑循环左移一位指令CSL" class="headerlink" title="🍑循环左移一位指令CSL"></a>🍑循环左移一位指令CSL</h2><p>循环左移一位指令CSL波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/QDU8AFVBIReEys5.png#height=337&id=Z8so1&originHeight=673&originWidth=1054&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=527"><br>分析：循环左移一位指令 CSL，对累加器中的数据进行操作。<br>下降沿自动加 1，Addr 至12’h005，所以进入算术右移指令。In1 循环左移过后，再存入 ACC，此时 in1 表示的是左移过后的数。由图可以看出，in1由16’hd902 变为16’hb205，循环左移成功成功。</p><h2 id="🍑存数指令STA"><a href="#🍑存数指令STA" class="headerlink" title="🍑存数指令STA"></a>🍑存数指令STA</h2><p>存数指令STA波形如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1685101420918-dd17468f-eb3c-4118-9d37-8657105b0d60.png#averageHue=%23424140&clientId=ud353abc6-2561-4&height=329&id=bXkq2&originHeight=658&originWidth=1051&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60727&status=done&style=none&taskId=u7561dbe6-83c7-4de3-a9ec-2f8c61e6edd&title=&width=526" alt="image.png"><br>分析：存数指令 STA：直接寻址，放入地址为 4 的内存单元<br>下降沿自动加 1，Addr 至12’h006，所以进入存数指令。由于本指令不需要进行写入 ACC 的操作，所以 ACC_wr 变为 0，因为要存数，所以写入数据存储器的信号 dmemory_wr 变为 1  在下一个上升沿时，写入 dmemory，此时由 in2可以看出，存入成功。</p><h2 id="🍑有条件跳转指令-无条件跳转指令"><a href="#🍑有条件跳转指令-无条件跳转指令" class="headerlink" title="🍑有条件跳转指令\无条件跳转指令"></a>🍑有条件跳转指令\无条件跳转指令</h2><p>有条件跳转指令\无条件跳转指令波形如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1685101409357-13d044e3-59c5-4c48-8725-a9e520ddfb0b.png#averageHue=%233c3b3a&clientId=ud353abc6-2561-4&height=353&id=KBeHW&originHeight=705&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74664&status=done&style=none&taskId=u7c7cbbad-7a7e-4e39-a5e4-6d05a78f7d7&title=&width=735" alt="image.png"><br>分析：有条件跳转指令：负则转。无条件跳转指令。<br>下降沿自动加 1，Addr 至12’h007，进入有条件跳转指令，在该 CPU中，我设置其跳转是 pc&#x3D;pc+1 是为了跳转至下一条无条件跳转指令，这样方便同时验证这两条指令的正确性。通过波形发现，此时有条件跳转信号 pc_wr 变为 1，ACC 中的数为负，所以发生跳转，在下一个上升沿时，pc+1，进入下一条指令，为无条件跳转。在本 cpu 中，我设置无条件跳转至第三条指令，取反指令，根据波形，可以得出有条件跳转和无条件跳转都能成功运行。</p><h2 id="🍑停机指令stop"><a href="#🍑停机指令stop" class="headerlink" title="🍑停机指令stop"></a>🍑停机指令stop</h2><p>停机指令stop波形如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1685101395234-b9e7a1e2-9a78-40e7-88c3-925ce036145b.png#averageHue=%233c3b3a&clientId=ud353abc6-2561-4&height=342&id=BBdBB&originHeight=683&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64889&status=done&style=none&taskId=uce77ff7a-45ca-4e1d-b178-5d206ee9821&title=&width=626" alt="image.png"><br>分析：停机指令 stop<br>由于为了验证上述两条跳转指令，该 cpu 无法自动进入 stop 指令。我为了验证停机指令，将有条件跳转指令中的 pc+1 改成 pc+2，跳转至停机指令。<br>跳转至停机指令，由 stop 信号变为 1 以及后面不运行可以看出。</p><h1 id="🍐总结与心得"><a href="#🍐总结与心得" class="headerlink" title="🍐总结与心得"></a>🍐总结与心得</h1><h2 id="🍑实验总结"><a href="#🍑实验总结" class="headerlink" title="🍑实验总结"></a>🍑实验总结</h2><p>本次实验主要完成了如下几点工作：<br><strong>实验四</strong></p><ol><li>完成方案总结——实验四完成了单周期 CPU 设计与实现——单指令 CPU，实验要求为通过设计并实现支持一条指令的 CPU，基本理解和掌握了 CPU 设计的基本原理和过程，根据实验内容设计和实现了一个支持加法指令的单周期 CPU。</li><li>功能总结——该实验所设计的单周期CPU可以实现加法指令要求该加法指令（表示为 add r1，r2，r3）格式约定如下：采用寄存器寻址，r1，r2，r3 为寄存器编号，r1 和 r2 存放两个源操作数，r3为目标寄存器，其功能为[r1] + [r2] -&gt; r3。</li></ol><p><strong>实验五</strong></p><ol><li>完成方案总结——实验五完成了为通过设计并实现支持 10 条指令的 CPU，进一步理解和掌握了 CPU 设计的基本原理和过程，根据实验内容设计和实现一个支持如下十条指令的单周期 CPU。</li><li>功能总结——该实验所设计的单周期CPU可以实现非访存指令、访存指令和转移类指令共10种指令。指令如下：</li></ol><ul><li><strong>非访存指令</strong><ul><li>清除累加器指令 CLA</li><li>累加器取反指令 COM</li><li>算术右移一位指令 SHR：将累加器 ACC 中的数右移一位，结果放回 ACC</li><li>循环左移一位指令 CSL：对累加器中的数据进行操作</li><li>停机指令 STP</li></ul></li><li><strong>访存指令</strong><ul><li>加法指令 ADD X：[X] + [ACC] –〉ACC，X 为存储器地址，直接寻址</li><li>存数指令 STA X，采用直接寻址方式</li><li>取数指令 LDA X，采用直接寻址</li></ul></li><li><strong>转移类指令</strong><ul><li>无条件转移指令 JMP imm：signExt(imm) -&gt; PC</li><li>有条件转移（负则转）指令 BAN X: ACC 最高位为 1 则（PC）+ X -&gt; PC,否则 PC不变</li></ul></li></ul><h2 id="🍑实验心得"><a href="#🍑实验心得" class="headerlink" title="🍑实验心得"></a>🍑实验心得</h2><ol><li>通过实验我知道了单周期 CPU 是指所有指令均在一个时钟周期内完成的 CPU。CPU 由数据通路及其控制部件两部分构成，因而要完成一个支持若干条指令 CPU 的设计，需要依次完成以下两件事：<ol><li>根据指令功能和格式设计 CPU 的数据通路；</li><li>根据指令功能和数据通路设计控制部件。</li></ol></li><li>通过本次实验，我对运算器，存储器以及输入输出的个各个系统内部结构有了更为深刻的了解，同时也增加了我对于计算机组成原理的更为深层次的理解，除此以外此次实验还增加了我对于Verilog语言的理解，锻炼了我对于verilog代码编写和使用的能力，初步掌握了对modelsim的使用，锻炼了我的实验动手能力。</li><li>通过本次实验，我认为，设计一个 CPU 要从这几个方面考虑：<ol><li>首先要确定 CPU 的指令条数、功能，根据指令的类型设计指令格式。</li><li>然后确定该 CPU 是单周期还是多周期。</li><li>接着，根据指令的具体功能设计 CPU 的数据通路，并设计数据通路上的各部件及其控制部件，确定他们的输入输出和功能。</li><li>最后，进行整体封装，再编写测试文件进行测试。然后通过 modelsim 进行波形仿真，验真是否能够实现功能。</li></ol></li><li>总之，这次 cpu 的实验，让我收获颇丰。加深了对计算机组成原理知识的印象，对cpu 的结构更加熟悉，对今后知识进一步的拓展打下基础。</li><li>对于实验的建议，刚开始为了分享实验我是直接做的实验四，就觉得和我自己的水平相差太大了，感觉完全无从下手，后来把实验一二三都看了一遍发现实验四是对于前三个的总结，后来我就将实验一二三都根据实验报告实现了一遍，在进行实验四五的时候，就顺手了很多。总的来说，这次实验还是让我收获了很多的，在通过听取别的同学的实验分享和我分享的时候丁老师对于我的指导也让我收获很多，虽然计组实验期间挺忙的，但是还是觉得很有意义的。</li></ol><h1 id="🍐参考文献"><a href="#🍐参考文献" class="headerlink" title="🍐参考文献"></a>🍐参考文献</h1><p>[1]DAVID A.PATTERSON(美).计算机组成与设计硬件&#x2F;软件接口(原书第5版).北京:机械工业出版社.<br>[2]David Money Harris(美).数字设计和计算机体系结构（第二版）. 机械工业出版社<br>[3]谭志虎,秦磊华,胡迪青.计算机组成原理实践教程.北京:清华大学出版社，2018年.<br>[4]秦磊华，吴非，莫正坤.计算机组成原理. 北京:清华大学出版社，2011年.<br>[5]袁春风编著. 计算机组成与系统结构. 北京:清华大学出版社，2011年.<br>[6]张晨曦，王志英. 计算机系统结构. 高等教育出版社，2008年.</p><h1 id="🍐程序代码"><a href="#🍐程序代码" class="headerlink" title="🍐程序代码"></a>🍐程序代码</h1><p>代码已开源至Github</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0">Cassie&#x2F;计算机组成原理-单周期CPU设计与实现 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程作业 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程作业 </tag>
            
            <tag> 计算机组成原理实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——单周期 CPU 设计与实现—单指令 CPU</title>
      <link href="/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%95%E6%8C%87%E4%BB%A4-CPU/"/>
      <url>/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%95%E6%8C%87%E4%BB%A4-CPU/</url>
      
        <content type="html"><![CDATA[<h1 id="🍀设计要求"><a href="#🍀设计要求" class="headerlink" title="🍀设计要求"></a>🍀设计要求</h1><p>通过设计并实现支持一条指令的 CPU，理解和掌握 CPU 设计的基本原理和过程。</p><h1 id="🍀方案设计"><a href="#🍀方案设计" class="headerlink" title="🍀方案设计"></a>🍀方案设计</h1><p>设计和实现一个支持加法指令的单周期 CPU。要求该加法指令（表示为 add r1，r2，r3）格式约定如下：</p><ul><li>采用寄存器寻址，r1，r2，r3 为寄存器编号，r1 和 r2 存放两个源操作数，r3为目标寄存器，其功能为[r1] + [r2] -&gt; r3；</li><li>指令字长 16 位，操作码和地址码字段分配如下所示：</li></ul><p><img src="https://s2.loli.net/2023/05/25/mS3bMvoN9H2jeOq.jpg#height=82&id=OImn5&originHeight=163&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=489"></p><h2 id="🌵方案原理"><a href="#🌵方案原理" class="headerlink" title="🌵方案原理"></a>🌵方案原理</h2><p>单周期 CPU 是指所有指令均在一个时钟周期内完成的 CPU。CPU 由数据通路及其控制部件两部分构成，因而要完成一个支持若干条指令 CPU 的设计，需要依次完成以下两件事：</p><ul><li>根据指令功能和格式设计 CPU 的数据通路；</li><li>根据指令功能和数据通路设计控制部件。</li></ul><h2 id="🌵根据功能和格式完成CPU的数据通路设计"><a href="#🌵根据功能和格式完成CPU的数据通路设计" class="headerlink" title="🌵根据功能和格式完成CPU的数据通路设计"></a>🌵根据功能和格式完成CPU的数据通路设计</h2><p>实验需要设计的 CPU 只需要支持一条加法指令，而该指令的功能是在一个时钟周期内从寄存器组中 r1 和 r2 中取出两个操作数，然后送到 ALU 进行加法运算，最后把计算结果保存到 r1 寄存器中。下图给出了改加法指令的数据通路图。<br>此外，还需要确定各个部件的位数，为了简单起见，我们假设目标 CPU 的机器字长、存储字长和指令字长相等均为 16 位，存储单元个数假设为 256，按字寻址，并取 PC 位数为 8。<br><img src="https://s2.loli.net/2023/05/25/r5mwPOS6ACGZs8I.png#height=124&id=YW8mH&originHeight=248&originWidth=491&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4%20add%20r1%2Cr2%2Cr3%20%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF&width=246" alt="加法指令 add r1,r2,r3 数据通路" title="加法指令 add r1,r2,r3 数据通路"></p><h2 id="🌵根据指令功能、数据通路完成控制单元的设计"><a href="#🌵根据指令功能、数据通路完成控制单元的设计" class="headerlink" title="🌵根据指令功能、数据通路完成控制单元的设计"></a>🌵根据指令功能、数据通路完成控制单元的设计</h2><p>控制单元的功能是为当前要执行的指令产生微操作命令从而完成该指令的执行。为了能够完成加法指令的执行，结合上图，控制单元需要在取出指令后根据指令操作码（本例中是加法指令），控制 ALU（参考实验二）做加法（通过给 alu_op 信号线相应赋值），并把结果写回寄存器组（参考实验三）中（通过给 wr_en 赋值为 true）。下图给出了整合控制单元后目标 CPU 的原理图，系统时钟信号也已标注。<br><img src="https://s2.loli.net/2023/05/25/6XjMvkQCg2cLxtr.png#height=218&id=Vzg2O&originHeight=435&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8D%95%E6%8C%87%E4%BB%A4%20CPU%20%E5%8E%9F%E7%90%86%E5%9B%BE&width=269" alt="单指令 CPU 原理图" title="单指令 CPU 原理图"></p><h1 id="🍀编程步骤"><a href="#🍀编程步骤" class="headerlink" title="🍀编程步骤"></a>🍀编程步骤</h1><p>在第三部分通过对该 CPU 实现细节的分析、设计，并得到该 CPU 的原理图后，就可以依次实现各个模块，并进行仿真验证了。</p><h2 id="🌵CPU各模块Verilog实现"><a href="#🌵CPU各模块Verilog实现" class="headerlink" title="🌵CPU各模块Verilog实现"></a>🌵CPU各模块Verilog实现</h2><p>在前面实验中，已经分别设计和实现了 PC、指令存储器、寄存器组和ALU，这里只给出各个模块的功能描述及其接口定义，具体实现可以直接使用或者调整前面试验的实现代码。</p><h3 id="🌾PC模块"><a href="#🌾PC模块" class="headerlink" title="🌾PC模块"></a>🌾PC模块</h3><p>PC 模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>时钟信号 clk、重置信号 rst</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>指令地址 pc（8 位）</td></tr><tr><td><strong>功能</strong></td><td>每个时钟上升沿 PC 的值自动加 1，并输出</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Pc(</span><br><span class="line">  <span class="comment">//输入的两个信号input c1k，input rst,</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] pc</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="number">1</span>)</span><br><span class="line">      pc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pc = pc + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span><span class="comment">//时钟上升沿触发</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾指令存储模块"><a href="#🌾指令存储模块" class="headerlink" title="🌾指令存储模块"></a>🌾指令存储模块</h3><p>指令存储器模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>8 位指令地址 Addr</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>16 位指令 Ins</td></tr><tr><td><strong>功能</strong></td><td>存放待执行的指令（初始化），并根据地址输出指令</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ins_unit(</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Ins,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] Addr</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">integer</span> i,j;</span><br><span class="line">  <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] unit[<span class="number">255</span>:<span class="number">0</span>];<span class="comment">//256个16位存储单元</span></span><br><span class="line">  initia1 <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i = i + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">      j= i % <span class="number">6</span>;</span><br><span class="line">      unit[i][<span class="number">2</span>:<span class="number">0</span>] = j;</span><br><span class="line">      unit[i][<span class="number">5</span>:<span class="number">3</span>] = j + <span class="number">1</span>;</span><br><span class="line">      unit[i][<span class="number">8</span>:<span class="number">6</span>] = j + <span class="number">2</span>;</span><br><span class="line">      unit[i][<span class="number">15</span>:<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span> <span class="comment">//任何时钟改变均会进入</span></span><br><span class="line">    Ins = unit[Addr] ;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾寄存器堆"><a href="#🌾寄存器堆" class="headerlink" title="🌾寄存器堆"></a>🌾寄存器堆</h3><p>寄存器堆模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>时钟信号 clk、读写控制线 wr_en、读寄存器编号 read_reg1 和read_reg2、写寄存器编号write_reg、写入数据 write_data</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>对应两个读寄存器编号的寄存器值 reg1 和 reg2</td></tr><tr><td><strong>功能</strong></td><td>根据读寄存器编号给出对应寄存器的值；在写允许情况下，把写入端的数据在 clk 下降沿写到写寄存器编号对应的寄存器</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> reg_stk(</span><br><span class="line">  <span class="keyword">input</span> clk，wr_en,<span class="comment">//wr_en读写信号为1时写入(上升沿有效）为0时，读数据input [15:o] write_data,</span></span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] read_reg1,read_reg2,write_reg,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] reg1,reg2</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] unit[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">integer</span> i;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span>(i = o;i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">      unit[i] = i;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span> (/任何时钟改变均会进入</span><br><span class="line">    reg1 = unit[read_reg1];</span><br><span class="line">    reg2 = unit[read_reg2];</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span> <span class="comment">//时钟下降沿触发</span></span><br><span class="line">    <span class="keyword">if</span>(wr_en == <span class="number">1</span>)</span><br><span class="line">      unit[write_reg] = write_data;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾ALU"><a href="#🌾ALU" class="headerlink" title="🌾ALU"></a>🌾ALU</h3><p>ALU模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>指令（操作码）</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>寄存器堆的读写控制线 wr_en、ALU 的操作选择信号alu_op</td></tr><tr><td><strong>功能</strong></td><td>根据当前指令功能对 wr_en 和 alu_op 赋值</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] in1,in2,inputalu_op,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(alu_op==<span class="number">0</span>)</span><br><span class="line">      result = in1+in2 ;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾CU"><a href="#🌾CU" class="headerlink" title="🌾CU"></a>🌾CU</h3><p>CU模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>操作数 in1 和 in2、操作选择信号 alu_op</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>ALU 运算结果 Z</td></tr><tr><td><strong>功能</strong></td><td>根据操作选择信号计算 in1 和 in2 的运算结果 Z</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cu(</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">6</span>:<span class="number">0</span>] Ins_op,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> wr_en,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> alu_op</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span>/任何时钟信号都引起</span><br><span class="line">    <span class="keyword">if</span>(Ins_op == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      wr_en = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      alu_op = <span class="number">0</span>;<span class="comment">//设置ALu的操作码对应为加</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🌵CPU顶层文件封装实现"><a href="#🌵CPU顶层文件封装实现" class="headerlink" title="🌵CPU顶层文件封装实现"></a>🌵CPU顶层文件封装实现</h2><p>通过根据单指令CPU原理图将以上定义的模块进行连接、封装就得到了目标 CPU，该 CPU 的输入为系统时钟信号 clk 和重置信号 reset。<br>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">modu1e cpu(</span><br><span class="line">  <span class="keyword">input</span> c1k，rst,</span><br><span class="line">  <span class="keyword">output</span> test</span><br><span class="line">);</span><br><span class="line"><span class="keyword">wire</span> wr;</span><br><span class="line"><span class="keyword">wire</span> alu_op;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] result, ins,r1,r2;</span><br><span class="line"></span><br><span class="line">pc pc(</span><br><span class="line">  <span class="variable">.c1k</span>(c1k),<span class="variable">.rst</span>(rst),<span class="variable">.pc</span>(addr)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ins_unit ins_unit(</span><br><span class="line">  <span class="variable">.Addr</span>(addr)，<span class="variable">.Ins</span>(ins)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">cu cu(</span><br><span class="line">  <span class="variable">.Ins_op</span>(ins[<span class="number">15</span>:<span class="number">9</span>])，</span><br><span class="line">  <span class="variable">.wr_en</span>(wr),<span class="variable">.alu_op</span>(alu_op)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg_sta reg_sta(</span><br><span class="line">  <span class="variable">.clk</span>(clk),<span class="variable">.wr_en</span>(wr) ,</span><br><span class="line">  <span class="variable">.read_reg1</span>(ins[<span class="number">8</span>:<span class="number">6</span>]),<span class="variable">.read_reg2</span>(ins[<span class="number">5</span>:<span class="number">3</span>]),<span class="variable">.write_reg</span>(ins[<span class="number">2</span>:<span class="number">0</span>]),<span class="variable">.write_data</span>(result),<span class="variable">.reg1</span>(r1),<span class="variable">.reg2</span>(r2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alu alu(</span><br><span class="line">  <span class="variable">.in1</span>(r1),<span class="variable">.in2</span>(r2),</span><br><span class="line">  <span class="variable">.alu_op</span>(alu_op),<span class="variable">.result</span>(result)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🌵CPU模拟仿真"><a href="#🌵CPU模拟仿真" class="headerlink" title="🌵CPU模拟仿真"></a>🌵CPU模拟仿真</h2><p>为了仿真验证所实现的 CPU，需要定义测试文件并在测试文件中对指令存储器和寄存器堆中的相应寄存器的值进行初始化，并通过仿真波形图查看是否指令得到了正确执行。</p><h3 id="🌾TestBench关键代码"><a href="#🌾TestBench关键代码" class="headerlink" title="🌾TestBench关键代码"></a>🌾TestBench关键代码</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cpu_sim;</span><br><span class="line">  <span class="keyword">reg</span> c1lk，rst;</span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> c1k = ~c1k ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1</span>;</span><br><span class="line">    rst = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">10</span> rst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  cpu uut(</span><br><span class="line">    <span class="variable">.c1k</span>(c1k)，<span class="variable">.rst</span>(rst)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1 id="🍀实验步骤"><a href="#🍀实验步骤" class="headerlink" title="🍀实验步骤"></a>🍀实验步骤</h1><h2 id="🌵建立ModelSim工程"><a href="#🌵建立ModelSim工程" class="headerlink" title="🌵建立ModelSim工程"></a>🌵建立ModelSim工程</h2><p>打开 ModelSim，选择 File-&gt;New-&gt;Project，出现 Create Project 对话框，填写工程名（Project Name）， 选择保存目录（Project Location），注意保存目录中不要有中文，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/Ag9NqwOsMbUyveP.png#height=122&id=lsuZX&originHeight=244&originWidth=272&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=136"><br>单击OK按钮后，会出现下图界面：<br><img src="https://s2.loli.net/2023/05/25/zq9JlKshfkynAUr.png#height=212&id=jRVPz&originHeight=424&originWidth=491&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=246"><br>现在可以选 Create New File（新建文件）或者 Add Existing File（添加已存在文件）。这里我们选择 Add Existing File，也就是添加上述所描述的 Verilog 代码，会出现下图界面：<br><img src="https://s2.loli.net/2023/05/25/WpmyjrFGzvcaOl1.png#height=138&id=K9S4c&originHeight=276&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>点击 Browse 按钮，添加上述描述的文件，会出现下图界面：<br><img src="https://s2.loli.net/2023/05/25/4MeYIKGqHls9orh.png#height=275&id=sghiU&originHeight=550&originWidth=1399&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=700"><br>选择要添加的文件后，单击“打开”按钮，即添加完成，会出现类似下图界面，在其中选择 copy to project directory，这样就会将 cu.v等文件复制到新的工程目录下，单击OK 按钮。<br><img src="https://s2.loli.net/2023/05/25/iyPUB2VqsRDj4ZJ.png#height=138&id=E5K4X&originHeight=275&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>文件添加完成后，ModelSim 主界面会显示所有文件的状态。选中任意一个文件，右键单击，选择 Compile-&gt;Compile All，即开始编辑所有文件，会出现下图界面。没有出错，文件状态应该都是绿色的对号，否则点击屏幕下方的 Transcript，查看出错信息，直至无误。<br><img src="https://s2.loli.net/2023/05/25/rCcAokGsZYxbdRO.png#height=161&id=PpKDL&originHeight=321&originWidth=802&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=401"></p><h2 id="🌵开始仿真"><a href="#🌵开始仿真" class="headerlink" title="🌵开始仿真"></a>🌵开始仿真</h2><p>切换到 Library，然后展开 work 目录，在 spu_sim.v 文件上单击右键，在弹出菜单中选择 Simulate （without Optimization），如下图界面：<br><img src="https://s2.loli.net/2023/05/25/fSAB6ElCK19xbcn.png#height=148&id=a96gc&originHeight=296&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=422"><br>此时会出现一个名为 sim 的界面，展开其中的spu_sim 节点，选择 uut，会在 Objects 窗口显示所有信号，如下图所示：（若没有出现 Objects 窗口，可以通过菜单 View-&gt;Objects调出该窗口）<br><img src="https://s2.loli.net/2023/05/25/4F85vkuCVOoZ6Wx.png#height=161&id=Eyki1&originHeight=321&originWidth=1235&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=618"><br>选择 Objects 窗口的所有信号（Ctrl+A），然后单击右键，在弹出菜单中选择 Add to-&gt;Wave-&gt;Selected Signals，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/dZtkp7JqmXR18Os.png#height=246&id=mTXtd&originHeight=492&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=616"><br>单击工具栏中的 Run-All 按钮，便开始仿真，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/VR3hZtT8QeDrz7l.png#height=50&id=pAF7j&originHeight=100&originWidth=237&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=119"><br>仿真效果图，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/l7N8pT4KiLkomHD.png#height=358&id=cv0zA&originHeight=716&originWidth=2019&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1010"><br>结束后，请在 Transcript 中输入 quit –sim 命令退出，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/1EDCicwyG7bT24B.png#height=84&id=tLdJA&originHeight=167&originWidth=831&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=416"></p><h1 id="🍀故障与调试"><a href="#🍀故障与调试" class="headerlink" title="🍀故障与调试"></a>🍀故障与调试</h1><h2 id="🌵安装故障1"><a href="#🌵安装故障1" class="headerlink" title="🌵安装故障1"></a>🌵安装故障1</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/Qd3Mxi75NYj96Fg.png#height=104&id=fzCJu&originHeight=207&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=226"><br><strong>原因分析：</strong></p><ol><li>在安装过程中一定要通过命令窗口运行该文件，不然下载出的modelsim会无法运行</li></ol><p><img src="https://s2.loli.net/2023/05/25/eRsqCzUuoTbLGWE.png#height=242&id=phkWx&originHeight=484&originWidth=890&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=445"><br>右键打开命令窗口，运行patch_dll.bat文件</p><ol start="2"><li>安装地址一定不能出现中文字符和空格，不然也会出错</li></ol><p><img src="https://s2.loli.net/2023/05/25/xeTlpDYoBiU8vX2.png#height=72&id=i1B04&originHeight=144&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=279"></p><ol start="3"><li>还有一种可能：是因为MAC地址不对。在运patch64_dll.bat之前需要将此文件用文件编辑器打开，添加正确的MAC地址。更改License文件中的网卡Mac地址</li></ol><p><img src="https://s2.loli.net/2023/05/25/eGySOVZsPK92XWr.png#height=342&id=Gb74s&originHeight=684&originWidth=1062&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=531"><br><img src="https://s2.loli.net/2023/05/25/7uNyVdKjGB4faOo.png#height=357&id=pv8bi&originHeight=713&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=376"><br><strong>解决方案：</strong><br>上述方法都尝试过后还是不行，就觉得可能是安装包本身出现问题，于是重新找了一个安装包进行安装，最终解决。</p><h2 id="🌵实验故障2"><a href="#🌵实验故障2" class="headerlink" title="🌵实验故障2"></a>🌵实验故障2</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/ZzPk2gSWslfjtTy.png#height=193&id=OkPOo&originHeight=386&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=600"><br><strong>原因分析：</strong><br>illegal reference to net “***”. 多半是因为没理解Wire 和Reg 的区别，如果用always语句块变量的声明就要用Reg 而不能用Wire，组合逻辑电路可以用Wire。</p><h2 id="🌵实验故障3"><a href="#🌵实验故障3" class="headerlink" title="🌵实验故障3"></a>🌵实验故障3</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/KOewRT6WUQvxgXC.png#height=10&id=PXLMz&originHeight=20&originWidth=385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=193"><br><strong>原因分析：</strong><br>括号打成中文下的括号</p><h2 id="🌵实验故障4"><a href="#🌵实验故障4" class="headerlink" title="🌵实验故障4"></a>🌵实验故障4</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/mXPE1cUanMHdR8x.png#height=66&id=ItJ8P&originHeight=131&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=588"><br><strong>原因分析：</strong><br>不能使用i++，只能是i&#x3D;i+1</p><h2 id="🌵实验故障5"><a href="#🌵实验故障5" class="headerlink" title="🌵实验故障5"></a>🌵实验故障5</h2><p><strong>故障现象：</strong><br><img src="https://s1.ax1x.com/2023/05/25/p9HRjY9.png#height=179&id=pJNKs&originHeight=357&originWidth=1128&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=564"><br><strong>原因分析：</strong><br>需要在端口中，对信号进行先声明，把端口外的声明去掉</p><h2 id="🌵实验故障6"><a href="#🌵实验故障6" class="headerlink" title="🌵实验故障6"></a>🌵实验故障6</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/rLbdRqQn3y8VkoJ.png#height=412&id=TnPVA&originHeight=823&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=633"><br><img src="https://s2.loli.net/2023/05/25/KxseAZSWLE4VFpn.png#height=277&id=CvxF6&originHeight=553&originWidth=1129&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=565"><strong>原因分析：</strong><br>原因是.v文件格式是utf-8编码，modelsim支持ANSI，UTF-8空白字符不是空白的，当把.v转换为ANSI编码可以看到下图所示，空白字符原来不是空白。删除这些异常空白字符就可以。<br>就在modelsim里编写代码，还是不要再其他地方编写再导入了</p><h2 id="🌵实验故障7"><a href="#🌵实验故障7" class="headerlink" title="🌵实验故障7"></a>🌵实验故障7</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/iTemV92RzvPlHut.png#height=251&id=WYJQ2&originHeight=502&originWidth=1195&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=598"><br><img src="https://s2.loli.net/2023/05/25/G5BOou3iZsLrhPE.png#height=194&id=kzddx&originHeight=388&originWidth=906&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=453"><br><strong>原因分析：</strong><br>仿真时信号出现高阻态和仿真出现问题等，可能是逻辑设计出现了错误，或者是某个文件中模块拼写问题等等</p><h1 id="🍀仿真及分析"><a href="#🍀仿真及分析" class="headerlink" title="🍀仿真及分析"></a>🍀仿真及分析</h1><p><img src="https://s1.ax1x.com/2023/05/25/p9HRvWR.png#height=358&id=Id5za&originHeight=716&originWidth=2019&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1010"><br>测试输出数据表如下：</p><table><thead><tr><th>clk</th><th>时钟周期</th></tr></thead><tbody><tr><td>rst</td><td>重置信号</td></tr><tr><td>addr</td><td>指令地址</td></tr><tr><td>result</td><td>计算结果</td></tr><tr><td>ins</td><td>指令字长 16 位地址</td></tr><tr><td>r1</td><td>操作数r1</td></tr><tr><td>r2</td><td>操作数r2</td></tr></tbody></table><p><img src="https://s2.loli.net/2023/05/25/7YOf1cxDU6ulHq2.png#height=329&id=Thh1R&originHeight=657&originWidth=941&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"><br><strong>分析：</strong>根据上图，此时重置信号为1，则当前各周期下的CPU不进行加法运算<br><img src="https://s2.loli.net/2023/05/25/vLJmVECqGMpxgQu.png#height=351&id=T1k7E&originHeight=702&originWidth=2268&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1134"><br><strong>分析：</strong>根据上图，此时重置信号为0，当前各周期下CPU进行加法指令操作，可知r1+r2&#x3D;result，alu根据所指定的加法周期计算出了正确的结果，实验成功。</p>]]></content>
      
      
      <categories>
          
          <category> 课程作业 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程作业 </tag>
            
            <tag> 计算机组成原理实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程设计——应用小大根交替堆实现双端优先队列</title>
      <link href="/2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="🔮课程设计选题"><a href="#🔮课程设计选题" class="headerlink" title="🔮课程设计选题"></a>🔮课程设计选题</h1><p><strong>应用小大根交替堆实现双端优先队列</strong></p><h1 id="🔮需求和规格说明"><a href="#🔮需求和规格说明" class="headerlink" title="🔮需求和规格说明"></a>🔮需求和规格说明</h1><h2 id="🎠问题描述"><a href="#🎠问题描述" class="headerlink" title="🎠问题描述"></a>🎠问题描述</h2><p>双端优先队列是一个支持如下操作的数据结构：</p><ul><li>Insert （S, x）——将元素x 插入集合S</li><li>Extract –Min （S）——删除S 中的最小关键字</li><li>Extract –Max （S）——删除S 中的最大关键字</li></ul><p>可用小大根交替堆来实现对上述三个操作的支持</p><h2 id="🎠实验要求"><a href="#🎠实验要求" class="headerlink" title="🎠实验要求"></a>🎠实验要求</h2><ol><li>给出双端优先队列的ADT 描述，包括优先队列的逻辑结构及其上基本操作。</li><li>给出小大根交替堆的ADT 描述，并实现该ADT。</li><li>以小大根交替堆结构为辅助结构实现双端优先队列的存储表示并实现其上的基本操作。</li><li>应用双端优先队列的ADT 实现依据学生成绩实现对学生信息的查询。</li><li>学生信息存放在文本文件中（格式自定，内容自行输入）。</li></ol><h1 id="🔮设计"><a href="#🔮设计" class="headerlink" title="🔮设计"></a>🔮设计</h1><h2 id="🎠整体思路"><a href="#🎠整体思路" class="headerlink" title="🎠整体思路"></a>🎠整体思路</h2><ol><li>双端优先队列以抽象类的方式建立ADT</li><li>使用小大根交替堆继承双端优先队列，并对其基本操作进行实现</li><li>建立学生信息类，将学生的相关信息（学生的学号，姓名，出生年月，出生日期，出生地，语文成绩，数学成绩，英语成绩等）</li><li>通过调用小大根交替堆中的基本函数对根据学生的各项成绩对学生的信息进行查询</li></ol><h2 id="🎠小大根交替堆和双端优先队列"><a href="#🎠小大根交替堆和双端优先队列" class="headerlink" title="🎠小大根交替堆和双端优先队列"></a>🎠小大根交替堆和双端优先队列</h2><h3 id="🎨基本介绍"><a href="#🎨基本介绍" class="headerlink" title="🎨基本介绍"></a>🎨基本介绍</h3><p>双端优先队列是指能够同时访问最大元素和最小元素的优先级队列。其主要的操作有：插入一个元素、访问最大元素、删除最大元素、访问最小元素、删除最小元素以及判断队列是否为空。通常双端优先队列的实现是通过最小最大堆来实现的。<br>小大根交替堆是一个满足如下小大根交替条件的完全二元树：如果该二元树不空，那么其上的每个元素都有一个称为关键字的域，且针对该关键字，二元树按层次形成了小大根交替的形式，即对于小大根交替堆中的任何一个结点x，如果x 位于小根层次，那么x 就是以x 为根节点的二元树中键值最小的结点，并称该结点为一个小根结点。同样的道理，如果x 位于大根层次，那么x 就是以x 为根节点的二元树中键值最大的结点，并称该结点为一个大根结点。在小大根交替堆中根结点位于小根层次。</p><h3 id="🎨实现结构"><a href="#🎨实现结构" class="headerlink" title="🎨实现结构"></a>🎨实现结构</h3><p>由于双端优先队列是基于小大根交替堆来实现的，所以在本次实验中，使用小大根交替堆继承双端优先队列来实现相关操作。</p><ol><li><strong>双端优先队列的属性和方法定义</strong></li></ol><img src="https://s1.ax1x.com/2023/05/11/p9sKP0I.png#id=oN1k1&originHeight=335&originWidth=1483&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 80%;" /><ol start="2"><li><strong>小大根交替堆的属性和方法定义</strong></li></ol><img src="https://s1.ax1x.com/2023/05/11/p9sKi7t.png#id=o1Mqt&originHeight=775&originWidth=1983&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 80%;" /><ol start="3"><li><strong>算法设计和分析</strong><ol><li><strong>找出下标为i的结点的儿子和孙子中的最小值</strong></li></ol></li></ol><p>int find_min_child_grandchild(min_max_heap<T>* h, int i)<br>分别表示下标为i的结点元素，通过逐个比较法最后输出其中的最小值</p><ol start="2"><li><strong>找出下标为i的结点的儿子和孙子中的最大值</strong></li></ol><p>int find_max_child_grandchild(min_max_heap<T>* h, int i)<br>分别表示下标为i的结点元素，通过逐个比较法最后输出其中的最大值</p><ol start="3"><li><strong>交换堆中下标为i和j的数据</strong></li></ol><p>void swap(min_max_heap<T>* h, int i, int j)<br>通过一个中间元素值T temp对当前堆中的元素进行交换</p><ol start="4"><li><strong>小层元素下滤操作，保证结构为以小层元素为根的小根堆</strong></li></ol><p>void TrickleDownMin(min_max_heap<T>* h, int i)<br>首先先找到下标为i的小层元素的儿子和孙子中的最小值：</p><ul><li>如果最小值是处于大层的儿子，那么根据小大交替堆的定义可以知道该元素没有孙子，此时比较该元素与儿子的大小关系，如果儿子小于自己，则交换元素来维护当前小根堆的结构。</li><li>如果最小值是孙子，比较孙子和该元素的大小关系：如果孙子大于该元素，证明以该元素为根节点的树的最小值就是它本身，不需要改变就符合小根堆的结构；如果孙子小于该元素，那么交换孙子和该元素，交换后需要判断该元素和父亲节点（也就是原来的儿子结点）的大小：如果父亲结点小于该元素，那么父亲结点不满足大根堆的结构，需要交换父亲节点和该元素，交换后对应孙子节点位置的元素不正确，那么就需要再对该元素进行下滤操作做递归调用。<ol start="5"><li><strong>大层元素下滤操作，保证结构为以大层元素为根的大根堆</strong></li></ol></li></ul><p>void TrickleDownMax(min_max_heap<T>* h, int i)<br>和小层元素的下滤操作有着异曲同工之意<br>首先先找到下标为i的大层元素的儿子和孙子中的最大值：</p><ul><li>如果最大值是处于小层的儿子，那么证明该元素没有孙子，比较该元素与儿子的大小关系，如果儿子大于自己，则交换维护大根堆结构。</li><li>如果有孙子，最大值是孙子，且如果孙子小于该元素，说明以该元素为根节点的树的最大值就是该元素自己，符合大根堆的结构，不需要进行调整；如果孙子大于该元素，则交换孙子与该元素，交换后判断该元素与父亲节点也就是原来的儿子节点的大小，如果父亲节点大于该元素，则父亲节点不满足小根堆结构，交换父亲节点与该元素，交换后就只有父亲节点元素也就是开始下滤操作时对应孙子节点位置的元素不正确，那么再对该元素进行下滤操作递归调用。<ol start="6"><li><strong>小层元素上滤操作，保证结构为以小层元素为根的小根堆</strong></li></ol></li></ul><p>void BubbleUpMin(min_max_heap<T>* h, int i)<br>小层元素的上滤操作，首先先找到下标为i的元素所对应的祖父结点（小根元素层对应的父亲结点所在的层为大根元素层）：</p><ul><li>如果祖父元素值比自己小，则满足小根堆的结构，不需要对此进行调整。</li><li>反之如果祖父元素的元素值比自己大，破坏了定义中的小根堆的结构，此时需要将自己与祖父结点进行交换，交换后需要对于当前结点所在的位置继续向上调整递归调用上滤函数。<ol start="7"><li><strong>大层元素上滤操作，保证结构为以大层元素为根的大根堆</strong></li></ol></li></ul><p>void BubbleUpMax(min_max_heap* h, int i)<br>    和小层元素的上滤操作有着异曲同工之意<br>    大层元素的上滤操作，首先先找到下标为i的元素所对应的祖父结点（大根元素层对应的父亲结点所在的层为小根元素层）：</p><ul><li>如果祖父元素值比自己大，则满足大根堆的结构，不需要对此进行调整。</li><li>反之如果祖父元素的元素值比自己小，破坏了定义中的大根堆的结构，此时需要将自己与祖父结点进行交换，交换后需要对于当前结点所在的位置继续向上调整递归调用上滤函数。<ol start="8"><li><strong>返回下标为i的数据属于大层还是小层</strong></li></ol></li></ul><p>int level(int i)<br>    根据小大根堆的定义即可直到通过对2取对数的方式，可以判断下标是属于大层还是小层，这里调用了floor向下取整。</p><ol start="9"><li><strong>下滤，用于删除后的调整工作</strong></li></ol><p>void TrickleDown(min_max_heap* h, int i)<br>    通过（4）（5）中对于大层和小层元素的下滤操作，主要应用在删除元素后的调整，首先对于下标为i的元素进行判断是属于小层元素还是大层元素，而后直接调用下滤函数，对当前堆进行调整，使之依然满足小大根堆的结构。</p><ol start="10"><li>上滤，用于插入后的调整工作</li></ol><p>void BubbleUp(min_max_heap* h, int i)<br>    对于下标为i的元素进行上滤操作，可用于插入元素后的调整工作，本处和（9）中的直接调用函数不相同，插入操作的时候，新增元素放置在最后的位置可能会破坏当前的结构，所以首先要进行预判断：<br>    首先先对下标为i的元素进行判断，是小层元素还是大层元素：</p><ul><li>如果是小层元素，则比较该元素与父亲结点：如果大层的父亲结点大，则对该元素进行小层上滤操作；如果父亲节点小，则该父亲节点不满足大根堆的结构，交换父亲结点与该元素，而后对于父亲结点进行大层上滤。</li><li>如果是大层元素，则比较该元素与父亲节点，如果父亲节点小，则直接对该元素进行大层上滤，如果父亲节点大，则父亲节点不满足小根堆结构，交换父亲节点与该元素后对父亲节点进行小层上滤。<ol start="11"><li><strong>返回最大值</strong></li></ol></li></ul><p>T&amp; min_max_heap::getmax()<br>    小大根交替堆中的最大值：</p><ul><li>如果对堆中只有一个元素，那么最大值为该元素</li><li>如果堆中有两个元素，由于第一层为小根堆，则最大值必然为第二个元素即儿子节点</li><li>如果有三个及以上的元素，第二层的大根堆结构保证了最大值必然出现在根节点所对应的两个孩子中，由此，比较第二个和第三个元素即两个儿子结点的元素值就可以得到最大值。<ol start="12"><li><strong>返回最小值</strong></li></ol></li></ul><p>T&amp; min_max_heap::getmin()<br>    返回最小值在小大交替堆中非常简单，只要堆不空，则根据性质，最小值一定为根节点元素。</p><ol start="13"><li><strong>删除最小值</strong></li></ol><p>T&amp; min_max_heap::popmin()</p><ul><li>堆中只有一个元素，则直接删除即可</li><li>堆中含有多个元素，删除第一个元素后，将最后一个元素放置在根节点的位置并开始调整当前根堆的结构，即从根节点开始对当前元素进行下滤操作。<ol start="14"><li><strong>删除最大值</strong></li></ol></li></ul><p>T&amp; min_max_heap::popmax()</p><ul><li>堆中只有一个元素，则直接删除即可</li><li>堆中有两个元素，返回二号元素并且将二号元素直接删除</li><li>堆中含有3个以及以上的元素，首先需要判断两个儿子节点中哪一个是最大元素，找到最大元素后，与删除最小元素同理，将最后一个元素填充到相应的位置后开始进行下滤操作来调整堆的结构。<ol start="15"><li><strong>插入元素</strong></li></ol></li></ul><p>void min_max_heap::insert(T&amp; Element)<br>    首先判断堆满则增加堆数组的长度，将插入元素放在堆的最后一个位置后进行元素上滤操作。</p><ol start="16"><li><strong>输出堆元素</strong></li></ol><p>void min_max_heap::output(ostream&amp; out)<br>    首先从第一层即0层开始计算树高和最底层的节点数(bottle_node_count_max);动态创建数组heapTreeMatrix[(high+1)_2][bottle_node_count_max_2];根据堆元素给数组进行赋值（空格和&#x2F;，\也相应的赋值给数组）最后输出。</p><h2 id="🎠学生成绩管理系统的实现"><a href="#🎠学生成绩管理系统的实现" class="headerlink" title="🎠学生成绩管理系统的实现"></a>🎠学生成绩管理系统的实现</h2><h3 id="🎨学生信息类的设计"><a href="#🎨学生信息类的设计" class="headerlink" title="🎨学生信息类的设计"></a>🎨学生信息类的设计</h3><img src="https://s1.ax1x.com/2023/05/11/p9sMFKJ.png#id=oMuqP&originHeight=1036&originWidth=1478&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><h3 id="🎨算法设计和思想"><a href="#🎨算法设计和思想" class="headerlink" title="🎨算法设计和思想"></a>🎨算法设计和思想</h3><p>学生成绩管理系统的实现主要包含学生信息的获取、修改以及类中运算符的重载<br><strong>信息获取：</strong>在学生成绩管理系统中对应输出学生的信息<br><strong>信息设置和修改：</strong>用于新增学生信息是的设置<br><strong>操作符重载：</strong> 由于student类是自己定义的，计算机不知道如何判断两个student类对象是否完全相同。这时候要使用操作符重载，让&#x3D;&#x3D;能够识别两个student类对象。</p><h2 id="🎠主函数"><a href="#🎠主函数" class="headerlink" title="🎠主函数"></a>🎠主函数</h2><img src="https://s1.ax1x.com/2023/05/11/p9sMZUx.png#id=htmZ1&originHeight=187&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:67%;" /><ol><li>读入学生信息：<br>将文件中的学生信息读入到学生类型的数组中，并按数学成绩，语文成绩，英语成绩，和总成绩放入不同的小大根交替堆中。</li><li>小大根交替堆实现的学生成绩管理系统：<br>学生管理系统的简单实现中，此处主要是实现了查询功能，对于最高最低成绩学生的查询，直接到对应查询方式的堆中调用getmax()和getmin()函数即可得到，对于具体成绩查询方式的查询，首先检查数据是否合法，之后遍历学生类数组，找到对应成绩的学生并输出。对于插入学生信息，直接调用insert将学生成绩对应写入不同的堆中，并将该学生信息写入文件。</li><li>输入，并根据输入选项进行相应的输出：<br>本函数主要验证小大根交替堆的功能，包含学生成绩管理系统的选项，实现两部分的连接。</li></ol><h1 id="🔮用户手册"><a href="#🔮用户手册" class="headerlink" title="🔮用户手册"></a>🔮用户手册</h1><p>程序运行时，首先出现“小大根交替堆实现双端优先队列”字样<br>进入主菜单界面<br>通过在下方输入相应指令的字母可以实现相关操作：<br>a.  建立小大根交替堆——请输入小大根交替堆的堆元素：<br>b.  插入元素——请输入插入的元素：<br>c.  删除最大值<br>d.  删除最小值<br>e.  输出最小值<br>f.  输出最大值<br>g.  依据学生成绩对学生信息的查询<br>程序会将学生的数学，语文，英语，总分成绩建立小大根交替堆不断调整的过程输出在当前屏幕上，并打印出“小大根交替堆实现的学生成绩管理系统”主菜单<br>根据菜单界面，用于可以通过输入相应的数字完成相应的操作：</p><ul><li>1-  输出所有学生的信息</li><li>2-  查询成绩最高的学生信息</li><li>3-  查询成绩最低的学生信息</li><li>4-  通过具体的成绩进行查询</li><li>5-  输出学生成绩的平均值</li><li>6-  添加学生信息</li><li>7-  退出</li></ul><p>h.  退出</p><h1 id="🔮调试及测试"><a href="#🔮调试及测试" class="headerlink" title="🔮调试及测试"></a>🔮调试及测试</h1><h2 id="🎠小大根交替堆实现下的双端优先队列"><a href="#🎠小大根交替堆实现下的双端优先队列" class="headerlink" title="🎠小大根交替堆实现下的双端优先队列"></a>🎠小大根交替堆实现下的双端优先队列</h2><p>菜单界面如下：<br><img src="https://s1.ax1x.com/2023/05/11/p9sQJOJ.png#id=a6oIC&originHeight=340&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 50%;" /><br>a-建立小大根交替堆<br><img src="https://s1.ax1x.com/2023/05/11/p9sQlWT.png#id=HTBeF&originHeight=574&originWidth=443&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>b-插入元素<br><img src="https://s1.ax1x.com/2023/05/11/p9sQ3SU.png#id=D2lmg&originHeight=574&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>c-删除最大值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQQYV.png#id=ygQ8T&originHeight=103&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>d-删除最小值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQMF0.png#id=JdJmU&originHeight=107&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>e-输出最小值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQGy4.png#id=uP4KQ&originHeight=103&originWidth=270&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>f-输出最大值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQ8lF.png#id=It7aS&originHeight=101&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>g-依据学生成绩对学生信息的查询<br><img src="https://s1.ax1x.com/2023/05/11/p9sQtm9.png#id=AMGJB&originHeight=744&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>小大根交替堆实现的学生成绩管理系统菜单如下：<br><img src="https://s1.ax1x.com/2023/05/11/p9sQNwR.png#id=MPvyx&originHeight=353&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>1-输出所有学生的信息</p><p>2-查询成绩最高的学生信息<br><img src="https://s1.ax1x.com/2023/05/11/p9sQUT1.png#id=OLQCM&originHeight=356&originWidth=886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>3-查询成绩最低的学生信息<br><img src="https://s1.ax1x.com/2023/05/11/p9sQdFx.png#id=J7fAM&originHeight=195&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>4-通过具体的成绩进行查询<br><img src="https://s2.loli.net/2023/05/11/4eZnTHDKtkbyLpY.png#id=O44vI&originHeight=402&originWidth=879&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>5-输出学生成绩的平均值<br><img src="https://s2.loli.net/2023/05/11/GLwIeixBdfv1sT3.png#id=C4aMl&originHeight=97&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>6-添加学生信息<br><img src="https://s2.loli.net/2023/05/11/kMVu1FQZ2PdUWR3.png#id=EXP0D&originHeight=248&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s2.loli.net/2023/05/11/35V6OJqkjXyWTUo.png#id=IDQsb&originHeight=717&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s2.loli.net/2023/05/11/xqEonrkKIMTyj7A.png#id=x9Cdy&originHeight=775&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>添加学生信息后的txt文件如下<br><img src="https://s2.loli.net/2023/05/11/Z6woNhO5US2PBXt.png#id=u7X1E&originHeight=281&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><h1 id="🔮进一步改进"><a href="#🔮进一步改进" class="headerlink" title="🔮进一步改进"></a>🔮进一步改进</h1><ol><li>由于本次实验进行的时间较短，仅仅实现了文本界面——后续改进可以设计一个GUI界面，能够同时实现显示当前文档中的学生信息，小大根交替堆的调整过程等信息。</li><li>该程序对于学生信息的管理系统所包含的内容较少——可以增加包括对学生的不同的成绩进行排序、将学生通过学号、出生地等的进行归类等操作。</li><li>该程序对于学生信息的添加后存入文件后，不能及时的读取进入该程序，需要等退出此次程序，下一次进行操作的时候才能读取今年加入的学生信息，此问题需要后续进行提升改进。</li><li>目前堆设定的长度最大值为50，后续若需要大批量的数据进行读入可以增加。</li></ol><h1 id="🔮心得体会"><a href="#🔮心得体会" class="headerlink" title="🔮心得体会"></a>🔮心得体会</h1><h2 id="🎠程序分析"><a href="#🎠程序分析" class="headerlink" title="🎠程序分析"></a>🎠程序分析</h2><p>本次实验主要进行的内容是数据结构中的小大根交替堆min-max-heap和该数据结构实现的双端优先队列在学生成绩管理系统上的应用，其难点在于对于堆结构的维护和调整。在对于堆的调整的过程中，上滤和下滤的操作是该数据结构中的核心点，小根堆和大根堆的区别在于：在上滤和上滤的过程中需要我们判断该元素是处于小层还是大层，由此来进行相应层的上滤和下滤，在上滤和下滤的过程中，由于大小根堆的的特性值，也会比普通大根堆或是小根堆的上滤和下滤要复杂一点。</p><h2 id="🎠程序性能分析"><a href="#🎠程序性能分析" class="headerlink" title="🎠程序性能分析"></a>🎠程序性能分析</h2><p>对于本实验，程序设计中包含了对异常的处理，对操作符的重载以及对类函数的封装等，在主函数中直接调用类函数对应头文件，由于本实验中小大根交替堆是以堆的形式展现在屏幕上，对于学生成绩的查询系统也没有可提供的大数据验证。程序主要是递归调用上滤下滤函数时的复杂度，复杂度为O(nlog2n)。</p><h2 id="🎠程序编写心得"><a href="#🎠程序编写心得" class="headerlink" title="🎠程序编写心得"></a>🎠程序编写心得</h2><h3 id="🎨语言的选择"><a href="#🎨语言的选择" class="headerlink" title="🎨语言的选择"></a>🎨语言的选择</h3><p>由于大一这一个学期的所有程序的编写基本都选择了使用C语言进行编写，在大一上半年对于C++的学习也几乎没有进行实践，导致对C++十分生疏甚至是不会的；在日常学习的过程中也发现了C++的重要性，因此本次实验采用C++进行编写。<br>在编写的过程中，对于C++中包括类，文件读取和写入等操作都非常生疏，也对于C++进行了一定的学习。其中印象比较深刻的是类中需要对于操作符进行重载，这样做的目的是为了防止用户修改用于基本类型数据的运算符性质。因此通过本次实验，不仅仅让我对于小大根交替堆这个数据结构有了一定的了解，同时也让我对C++的认识更近一步，对于自己来说也算是一举两得了。</p><h3 id="🎨小大根交替堆"><a href="#🎨小大根交替堆" class="headerlink" title="🎨小大根交替堆"></a>🎨<strong>小大根交替堆</strong></h3><p>堆有一个性质，在一个给定优先次序的情况下。堆顶元素的优先级最高。而且这个性质递归的适用于每一个子堆。所以，每次都可以用O(1)的时间得到优先级最高的一个元素。如果要删除，那么只需要O(log2(N))的时间去维护整个堆，使其仍然满足堆的性质。<br>但在课堂上所学习得小根堆和大根堆只能较为方便的查找到所有数字中的最小值或者最大值。而要同时得到最小值和最小值，除了堆，还可以通过平衡二叉树来实现，此时最左孩子和最右孩子就是所求最值。<br>通过本次实验对于小大根交替堆的理解，来实现查找最大值和最小值的功能，而不需要直到其他结果，只需要引入一个最大最小堆即可。<br>在一个系统或者在一个生活场景中，我们需要实时的知道当前的最大值最小值，这个时候，如果我们每次都得通过遍历得到最值，那么效率无疑是低下的。那么这个时候，小大根交替堆就能为此应用场景提供适配。</p><h1 id="🔮程序代码"><a href="#🔮程序代码" class="headerlink" title="🔮程序代码"></a>🔮程序代码</h1><p>代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%BA%94%E7%94%A8%E5%B0%8F%E5%A4%A7%E6%A0%B9%E4%BA%A4%E6%9B%BF%E5%A0%86%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">Cassie&#x2F;数据结构课程设计-应用小大根交替堆实现双端优先队列 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 数据结构课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计课程设计——推箱子</title>
      <link href="/2021/01/05/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%8E%A8%E7%AE%B1%E5%AD%90/"/>
      <url>/2021/01/05/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="⛳需求和规格说明"><a href="#⛳需求和规格说明" class="headerlink" title="⛳需求和规格说明"></a>⛳需求和规格说明</h1><p>“推箱子小游戏”要求编写一个推箱子游戏游戏，使用图形界面。<br>推箱子游戏的目：用最少的步数把所有的箱子推到目标位置。</p><h2 id="🎳游戏规则"><a href="#🎳游戏规则" class="headerlink" title="🎳游戏规则"></a>🎳游戏规则</h2><ol><li>游戏开始时，在游戏区域内随机的出现箱子、障碍物、小人以及箱子的目标位置。</li><li>箱子只可以被推动，不可以被拉动。</li><li>用户通过键盘的来控制小人上下左右的移动来推动箱子。记录用户移动小人的次数。</li><li>如果箱子被推到死角，则游戏结束。</li><li>所有箱子被推到目标位置，游戏胜利。</li></ol><h1 id="⛳设计"><a href="#⛳设计" class="headerlink" title="⛳设计"></a>⛳设计</h1><h2 id="🎳需求概要"><a href="#🎳需求概要" class="headerlink" title="🎳需求概要"></a>🎳需求概要</h2><ul><li><p>推箱子游戏的设计目标完成一个比较简单的游戏，使之能够实现推箱子游戏的基本功能，成为一个较为完整的游戏框架。游戏内容为，在一个较为狭小的仓库中，要求把木箱子推到游戏界面中的目标位置，稍不小心就会出现箱子无法移动或者通道被堵住的情况，所以需要玩家巧妙地利用有限的空间和通道，合理安排自己移动的次序和位置，使得顺利完成游戏的任务。</p></li><li><p>用户进入游戏界面后，会出现一个小人，若干个箱子和箱子的目标位置。玩家可以根据自己的想法自由地移动箱子，游戏提供跳关以及退步的功能模块，拼接这些模块，玩家可以实现对游戏的快速通关！</p></li><li><p>由于该程序需要使用图形界面，最终选择使用VS2019软件进行编程。</p></li></ul><h2 id="🎳设计思路"><a href="#🎳设计思路" class="headerlink" title="🎳设计思路"></a>🎳设计思路</h2><p>系统流程图如下所示：<br><img src="https://s1.ax1x.com/2023/05/09/p9BGUkq.jpg#height=363&id=OyCqa&originHeight=726&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=517" style="zoom:50%;" /></p><h2 id="🎳设计表示"><a href="#🎳设计表示" class="headerlink" title="🎳设计表示"></a>🎳设计表示</h2><p>头文件总览：</p><table><thead><tr><th align="center"><strong>include</strong></th><th align="center">#include&lt;stdio.h&gt;</th><th align="center">标准输入输出头文件</th></tr></thead><tbody><tr><td align="center"></td><td align="center">#include&lt;stdlib.h&gt;</td><td align="center">system函数的头文件</td></tr><tr><td align="center"></td><td align="center">#include&lt;windows.h&gt;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">#include&lt;conio.h&gt;</td><td align="center">图形库头文件</td></tr><tr><td align="center"></td><td align="center">#include&lt;graphics.h&gt;</td><td align="center">图形库头文件</td></tr><tr><td align="center">函数总览：</td><td align="center"></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center"><strong>函数</strong></th><th align="center">void DrawMap()</th><th align="center">绘制地图，加载图片</th></tr></thead><tbody><tr><td align="center"></td><td align="center">void PlayGame()</td><td align="center">推箱子游戏的主体</td></tr><tr><td align="center"></td><td align="center">int Win()</td><td align="center">判断该关卡是否通关</td></tr><tr><td align="center"></td><td align="center">void TargetCount()</td><td align="center">遍历地图，查看总共的目的地的个数</td></tr><tr><td align="center"></td><td align="center">void InitGame();</td><td align="center">游戏开始前需要做的准备工作</td></tr><tr><td align="center"></td><td align="center">void SaveStep()</td><td align="center">将玩家的每一步都保存起来</td></tr><tr><td align="center"></td><td align="center">void PreviousStep()</td><td align="center">记录上一步</td></tr></tbody></table><p>宏定义：</p><table><thead><tr><th align="center"><strong>宏定义</strong></th><th align="center">#define SIZE 45</th><th align="center">每张贴图的大小</th></tr></thead><tbody><tr><td align="center"></td><td align="center">#define WINDOWSWIDTH (COL*SIZE)</td><td align="center">窗口的宽</td></tr><tr><td align="center"></td><td align="center">#define WINDOWSHEIGHT (ROW*SIZE)</td><td align="center">窗口的高</td></tr><tr><td align="center"></td><td align="center">#define MAXLEVEL 10</td><td align="center">最大关卡数</td></tr></tbody></table><p>定义的变量：</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>成员名</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">int</td><td align="center">map[20][20]&#x3D;{};</td><td align="center">地图数组</td></tr><tr><td align="center"></td><td align="center">temp[5000][20][20] &#x3D; {}</td><td align="center">临时地图数组</td></tr><tr><td align="center"></td><td align="center">step &#x3D; -1</td><td align="center">计步</td></tr><tr><td align="center"></td><td align="center">ROW &#x3D; 0</td><td align="center">地图的行</td></tr><tr><td align="center"></td><td align="center">COL &#x3D; 0</td><td align="center">地图的列</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">玩家的横坐标</td></tr><tr><td align="center"></td><td align="center">C</td><td align="center">玩家的纵坐标</td></tr><tr><td align="center"></td><td align="center">targetCount &#x3D; 0</td><td align="center">地图中目的地的个数</td></tr><tr><td align="center"></td><td align="center">gameLevel &#x3D; 1</td><td align="center">游戏关卡</td></tr><tr><td align="center">char</td><td align="center">dir &#x3D; ‘s’</td><td align="center">人物当前的方向</td></tr><tr><td align="center"></td><td align="center">fileName[100]</td><td align="center">存放图片路径的字符串</td></tr><tr><td align="center">IMAGE</td><td align="center">bkImg</td><td align="center">没有墙，人物，箱子的空白图片</td></tr><tr><td align="center"></td><td align="center">boxImg</td><td align="center">箱子的图片</td></tr><tr><td align="center"></td><td align="center">dkboxImg</td><td align="center">箱子推到目的地时的图片</td></tr><tr><td align="center"></td><td align="center">targetImg</td><td align="center">目的地的图片</td></tr><tr><td align="center"></td><td align="center">blankImg</td><td align="center">没有墙，人物，箱子的空白图片</td></tr><tr><td align="center"></td><td align="center">wallImg</td><td align="center">墙面的图片</td></tr><tr><td align="center"></td><td align="center">playerImg[4]</td><td align="center">人物的四各方向的图片</td></tr></tbody></table><h1 id="⛳推箱子的功能框架"><a href="#⛳推箱子的功能框架" class="headerlink" title="⛳推箱子的功能框架"></a>⛳推箱子的功能框架</h1><p><img src="https://s1.ax1x.com/2023/05/09/p9BGt7n.jpg#id=tRh9z&originHeight=483&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎳初始化模块"><a href="#🎳初始化模块" class="headerlink" title="🎳初始化模块"></a>🎳初始化模块</h2><p>该模块包括屏幕初始化和游戏第一关到最后一关的初始化。屏幕的初始化用于输出操作信息，游戏每一关的初始化时构建每一关的关卡。</p><h2 id="🎳画图模块"><a href="#🎳画图模块" class="headerlink" title="🎳画图模块"></a>🎳画图模块</h2><p>用于画墙，画箱子，画人物，画目的地。</p><h2 id="🎳移动人物模块"><a href="#🎳移动人物模块" class="headerlink" title="🎳移动人物模块"></a>🎳移动人物模块</h2><p>该模块用于移动人物，包括人物与目的地之间，空地与人物之间，空地与箱子之间，箱子与目的地之间的移动变化。</p><h2 id="🎳功能控制模块"><a href="#🎳功能控制模块" class="headerlink" title="🎳功能控制模块"></a>🎳功能控制模块</h2><p>包括判断是否通关，悔步，关卡跳关，关卡重置操作。</p><h1 id="⛳推箱子具有的功能"><a href="#⛳推箱子具有的功能" class="headerlink" title="⛳推箱子具有的功能"></a>⛳推箱子具有的功能</h1><h2 id="🎳能够显示主菜单和游戏界面"><a href="#🎳能够显示主菜单和游戏界面" class="headerlink" title="🎳能够显示主菜单和游戏界面"></a>🎳能够显示主菜单和游戏界面</h2><img src="https://s1.ax1x.com/2023/05/09/p9BGJmj.png#height=325&id=sutgX&originHeight=650&originWidth=440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=220" style="zoom:50%;" />游戏界面上有一个菜单，可以让玩家进行必要的游戏设置。同时可以将地图中的数字信息转化成对应的图像信息显示在游戏界面上。代码展示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setfillcolor</span>(<span class="built_in">RGB</span>(<span class="number">235</span>, <span class="number">227</span>, <span class="number">206</span>));   <span class="comment">//填充当前颜色</span></span><br><span class="line"><span class="built_in">fillrectangle</span>(WINDOWSWIDTH, <span class="number">0</span>, WINDOWSWIDTH + <span class="number">220</span>, WINDOWSHEIGHT);   <span class="comment">//窗口大小</span></span><br><span class="line"><span class="built_in">settextcolor</span>(BLACK);</span><br><span class="line"><span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">0</span>, <span class="string">&quot;宋体&quot;</span>);</span><br><span class="line"><span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH + <span class="number">45</span>, <span class="number">45</span>, <span class="string">&quot;推箱子小游戏&quot;</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">70</span>, <span class="string">&quot;操作说明:&quot;</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">95</span>, <span class="string">&quot;WASD 或者↑↓←→&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;关卡           ：%d/%d&quot;</span>, gameLevel, MAXLEVEL);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">120</span>, str);</span><br><span class="line"><span class="type">char</span> stepStr[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现键盘操作的功能"><a href="#🎳能够实现键盘操作的功能" class="headerlink" title="🎳能够实现键盘操作的功能"></a>🎳能够实现键盘操作的功能</h2><p>可以从用户的键盘上获取信息，根据不同的方向键盘所对应的ASCII码数值，实现人物上下左右的移动。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dir = _getch();         <span class="comment">//从键盘上获取数据</span></span><br><span class="line"><span class="keyword">switch</span> (dir)</span><br></pre></td></tr></table></figure><p>通过#include&lt;conio.h&gt;调用getch函数，用来获取键值，再通过switch-case实现人物的移动</p><h3 id="🥌计算说明书部分"><a href="#🥌计算说明书部分" class="headerlink" title="🥌计算说明书部分"></a>🥌计算说明书部分</h3><p>假设空地为0，墙面为1，目的地为3，箱子为4，人物为5。这样子的目的是使得地图看起来更加规则，后面移动时的操作更加简洁明了。<br><img src="https://s1.ax1x.com/2023/05/09/p9BG8XQ.png#height=244&id=OKQgF&originHeight=486&originWidth=301&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=151"><br>上图为第一关的地图</p><ul><li>人物移动到空地上的数值变化就是0-&gt;5</li><li>箱子移动到空地上的数值变化就是0-&gt;4</li><li>人移动到目的地上时的数据变化就是3-&gt;8(3+5)</li><li>箱子移动到目的地上时的数据变化就是3-&gt;7(3+4)</li><li>根据每一次的移动，来改变原来位置和现在移动的位置所对应的数据变化，还原出地图所对应的数字模型。在编写程序的时候，分为四个方向——上下左右，依次分类讨论。由于四个方向的思路几乎相同，则可以重点编写一个方向所对应的数字改变，剩余的四个方向以此类推少做略微改变即可。</li><li>(下面以玩家进行向上移动时的数字改变为例子的代码显示)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">72</span>:               <span class="comment">//方向键上</span></span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">0</span>)  <span class="comment">// 1 人上面是空地（0）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)<span class="comment">// 1.1所站的地方以前是空地（5+0）</span></span><br><span class="line">&#123;<span class="comment">// 1.2所站的地方以前是目的地（3+5）</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">5</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">4</span>)  <span class="comment">// 2 人上面是箱子（4）</span></span><br><span class="line">&#123;<span class="comment">//2.1所站的地方以前是空地（5+0)</span></span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>) <span class="comment">//2.1.1箱子的上面是空地(0)</span></span><br><span class="line">&#123;        <span class="comment">//2.1.2箱子的上面是目的地(3)</span></span><br><span class="line">        <span class="comment">//2.2所站的地方以前是目的地(5+3)</span></span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">2</span>][C] == <span class="number">0</span> || map[R - <span class="number">2</span>][C] == <span class="number">3</span>)<span class="comment">//2.2.1箱子的上面是空地(0)</span></span><br><span class="line">&#123;        <span class="comment">//2.2.2箱子的上面是目的地(3)</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">2</span>][C] += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">3</span>)          <span class="comment">//3人上面是目的地(3)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)                 <span class="comment">//3.1人所站的地方是空地(5+0)</span></span><br><span class="line">&#123;                     <span class="comment">//3.2人所站的地方是目的地(5+3)</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">7</span>)            <span class="comment">//4人上面是在目的地的箱子也就是(3+4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)<span class="comment">//4.1人所站的地方以前是空地（0+5） </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">2</span>][C] == <span class="number">0</span> || map[R - <span class="number">2</span>][C] == <span class="number">3</span>)          <span class="comment">//4.1.1箱子的上面是空地（0)</span></span><br><span class="line">&#123;               <span class="comment">//4.1.2箱子的上面是目的地（3）</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;                                    <span class="comment">//4.2人所站的地方以前是目的地（3+5）       </span></span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">8</span>;                                 <span class="comment">//4.2.1箱子的上面是空地（0）</span></span><br><span class="line">map[R - <span class="number">2</span>][C] += <span class="number">4</span>;                                <span class="comment">//4.2.2箱子的上面是目的地（3）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SaveStep</span>();<span class="comment">//将每一步走之后的地图信息都保存起来</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现箱子到达目的地的时候的变色显示"><a href="#🎳能够实现箱子到达目的地的时候的变色显示" class="headerlink" title="🎳能够实现箱子到达目的地的时候的变色显示"></a>🎳能够实现箱子到达目的地的时候的变色显示</h2><p>当玩家把箱子推到指定的位置的时候，需要实现箱子的变色，这样可以明确的告诉玩家，您的箱子已经到达指定的目的地。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:     <span class="comment">//箱子被推到了目的地 4+3</span></span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;dkboxImg);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/05/09/p9BG36g.png#height=359&id=ys0YL&originHeight=717&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=362" style="zoom:50%;" /><h2 id="🎳能够实现人物的方向运动"><a href="#🎳能够实现人物的方向运动" class="headerlink" title="🎳能够实现人物的方向运动"></a>🎳能够实现人物的方向运动</h2><p>当玩家通过上下左右的按键操控游戏中的人物进行运动的时候，人物也会随着方向键的改变，改变其旋转的方向。可以使得游戏更加生动，增加可玩性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (dir)      <span class="comment">//从键盘中获取键值，以改变人物图片的方向</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>W<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">72</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>S<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">1</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">75</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">2</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">77</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">3</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>通过玩家的上下左右的操作中获取键值，再次通过switch-case函数通过不同的键值显示不同的人物方向。<br><img src="https://s1.ax1x.com/2023/05/09/p9BGY0s.png#id=B1r8V&originHeight=129&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://s1.ax1x.com/2023/05/09/p9BGrX4.png#id=h1YYX&originHeight=232&originWidth=1386&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎳能够实现人物的方向运动-1"><a href="#🎳能够实现人物的方向运动-1" class="headerlink" title="🎳能够实现人物的方向运动"></a>🎳能够实现人物的方向运动</h2><p>在游戏中，当玩家把所有的箱子都推到指定的目的地的时候，系统会进行判断。会跳出一个窗口，提示是否进入下一关游戏还是选择退出该游戏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TargetCount</span><span class="params">()</span>             <span class="comment">//遍历地图，查看总共的目的地的个数，用于判断是否将所有箱子移动到了目的地</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">targetCount = <span class="number">0</span>;<span class="comment">//每次调用函数都需要将targetCount初始化为零，不然就是在上一次的基础上++了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">3</span> || map[i][j] == <span class="number">7</span>)        </span><br><span class="line">targetCount++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Win</span><span class="params">()</span>          <span class="comment">//判断是否通关 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> boxToTargetCount = <span class="number">0</span>;       <span class="comment">//在目的地的箱子个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)           <span class="comment">//遍历整张地图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)       </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">7</span>)         <span class="comment">//所有的箱子到达目的地（3+4=7）</span></span><br><span class="line">&#123;</span><br><span class="line">boxToTargetCount++; </span><br><span class="line"><span class="keyword">if</span> (boxToTargetCount == targetCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (gameLevel == MAXLEVEL)        <span class="comment">//是否通过了全部的关卡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;恭喜你全部通关，太棒了！&quot;</span>, <span class="string">&quot;通关&quot;</span>, MB_OKCANCEL | MB_SYSTEMMODAL);       <span class="comment">//弹框函数</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过关，返回选择函数值 1 确定 2取消</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;你真棒，继续下一关吧！&quot;</span>, <span class="string">&quot;获胜&quot;</span>, MB_OKCANCEL | MB_SYSTEMMODAL));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个函数的共同作用，以判断该关卡是否成功。</p><ul><li>void TargetCount()遍历地图，查看总共的目的地的个数</li><li>int Win()判断该关卡是否通关</li></ul><p>再通过Win函数中弹框函数获取用户点击的选项所对应的数值判断是进去下一关还是退出游戏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> select = <span class="built_in">Win</span>();      <span class="comment">//是否继续下一关，1 确定 2  取消</span></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        gameLevel++;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/05/09/p9BGat0.png#height=156&id=m0YFt&originHeight=312&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=237" style="zoom:50%;" />点击确定则进去下一个关卡，点击取消则直接退出游戏。<h2 id="🎳能够实现跳过关卡的功能"><a href="#🎳能够实现跳过关卡的功能" class="headerlink" title="🎳能够实现跳过关卡的功能"></a>🎳能够实现跳过关卡的功能</h2><p>玩家可以通过对应的按键进行选择上一关或者下一关的选择，进行跳关选项。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:<span class="comment">//上一关</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gameLevel &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gameLevel--;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:<span class="comment">//下一关</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gameLevel &lt; MAXLEVEL)</span><br><span class="line">&#123;</span><br><span class="line">gameLevel++;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现悔步的操作"><a href="#🎳能够实现悔步的操作" class="headerlink" title="🎳能够实现悔步的操作"></a>🎳能够实现悔步的操作</h2><p>系统会记录每一步的运动，玩家可以通过按键的操控，实现悔步。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveStep</span><span class="params">()</span>                  <span class="comment">//将玩家的每一步都保存起来，以便于回退操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">step += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp[step][i][j] = map[i][j];        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">PreviousStep</span><span class="params">()</span><span class="comment">//上一步，以实现回退操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">step--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j] = temp[step][i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个函数的共同协助完成悔步的操作。</p><ul><li>void SaveStep()——将玩家的每一步都保存起来</li><li>void  PreviousStep()——记录上一步</li></ul><p>在人物移动的每一步时，都会通过SaveStep()函数，保存玩家的每一步。（通过ESC实现回退操作的代码显示）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">27</span>:<span class="comment">//ESC按键ASCII值   回退</span></span><br><span class="line"><span class="built_in">PreviousStep</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>(下图为通过按ESC实现悔步操作)<br><img src="https://s1.ax1x.com/2023/05/09/p9BG0pT.png#height=437&id=VR5TM&originHeight=874&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/09/p9BGDcF.png#height=437&id=kvJXb&originHeight=874&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627" style="zoom:50%;" /></p><h2 id="🎳能够实现记录步数的操作"><a href="#🎳能够实现记录步数的操作" class="headerlink" title="🎳能够实现记录步数的操作"></a>🎳能够实现记录步数的操作</h2><p>在功能菜单界面，会显示当前步数，随时记录玩家都在游戏过程中的总步数。每启用一次SaveStep()函数就会实现Step+1</p><ul><li>这里需要注意的是：</li></ul><p>判断是不是重新开始，因为运行程序开始和按了R开始两种情况是不一样的；如果是第一次开始，在主函数中执行DrawMap函数之后就会等待玩家按了按键之后，才再次执行DrawMap函数，这种情况step是从-1开始计步的，这时显示时就需要+1。而如果按了R重新开始，这时执行了InitGame函数，然后PlayGame函数执行完毕，就会继续执行DrawMap函数，这时step是为0的就不需要+1了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (step == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(stepStr, <span class="string">&quot;步数           ：%d&quot;</span>, step + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">145</span>, stepStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(stepStr, <span class="string">&quot;步数           ：%d&quot;</span>, step);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">145</span>, stepStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="⛳用户手册"><a href="#⛳用户手册" class="headerlink" title="⛳用户手册"></a>⛳用户手册</h1><p>本游戏一共有10关，从易到难，每一关都可以进行重新开始，回退，记录步数，返回上一关，进入下一关等操作。</p><h2 id="🎳操作说明"><a href="#🎳操作说明" class="headerlink" title="🎳操作说明"></a>🎳操作说明</h2><ul><li>可以通过按动键盘“WASD”或者“↑↓←→”对游戏中的小人物进行操控；</li><li>可以通过按动键盘“Esc”键来进行回退上一步，及允许用户悔步；</li><li>可以通过按动键盘“R”对该局游戏重新开始；</li><li>可以通过按动键盘“X”直接进入上一关；</li><li>可以通过按动键盘“N”直接进入下一关；</li><li>通过界面上的步数，可以直接看出本局用户行走的步数。</li></ul><h1 id="⛳调试及测试"><a href="#⛳调试及测试" class="headerlink" title="⛳调试及测试"></a>⛳调试及测试</h1><h2 id="🎳地图部分"><a href="#🎳地图部分" class="headerlink" title="🎳地图部分"></a>🎳地图部分</h2><p>刚开始只编辑了一张地图并且直接在程序中体现<br><img src="https://s1.ax1x.com/2023/05/09/p9BGdhV.png#id=H8qux&originHeight=411&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>后续为了实现选关和增加关卡的数量，选择使用TXT文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载地图</span></span><br><span class="line"><span class="type">char</span>  fileName[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;      <span class="comment">//定义</span></span><br><span class="line"><span class="built_in">sprintf</span>(fileName, <span class="string">&quot;./第%d关.txt&quot;</span>, gameLevel);      <span class="comment">//为了简化代码以及便于增加游戏关卡数，采用读取TXT文件的方法</span></span><br><span class="line"></span><br><span class="line">FILE* file;         </span><br><span class="line"><span class="keyword">if</span> ((file = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;ROW);       <span class="comment">//地图的行</span></span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;COL);       <span class="comment">//地图的列    （读取行列数以便控制窗口的大小和遍历）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">rewind</span>(file);     <span class="comment">//文件指针回绕到文件起始处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎳步数计算部分"><a href="#🎳步数计算部分" class="headerlink" title="🎳步数计算部分"></a>🎳步数计算部分</h2><p>关卡重置后会发现当前步数多1<br>需要判断是不是重新开始，因为运行程序开始和按了R开始两种情况是不一样的。如果是第一次开始，在主函数中执行DrawMap函数之后就会等待玩家按了按键之后，才再次执行DrawMap函数，这种情况step是从-1开始计步的，这时显示时就需要+1。而如果按了R重新开始，这时执行了InitGame函数，然后PlayGame函数执行完毕。就会继续执行DrawMap函数，这时step是为0的就不需要+1了。</p><h1 id="⛳运行示例"><a href="#⛳运行示例" class="headerlink" title="⛳运行示例"></a>⛳运行示例</h1><img src="https://s1.ax1x.com/2023/05/09/p9BGB1U.png#height=392&id=cHGpX&originHeight=784&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=492" style="zoom:50%;" /><img src="https://s1.ax1x.com/2023/05/09/p9BGynJ.png#height=392&id=nXW0X&originHeight=784&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=582" style="zoom:50%;" /><h1 id="⛳进一步改进"><a href="#⛳进一步改进" class="headerlink" title="⛳进一步改进"></a>⛳进一步改进</h1><ol><li>可以增加一个菜单界面，使用户更加清楚自己接下来的操作（如增加游戏规则说明，选择关卡等）；</li><li>可以增加背景音乐，使得该小游戏更加可玩，有趣；</li><li>可以改变背景颜色，增加人物颜色的可选择性等；</li><li>代码可以更加简单明了一些。</li></ol><h1 id="💡程序代码"><a href="#💡程序代码" class="headerlink" title="💡程序代码"></a>💡程序代码</h1><p>代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F">Cassie&#x2F;程序设计课程设计-推箱子小游戏 at main · xiayi0409&#x2F;Cassie · GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
          <category> 程序设计技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 程序设计技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
