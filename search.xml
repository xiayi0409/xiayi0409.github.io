<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程课程总结</title>
      <link href="/2023/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"/>
      <url>/2023/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="🍒01章-软件工程学概述"><a href="#🍒01章-软件工程学概述" class="headerlink" title="🍒01章 软件工程学概述"></a>🍒01章 软件工程学概述</h1><h4 id="软件的定义："><a href="#软件的定义：" class="headerlink" title="软件的定义："></a>软件的定义：</h4><p>软件是多种术语和对象的集合，并将这些术语和对象有效地配置在一起。软件包括三个组成部分——<strong>程序、文档和数据</strong><br>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><h4 id="软件的特点："><a href="#软件的特点：" class="headerlink" title="软件的特点："></a>软件的特点：</h4><ol><li>软件是被工程化的逻辑系统</li><li>软件一般没有磨损</li><li>软件具有不同于一般实物系统的复杂性</li></ol><h4 id="软件危机定义："><a href="#软件危机定义：" class="headerlink" title="软件危机定义："></a>软件危机定义：</h4><p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。这些问题不是在解决具体问题时遇到的，而是软件开发过程中所面临的具有<strong>普适性的问题</strong>。<br>软件危机的典型表现：概括的来说，<strong>开发周期长、成本高、质量差、适应性差和难以维护</strong></p><h4 id="软件工程方法学三要素："><a href="#软件工程方法学三要素：" class="headerlink" title="软件工程方法学三要素："></a>软件工程方法学三要素：</h4><p>软件工程的三个基本要素：<strong>方法、工具和过程</strong></p><ol><li><strong>过程：</strong>规定了完成各项任务的过程</li></ol><p>为了获得高质量软件所需要完成的一系列任务的<strong>框架</strong>，规定了完成各项任务的<br>工作步骤。</p><ol start="2"><li><strong>方法：</strong>完成软件开发的各项任务的技术方法，回答“怎样做”的问题</li><li><strong>工具：</strong>（为运用方法而提供的自动的或半自动的）软件工程的支撑环境</li></ol><p>目前使用最广泛的软件工程方法学，分别是<strong>传统方法学</strong>和<strong>面向对象方法学</strong></p><h4 id="软件生命周期各阶段定义："><a href="#软件生命周期各阶段定义：" class="headerlink" title="软件生命周期各阶段定义："></a>软件生命周期各阶段定义：</h4><p>三个时期：<strong>软件定义、软件开发和运行维护（软件维护）</strong></p><ol><li><strong>软件定义：问题定义、可行性研究和需求分析</strong></li></ol><p>软件定义时期的任务是：</p><ol><li>确定软件开发工程必须完成的总目标；</li><li>确定工程的可行性；</li><li>导出实现工程目标应该采用的策略及系统必须完成的功能；</li><li>估计完成该项工程需要的资源和成本，并且制定工程进度表。</li></ol><p>这个时期的工作通常又称为系统分析，由系统分析员负责完成。</p><ol start="2"><li><strong>软件开发：总体设计、详细设计、编码和单元测试、综合测试</strong>（前两个为系统设计，后两个为系统实现）</li></ol><p>开发时期具体设计和实现在前一个时期定义的软件</p><ol start="3"><li><strong>软件维护：</strong>主要任务是使软件持久地满足用户的需要</li></ol><h4 id="Scrum模型的框架图："><a href="#Scrum模型的框架图：" class="headerlink" title="Scrum模型的框架图："></a>Scrum模型的框架图：</h4><p>Scrum 是一个轻量级的项目管理的框架，它的核心在于迭代。<br><img src="https://s1.ax1x.com/2023/05/16/p92yWAH.png#height=324&id=N4BMo&originHeight=648&originWidth=1152&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=576"></p><h4 id="Scrum三大特点："><a href="#Scrum三大特点：" class="headerlink" title="Scrum三大特点："></a>Scrum三大特点：</h4><ol><li>关注当下——“可能性的”艺术</li><li>放权——团队自组织、自管理</li><li>提高沟通效率——面对面沟通</li></ol><h4 id="Scrum团队模型的三种角色："><a href="#Scrum团队模型的三种角色：" class="headerlink" title="Scrum团队模型的三种角色："></a>Scrum团队模型的三种角色：</h4><ol><li>Scrum Master——不要管理团队</li><li>Product Owner</li><li>团队</li></ol><p><img src="https://s1.ax1x.com/2023/05/13/p96rlLj.png#height=327&id=wJKbc&originHeight=654&originWidth=1398&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=699"></p><h1 id="🍒02章-可行性研究"><a href="#🍒02章-可行性研究" class="headerlink" title="🍒02章 可行性研究"></a>🍒02章 可行性研究</h1><h4 id="可行性分析定义："><a href="#可行性分析定义：" class="headerlink" title="可行性分析定义："></a>可行性分析定义：</h4><p>对需求内容进行初步的分析，确定解决问题的可能性，分析不同解决方案的优劣，并提出建议。其本质实际上就是一个粗略的系统分析和设计过程，通常由客户完成。<br>可行性研究的目的，就是用<strong>最小的代价</strong>在<strong>尽可能短的时间</strong>内确定问题是否能够解决<br>可行性研究的类型：</p><ol><li>研究型项目的可行性研究分析</li><li>委托型可行性研究分析</li><li>自主开发型可行性研究分析</li></ol><p>可行性研究分析过程：</p><ol><li>首先，进一步分析和澄清<strong>问题定义</strong></li><li>然后，分析员应该导出系统的<strong>逻辑模型</strong></li><li>最后，探索若干可供选择的<strong>主要解法</strong></li></ol><h4 id="可行性分析三个方面："><a href="#可行性分析三个方面：" class="headerlink" title="可行性分析三个方面："></a>可行性分析三个方面：</h4><ol><li>技术可行性</li><li>经济可行性</li><li>操作可行性</li></ol><p>技术可行性——使用现有的技术能实现这个系统吗?<br>经济可行性——这个系统的经济效益能超过它的开发成本吗?<br>操作可行性——系统的操作方式在这个用户组织内行得通吗?</p><h1 id="🍒03章-需求分析"><a href="#🍒03章-需求分析" class="headerlink" title="🍒03章 需求分析"></a>🍒03章 需求分析</h1><h4 id="需求分析定义："><a href="#需求分析定义：" class="headerlink" title="需求分析定义："></a>需求分析定义：</h4><p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答”系统必须做什么“这个问题。<br>需求分析的任务就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统“做什么”的问题。</p><h4 id="需求分析（面向过程）需要建立的三类模型："><a href="#需求分析（面向过程）需要建立的三类模型：" class="headerlink" title="需求分析（面向过程）需要建立的三类模型："></a>需求分析（面向过程）需要建立的三类模型：</h4><ol><li><strong>数据模型</strong>：主要采用实体联系图ERD图描述，描述数据对象及数据对象之间的关系</li><li><strong>功能模型</strong>：主要采用数据流图描述，描述当数据在软件系统中移动时被变换的逻辑过程，指明系统具有的变换数据的功能</li><li><strong>行为模型</strong>：采用状态转换图，指明了作为外部事件结果的系统行为。为此，状态转换图描述了系统各种行为模式（状态）和在不同状态间转换的方式</li></ol><h4 id="实体联系图定义："><a href="#实体联系图定义：" class="headerlink" title="实体联系图定义："></a>实体联系图定义：</h4><p>ER实体联系图，描述数据对象及数据对象之间的关系，是用于建立数据模型的图形<br>数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系</p><h4 id="数据流图定义："><a href="#数据流图定义：" class="headerlink" title="数据流图定义："></a>数据流图定义：</h4><p><strong>数据流图（DFD）</strong>是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换。<br>数据流图是建立功能模型的基础<br>数据流图让软件工程师能够建模同时建模信息模型和功能模型。</p><h4 id="加油站-x2F-数据流图："><a href="#加油站-x2F-数据流图：" class="headerlink" title="加油站&#x2F;数据流图："></a>加油站&#x2F;数据流图：</h4><p>0层：<br><img src="https://s1.ax1x.com/2023/05/13/p96c5gf.png#height=141&id=J84Ho&originHeight=282&originWidth=1147&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574"><br>1层：<br><img src="https://s1.ax1x.com/2023/05/13/p96c48P.png#height=304&id=XPhm2&originHeight=607&originWidth=1192&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=596"><br>2层：<br><img src="https://s1.ax1x.com/2023/05/13/p96cIv8.png#height=364&id=IZ83a&originHeight=727&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=693"><br>3层：<br><img src="https://s1.ax1x.com/2023/05/13/p96chCt.png#height=387&id=CaN22&originHeight=773&originWidth=1373&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=687"></p><h4 id="登录-x2F-状态转换图："><a href="#登录-x2F-状态转换图：" class="headerlink" title="登录&#x2F;状态转换图："></a>登录&#x2F;状态转换图：</h4><p>密码验证状态转换图<br><img src="https://s1.ax1x.com/2023/05/13/p96WurT.png#id=F2nKx&originHeight=519&originWidth=838&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="🍒05章-总体设计"><a href="#🍒05章-总体设计" class="headerlink" title="🍒05章 总体设计"></a>🍒05章 总体设计</h1><h4 id="总体设计定义："><a href="#总体设计定义：" class="headerlink" title="总体设计定义："></a>总体设计定义：</h4><p>总体设计的基本目的就是回答”概括地说，系统应该如何实现“这个问题，又叫<strong>概要设计</strong>、<strong>初步设计</strong><br>总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系</p><h4 id="模块的三个基本要素："><a href="#模块的三个基本要素：" class="headerlink" title="模块的三个基本要素："></a>模块的三个基本要素：</h4><ol><li><strong>功能</strong>：描述该模块实现什么功能</li><li><strong>逻辑</strong>：描述模块内部该怎么做</li><li><strong>状态</strong>：该模块使用时的环境和条件</li></ol><p><strong>模块化</strong>是为了使一个复杂的大型程序能被人的智力所管理，<strong>是软件应该具备的唯一属性</strong></p><h4 id="信息隐藏："><a href="#信息隐藏：" class="headerlink" title="信息隐藏："></a>信息隐藏：</h4><p>应该这样设计和确定模块，使得一个模块内包含的信息（过程、数据）对于不需要这些信息的模块来说，是不能访问的<br>每个模块的实现细节对于其他模块来说是隐蔽的，也就是说，模块中所包含的信息（包括数据和过程）不允许其他不需要这些信息的模块使用</p><h4 id="模块独立性："><a href="#模块独立性：" class="headerlink" title="模块独立性："></a>模块独立性：</h4><p>模块的独立程度可以由两个定性标准度量，这两个标准分别为：<strong>内聚和耦合</strong><br><strong>模块独立性</strong>，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他模块的接口是简单的<br><strong>耦合</strong>，是模块之间的互相连接的紧密程度的度量(非数标控外公内)<br><img src="https://s1.ax1x.com/2023/05/14/p9cYjAS.png#height=144&id=bWIbT&originHeight=288&originWidth=805&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=403"><br><strong>内聚</strong>，标志一个模块内各个元素彼此结合的紧密程度（功信通过时逻巧）<br><img src="https://s1.ax1x.com/2023/05/14/p9cYO78.png#height=144&id=jcZ9T&originHeight=288&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=410"><br>模块独立性的重要原因：</p><ol><li>有效的模块化（即具有独立的模块）的软件比较容易开发出来</li><li>独立的模块比较容易测试和维护</li></ol><h4 id="作用域、控制域："><a href="#作用域、控制域：" class="headerlink" title="作用域、控制域："></a>作用域、控制域：</h4><p><strong>模块的作用域应该在控制域之内</strong><br><strong>作用域</strong>：受该模块内一个判定影响的所有模块的集合<br><strong>控制域</strong>：模块本身以及所有直接或间接从属与它的模块的集合</p><h4 id="总体设计原则："><a href="#总体设计原则：" class="headerlink" title="总体设计原则："></a>总体设计原则：</h4><p>（莫愁逐藏巨毒）</p><ol><li>模块化</li><li>抽象</li><li>逐步求精</li><li>信息隐藏和局部化</li><li>模块独立</li></ol><h4 id="变换流，事务流定义："><a href="#变换流，事务流定义：" class="headerlink" title="变换流，事务流定义："></a>变换流，事务流定义：</h4><p>面向数据流的式设计方法把信息流映射成软件结构，信息流的类型决定了映射方法。<br><strong>变换流</strong>：信息沿输入通路进入系统，由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫做变换流<br><strong>事务流</strong>：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类数据流应该划分为一类特殊的数据流，称为事务流<br>T称为事务中心，它完成下述任务：接收输入数据（输入数据又称为事务）；分析每个事务以确定它的类型；根据事务类型选取一条活动通路</p><h4 id="格式化123-x2F-软件结构图："><a href="#格式化123-x2F-软件结构图：" class="headerlink" title="格式化123&#x2F;软件结构图："></a>格式化123&#x2F;软件结构图：</h4><p><img src="https://s1.ax1x.com/2023/05/13/p96RTKK.png#height=404&id=TG027&originHeight=808&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=675"></p><h1 id="🍒06章-详细设计"><a href="#🍒06章-详细设计" class="headerlink" title="🍒06章 详细设计"></a>🍒06章 详细设计</h1><h4 id="详细设计定义："><a href="#详细设计定义：" class="headerlink" title="详细设计定义："></a>详细设计定义：</h4><p>根本目标：确定应该怎样具体地实现所要求的系统。详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。<br>详细设计的结果基本上决定了最终的程序代码的质量。</p><ol><li>确定软件各个组成部分内的算法以及各部分的内部数据结构</li><li>选定某种过程的表达形式来描述各种算法</li><li>进行详细设计的评审</li></ol><h4 id="结构化程序的三种基本控制结构："><a href="#结构化程序的三种基本控制结构：" class="headerlink" title="结构化程序的三种基本控制结构："></a>结构化程序的三种基本控制结构：</h4><p>顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这3种基本控制结构，则称为<strong>经典的结构程序设计</strong></p><ol><li>顺序</li><li>选择</li><li>循环</li></ol><h1 id="🍒07章-实现"><a href="#🍒07章-实现" class="headerlink" title="🍒07章 实现"></a>🍒07章 实现</h1><h4 id="软件测试的原则："><a href="#软件测试的原则：" class="headerlink" title="软件测试的原则："></a>软件测试的原则：</h4><p>（需前 P小 穷三 早两 合检妥）</p><ol><li>所有测试都应该能追溯到用户需求</li><li>应该远在测试之前就制定出测试计划</li><li>把Pareto原理应用到软件测试中（测试存在群集现象）</li><li>该从“小规模”测试开始，并逐步进行“大规模”的测试</li><li>穷举测试是不可能的</li><li>为了达到最佳测试效果，应该由独立的第三方从事测试工作</li><li>应当把“尽早地和不断地进行软件测试”作为软件开发者的座右铭</li><li>测试用例应由测试输入数据和对应的预计输出结果这两部分组成</li><li>在设计测试用例时，应当包括合理的输入条件和不合理的输入条件</li><li>应当对每个测试结果做全面检查</li><li>妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便</li></ol><p>测试过程按4个步骤进行，即<strong>单元测试、集成测试、确认测试和系统测试</strong></p><h4 id="单元测试定义："><a href="#单元测试定义：" class="headerlink" title="单元测试定义："></a>单元测试定义：</h4><p>单元测试又称<strong>模块测试</strong>，是针对软件设计的最小单元——程序模块，进行<strong>正确性检验</strong>的测试工作。其目的在于发现各模块内部可能存在的各种差错（采用的方法主要是白盒测试）单元测试需要从模块内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。<br>在单元测试期间着重从以下5个方面对模块进行测试：<br>（摩羯局指错边）</p><ol><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件（最重要）</li></ol><h4 id="驱动程序："><a href="#驱动程序：" class="headerlink" title="驱动程序："></a>驱动程序：</h4><p>驱动程序是一个<strong>“主程序”</strong>，它<strong>接收测试数据</strong>，把这些数据传送给被测试的模块，并且印出有关的结果。</p><h4 id="白盒测试定义-x2F-类型-x2F-步骤："><a href="#白盒测试定义-x2F-类型-x2F-步骤：" class="headerlink" title="白盒测试定义&#x2F;类型&#x2F;步骤："></a>白盒测试定义&#x2F;类型&#x2F;步骤：</h4><p>白盒测试<strong>把测试对象看作一个透明的盒子</strong>，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<br>通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。因此白盒测试又称为<strong>结构测试或逻辑驱动测试</strong>。<br>类型：白盒测试的测试方法有代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径测试法、域测试、符号测试、Z路径覆盖、程序变异。<br>（带境节制罗录迂腐Z变）<br>其中运用最为广泛的是<strong>基本路径测试法</strong>。<br>白盒测试类型：</p><ol><li><strong>逻辑覆盖</strong></li></ol><p>（预判条件组合点边）</p><ol><li><strong>语句覆盖</strong>——选择足够多的测试数据，是被测程序中每个语句至少执行一次</li><li><strong>判定覆盖</strong>——分支覆盖，不仅每个语句必须至少执行一次，而且<strong>每个判定的每种可能的结果</strong>都应该至少执行一次，也就是每个判定的每个分支都至少执行一次</li><li><strong>条件覆盖</strong>——不仅每个语句至少执行一次，而且使<strong>判定表达式中的每个条件</strong>都取到各种可能的结果</li><li><strong>判定&#x2F;条件覆盖</strong>——选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</li><li><strong>条件组合覆盖</strong>——它要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。<strong>最强的，但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到</strong></li><li><strong>点覆盖</strong>——点覆盖标准和语句覆盖标准是相同的</li><li><strong>边覆盖</strong>——通常边覆盖和判定覆盖是一致的</li></ol><p>白盒测试技术：</p><ol><li><strong>基本路径测试</strong></li></ol><p>（流环线测）</p><ol><li>根据过程设计结果画出相应的<strong>流图</strong></li><li>计算流图的<strong>环形复杂度</strong></li><li>确定线性独立路径的基本集合</li><li>设计<strong>可强制执行基本集合中</strong>每条路径的测试用例</li><li><strong>条件测试</strong></li></ol><p>优点：容易度量条件的测试覆盖率； 程序内条件的测试覆盖率可指导附加测试的设计</p><ol start="3"><li><strong>循环测试</strong></li></ol><p>在结构化的程序中通常只有3种循环，即<strong>简单循环、串接循环和嵌套循环</strong></p><h4 id="黑盒测试方法："><a href="#黑盒测试方法：" class="headerlink" title="黑盒测试方法："></a>黑盒测试方法：</h4><p>这种方法是<strong>把测试对象看做一个黑盒子</strong>，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。黑盒测试又叫做<strong>功能测试或数据驱动测试</strong>。<br>黑盒测试技术：（等边错）</p><ol><li><strong>等价划分</strong></li></ol><p>等价划分把程序的输入域划分成若干个数据类，据此导出测试用例<br>使用等价划分法设计测试方案首先需要划分输入数据的等价类，为此需要研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类。<br>划分出等价类以后，根据等价类设计测试方案时主要使用下面两个步骤<br>(1)设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止<br>(2)设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止<br>注意，通常程序发现一类错误后就不再检查是否还有其他错误，因此，应使每个测试方案只覆盖一个无效的等价类</p><ol start="2"><li><strong>边界值分析</strong></li></ol><p>使用边界值分析方法设计测试方案首先应该确定边界情况，通常输入等价类和输出等价类的边界。选取的测试数据应该刚好<strong>等于、刚刚小于和刚刚大于</strong>边界值<br>通常设计测试方案时总是联合使用<strong>等价划分和边界值分析</strong>两种技术</p><ol start="3"><li><strong>错误推测</strong></li></ol><p>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h4 id="软件调试定义-x2F-步骤："><a href="#软件调试定义-x2F-步骤：" class="headerlink" title="软件调试定义&#x2F;步骤："></a>软件调试定义&#x2F;步骤：</h4><p>调试（也称为纠错）作为成功测试的后果出现，即<strong>调试是在测试发现错误之后排除错误的过程</strong>。<br>软件错误的外部表现和它的内在原因之间可能并没有明显的联系。调试就是把症状和原因联系起来的尚未被人深入认识的智力过程。<br>调试不是测试<br>调试过程从执行一个测试用例开始，评估测试结果，如果发现实际结果与预期结果不一致，则这种不一致就是一个症状，它表明在软件中存在着隐藏的问题。调试过程试图找出产生症状的原因，以便改正错误。<br><img src="https://s1.ax1x.com/2023/05/15/p9glxGn.png#height=318&id=c67qe&originHeight=636&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=396"><br><strong>调试途径：</strong></p><ol><li>蛮干法：最低效</li><li>回溯法：从发现症状的地方开始，人工沿程序的控制流往回追踪分析源程序代码，直到找出错误原因为止</li><li>原因排查法：对分查找法、归纳法和演绎法<ol><li>对分查找法：如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近“注入”这些变量的正确值，然后运行程序并检查所得到的输出。</li><li>归纳法：从个别现象推断出一般性结论的思维方法。使用这种方法调试程序时，首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设</li><li>演绎法：从一般原理或前提出发，经过排除和精化的过程推导出结论。采用这种方法调试程序时，首先设想出所有可能的出错原因，然后试图用测试来排除每一个假设的原因</li></ol></li></ol><h1 id="🍒08章-维护"><a href="#🍒08章-维护" class="headerlink" title="🍒08章 维护"></a>🍒08章 维护</h1><h4 id="软件维护定义-x2F-类型"><a href="#软件维护定义-x2F-类型" class="headerlink" title="软件维护定义&#x2F;类型"></a>软件维护定义&#x2F;类型</h4><p>所谓软件维护就是在软件<strong>已经交付使用</strong>之后，为了<strong>改正错误或满足新的需要</strong>而<strong>修改软件</strong>的过程。可以通过描述软件交付使用后可能进行的<strong>4</strong>项活动，具体地定义软件维护。<br>（改适完预）</p><ol><li><strong>改正性维护</strong>：在任何大型程序的使用期间，用户必然会发现程序错误，并且把他们遇到的问题报告给维护人员。把<strong>诊断和改正错误的过程</strong>称为改正性维护。</li><li><strong>适应性维护</strong>：<strong>第二项维护活动</strong>。适应性维护也就是为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动</li><li><strong>完善性维护</strong>：当一个软件系统顺利地运行时，常常出现第三项维护活动：在使用软件的过程中用户往往提出<strong>增加新功能或修改已有功能</strong>的建议，还可能提出一般性的改进意见。为了满足这类要求，需要进行<strong>完善性维护</strong>。这项维护活动通常占软件维护工作的<strong>大部分</strong></li><li><strong>预防性维护</strong>：当为了改进未来的<strong>可维护性</strong>或<strong>可靠性</strong>，或为了给<strong>未来的改进</strong>奠定更好的基础而修改软件时，出现了第四项维护活动。这项维护活动通常称为预防性维护，目前这项维护活动相对比较少</li></ol><p>上述4类维护活动都<strong>必须应用于整个软件配置</strong></p><h4 id="软件再工程定义-x2F-步骤"><a href="#软件再工程定义-x2F-步骤" class="headerlink" title="软件再工程定义&#x2F;步骤"></a>软件再工程定义&#x2F;步骤</h4><p>程序再工程是指<strong>通过对目标系统的检查和改造</strong>，其中包括设计恢复（库存目录分析）、再文档、逆向工程、程序和数据重构以及正向工程等一系列活动，旨在将逆向工程、重构和正向工程组合起来，<strong>将现存系统重新构造为新的形式，以开发出质量更高、维护性更好的软件</strong><br>典型的<strong>软件再工程过程模型</strong>如下图所示。在某些情况下这些活动以线性顺序发生，但也并非总是这样。例如，为了理解某个程序的内部工作原理，可能在文档重构开始之前必须先进行逆向工程<br><img src="https://s1.ax1x.com/2023/05/14/p9co54O.png#height=272&id=dCMkE&originHeight=542&originWidth=495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=248"></p><h1 id="🍒09章-面向对象方法学引论"><a href="#🍒09章-面向对象方法学引论" class="headerlink" title="🍒09章 面向对象方法学引论"></a>🍒09章 面向对象方法学引论</h1><h4 id="面向对象的统一软件开发过程的各阶段-里程碑"><a href="#面向对象的统一软件开发过程的各阶段-里程碑" class="headerlink" title="面向对象的统一软件开发过程的各阶段 里程碑"></a>面向对象的统一软件开发过程的各阶段 里程碑</h4><p>RUP中的软件生命周期在时间上被分解为四个顺序的阶段 </p><ol><li>初始阶段(Inception) （生命周期目标里程碑 ）</li><li>细化阶段(Elaboration)（生命周期结构里程碑） </li><li>构造阶段(Construction)（初始运行能力 ）</li><li>交付阶段(Transition)（产品发布里程碑）</li></ol><h4 id="关联，两种聚集关联定义"><a href="#关联，两种聚集关联定义" class="headerlink" title="关联，两种聚集关联定义"></a>关联，两种聚集关联定义</h4><ol><li><strong>关联</strong></li></ol><p>关联表示<strong>两个类的对象之间存在某种语义上的联系</strong></p><ol><li>普通关联</li><li>关联的角色</li><li>限定关联</li><li>关联类</li><li><strong>聚集</strong></li></ol><p>聚集也称为聚合，是关联的特例。聚集表示类与类之间的关系是<strong>整体与部分</strong>的关系。使用的“包含”、“组成”、“分为……部分”等字句，意味着存在聚集关系。有<strong>共享聚集</strong>和<strong>组合聚集</strong>两种特殊的聚集关系</p><ol><li>共享聚集</li></ol><p>如果在聚集关系中<strong>处于部分方的对象可同时参与多个处于整体方对象的构成</strong>，则该聚集称为共享聚集。一般聚集和共享聚集的关联关系用空心菱形表示。</p><ol start="2"><li>组合聚集</li></ol><p>如果<strong>部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失</strong>（或失去存在价值了），则该聚集称为组合聚集（简称为组成）。组合聚集的组成关系用实心菱形表示。</p><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>一幅用例图包含的模型元素有<strong>系统、行为者、用例及用例之间的关系</strong>。<br>图是自动售货机系统的用例图。图中的方框代表系统，椭圆代表用例（售货、供货和取货款是自动售货机系统的典型用例），线条人代表行为者，它们之间的连线表示关系<br><img src="https://s1.ax1x.com/2023/05/15/p9g87Kx.png#height=185&id=PncPi&originHeight=737&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=148"><br>一个用例是可以被行为者感受到的、系统的一个完整的功能。在UML中把用例定义成系统完成的一系列动作，动作的结果能被特定的行为者察觉到。这些动作除了完成系统内部的计算与工作外，还包括与一些行为者的通信。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是双向的。<br>用例具有下述特征：</p><ol><li>用例代表某些用户可见的功能，实现一个具体的用户目标。</li><li>用例总是被行为者启动的，并向行为者提供可识别的值。</li><li>用例必须是完整的。</li></ol><p>UML提供的用例图是进行需求分析和建立功能模型的强有力工具。</p><ul><li>使用UML的<strong>类图</strong>来建立<strong>对象模型</strong>，使用UML的<strong>状态图</strong>来建立<strong>动态模型</strong>，使用<strong>数据流图</strong>或UML的<strong>用例图</strong>来建立<strong>功能模型</strong>。在UML中把用用例图建立起来的系统模型称为<strong>用例模型</strong>。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图<strong>描述类及类与类之间的静态关系</strong>。类图是一种静态模型，它是创建其他UML图的基础。一个系统可以由多张类图来描述，一个类也可以出现在几张类图中</p><ul><li>UML描述属性的语法格式如下：</li></ul><p>可见性 属性名：类型名&#x3D;初值{性质串}</p><ul><li>服务也就是操作，UML描述操作的语法格式如下：</li></ul><p>可见性 操作名（参数表）： 返回值类型{性质串}</p><h1 id="🍒10章-面向对象分析"><a href="#🍒10章-面向对象分析" class="headerlink" title="🍒10章 面向对象分析"></a>🍒10章 面向对象分析</h1><h4 id="面向对象需要建立的三类模型"><a href="#面向对象需要建立的三类模型" class="headerlink" title="面向对象需要建立的三类模型"></a>面向对象需要建立的三类模型</h4><p>用面向对象方法开发软件，通常需要建立3种形式的模型，它们分别是：</p><ol><li><strong>描述系统数据结构的对象模型</strong></li></ol><p>对象模型是从系统的静态结构上描述系统的需求</p><ol start="2"><li><strong>描述系统控制结构的动态模型</strong></li></ol><p>动态模型是描述系统的交互行为的需求</p><ol start="3"><li><strong>描述系统功能的功能模型</strong></li></ol><p>功能模型表明的是系统中数据之间的依赖关系，以及有关的数据处理功能，一般采用数据流图描述<br>在任何情况下，<strong>对象模型</strong>始终都是最重要、最基本、最核心的。<br>面向对象建模得到的模型包含系统的3个要素，即<strong>静态结构</strong>（对象模型）、<strong>交互次序</strong>（动态模型）和<strong>数据变换</strong>（功能模型）。解决的问题不同，这3个子模型的重要程度也不同。</p><h4 id="对象模型的5个层次"><a href="#对象模型的5个层次" class="headerlink" title="对象模型的5个层次"></a>对象模型的5个层次</h4><p>复杂问题（大型系统）的对象模型通常由下述5个层次组成：<br>（主类结束符）<br><img src="https://s1.ax1x.com/2023/05/14/p9cTaxH.png#height=185&id=DZtVP&originHeight=369&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=404"></p><h4 id="软件重用定义"><a href="#软件重用定义" class="headerlink" title="软件重用定义"></a>软件重用定义</h4><p>两次或多次不同的软件开发过程中使用相同或相似软件元素的过程<br>重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使用。广义地说，软件重用可分为以下3个层次：</p><ol><li>知识重用</li><li>方法和标准的重用</li><li><strong>软件成分的重用</strong></li></ol><p>软件过程的增量模型<img src="https://s1.ax1x.com/2023/05/16/p92zhIe.png#height=374&id=i82C8&originHeight=748&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 课程总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程总结 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全技术——DES和RSA加密解密程序</title>
      <link href="/2023/05/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DES%E5%92%8CRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DES%E5%92%8CRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="🍹题目要求"><a href="#🍹题目要求" class="headerlink" title="🍹题目要求"></a>🍹题目要求</h1><p>用Java语言设计并实现DES和RSA加密解密程序。<br>利用实现的DES加密解密程序分别对字符串、文本、图像等数据进行加密和解密。<br>利用实现的RSA加密解密程序对文本加密和解密，并与DES算法进行效率对比。</p><h1 id="🍹算法思路"><a href="#🍹算法思路" class="headerlink" title="🍹算法思路"></a>🍹算法思路</h1><h2 id="🍬DES算法"><a href="#🍬DES算法" class="headerlink" title="🍬DES算法"></a>🍬DES算法</h2><p>数据加密标准（Data Encryption Standard，简称DES）是一种对称加密算法，于1977年由美国国家标准与技术研究院（NIST）正式发布。DES算法使用相同的密钥进行加密和解密操作。该算法基于分组密码设计原则，将明文分为固定大小（64位）的块，然后对每个块进行加密。DES使用一个56位的密钥，但其密钥长度实际上为64位（其中8位用于奇偶校验）。<br>DES加密算法的主要步骤如下：</p><ol><li><strong>初始置换</strong>：将64位明文输入块进行置换（重新排列）操作。初始置换表定义了明文位的重新排列规则。</li><li><strong>密钥处理</strong>：对于给定的56位密钥，使用密钥调度算法（key schedule）生成16个48位的子密钥，这些子密钥将在接下来的加密过程中使用。</li><li><strong>16轮迭代</strong>：DES算法进行16轮迭代操作，每轮迭代包括以下步骤： <ul><li><strong>扩展置换</strong>：将32位的右半部分进行扩展置换，得到一个48位的数据块。</li><li><strong>子密钥异或</strong>：将扩展后的数据块与对应轮的子密钥进行异或操作。</li><li><strong>S-盒替换</strong>：将异或后的48位数据块划分为8个6位的分组，然后使用8个S-盒（替换盒）将每个6位分组映射为4位的输出。S-盒的设计是DES安全性的关键。</li><li><strong>P-盒置换</strong>：将S-盒的输出进行P-盒置换，重新排列比特，得到一个32位的数据块。</li><li><strong>左右交换与混合</strong>：最后，将P-盒置换后的32位数据与输入的左半部分进行异或，得到下一轮迭代的右半部分。同时，本轮的右半部分变为下一轮的左半部分。</li></ul></li><li><strong>最终交换</strong>：在16轮迭代完成后，将最后一轮的左右半部分合并，并进行最终置换，即初始置换的逆置换，得到64位的密文输出。</li></ol><p>解密过程与加密过程类似，只需使用相同的密钥进行逆操作即可。注意，解密时使用的子密钥顺序与加密时相反。</p><h2 id="🍬RSA算法"><a href="#🍬RSA算法" class="headerlink" title="🍬RSA算法"></a>🍬RSA算法</h2><p>RSA加密算法是一种非对称加密算法，于1978年由Ron Rivest、Adi Shamir和Leonard Adleman提出，算法名称就是根据他们的名字首字母得来。非对称加密意味着加密和解密过程使用不同的密钥。在RSA算法中，有一对密钥：公钥和私钥。公钥用于加密数据，私钥用于解密数据。通常，公钥是公开的，任何人都可以用它加密数据；私钥是保密的，仅拥有者可以用它解密数据。<br>RSA加密算法的原理基于数论和大数计算。以下是算法的主要步骤：</p><ol><li>选择两个大质数 ${p}$ 和 ${q}$ 。</li><li>计算 ${n &#x3D; p\times q}$ 。 ${n}$ 用于构建公钥和私钥，是模数。</li><li>计算欧拉函数 ${\varphi(n) &#x3D; (p-1)(q-1)}$ 。</li><li>选择一个整数 ${e}$ ，使得 ${1 &lt; e &lt; \varphi(n)}$ ，且 ${e}$ 与 ${\varphi(n)}$ 互质 $ {(gcd(e, \varphi(n)) &#x3D; 1)} $ 。 ${e}$ 是公钥的一部分。</li><li>计算整数 ${d}$ ，使得 ${d ≡ e^{-1}(mod \varphi(n))}$ 。换句话说，找到一个数 ${d}$ ，满足 ${ed \equiv 1 (mod \varphi(n))}$ 。 ${d}$ 是私钥的一部分。</li><li>公钥为 $(n, e)$ ，私钥为 $(n, d)$ 。</li></ol><p>加密和解密的过程如下：</p><ol><li>加密：假设明文消息为 ${M(0 &lt; M &lt; n)}$，密文C可以通过以下公式计算： ${C ≡ M^e (mod n)}$。</li><li>解密：已知密文 ${C}$，明文消息 ${M}$可以通过以下公式计算： ${M ≡ C^d (mod n)}$。</li></ol><p>RSA算法的安全性依赖于大数因子分解的困难性，即随着密钥长度( ${n}$ 的位数)的增加，攻击难度呈指数级增长。给定 ${n}$ 的值，分解出 ${p}$ 和 ${q}$ 是非常困难的，特别是当 ${p}$ 和 ${q}$ 都是大质数时。目前，尚无已知的高效算法能够在合理时间内分解大数${n}$</p><h1 id="🍹实现思路"><a href="#🍹实现思路" class="headerlink" title="🍹实现思路"></a>🍹实现思路</h1><h2 id="🍬DES算法-1"><a href="#🍬DES算法-1" class="headerlink" title="🍬DES算法"></a>🍬DES算法</h2><ol><li>首先根据DES算法的具体步骤，定义每一步所需要使用的矩阵；</li><li>接着，根据DES算法的过程，定义在DES算法中会使用到的函数。特别要说明的是在本算法中，实现了任何长度的密钥加密，因此定义了publicstaticbyte[]DataFormat(byte[] data)来实现了对秘钥的扩展。</li><li>最后开始正式实现DES算法：<ol><li>定义publicstaticbyte[]DesEncrypt(byte[] des_data,int flag)其中，DesEncrypt方法接收待加密&#x2F;解密的数据和一个标志位flag，用于指示执行加密或解密操作。在方法内部，首先将传入的密钥和数据进行格式化处理，然后按照ECB模式对数据进行加解密操作。ECB模式是一种基础的分组密码加密模式，它将明文数据按照固定长度分组，并对每个分组进行加密处理。</li><li>接着，如果flag为0，则表示执行解密操作。此时需要去掉加密时产生的填充位，具体做法是从加密结果中读取最后一个分组的最后一个字节，该字节记录了填充的长度。然后根据填充长度计算出实际的解密数据长度，并将解密数据复制到decryptbytearray数组中返回。</li><li>最后，无论执行加密还是解密操作，result_data数组都会被返回。如果flag为1，则表示执行加密操作，返回加密结果；如果flag为0，则表示执行解密操作，返回解密结果。</li></ol></li></ol><ul><li>本算法实现了对字符串、文本、图像等数据的加密和解密。通过终端直接输入密钥和想要加密的字符串即可进行加密输出，在对应的文件夹中存入想要加密的文件，即可在解密，密文文件夹发现相应的加解密文件。</li></ul><h2 id="🍬RSA算法-1"><a href="#🍬RSA算法-1" class="headerlink" title="🍬RSA算法"></a>🍬RSA算法</h2><ol><li>首先，程序生成一个RSA密钥对：一个公钥和一个私钥。公钥用于加密，私钥用于解密。具体来说，程序通过Java的KeyPairGenerator类生成了一个1024位的RSA密钥对，并将其存储在HashMap中以便后续使用。</li><li>接下来，程序演示了如何使用模和指数来生成公钥和私钥。模是大质数的乘积，而指数是一个小质数。程序根据给定的模和指数生成了相应的公钥和私钥。</li><li>然后，程序演示了如何使用公钥加密一个明文。在加密过程中，程序首先使用Java的Cipher类创建了一个RSA实例，并将其初始化为加密模式。然后，程序计算出加密数据长度并将明文分成若干个块进行加密。最后，程序将所有加密后的块连接起来得到密文。</li><li>最后，程序演示了如何使用私钥解密密文。在解密过程中，程序首先使用Java的Cipher类创建了一个RSA实例，并将其初始化为解密模式。然后，程序将密文分成若干个块进行解密，并将所有解密后的块连接起来得到明文。</li></ol><h1 id="🍹运行结果"><a href="#🍹运行结果" class="headerlink" title="🍹运行结果"></a>🍹运行结果</h1><h2 id="🍬DES加密解密算法"><a href="#🍬DES加密解密算法" class="headerlink" title="🍬DES加密解密算法"></a>🍬DES加密解密算法</h2><p>在明文文件夹中存入以下文件：<br><img src="https://s1.ax1x.com/2023/05/12/p9yOdRU.png#id=pter0&originHeight=362&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>运行项目，输入密钥wxy0409，输入字符串2020218090，可以得到如下所示的结果：<br><img src="https://s1.ax1x.com/2023/05/12/p9yOUiV.png#id=Ca1u3&originHeight=449&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>可以看到经过DES加密和解密后的字符串与原来输入的字符串相同，同时在密文文件夹中出现了经过加密后的文件，在解密文件夹中出现如下所示的文件：<br><img src="https://s1.ax1x.com/2023/05/12/p9yOwzF.png#id=s2uGc&originHeight=366&originWidth=1059&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/12/p9yOBM4.png#id=chGSQ&originHeight=327&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><p>将加密前后的文件进行对比，可以发现本项目成果符合预期。<img src="https://s1.ax1x.com/2023/05/12/p9yOaGT.png#id=rMfTi&originHeight=346&originWidth=1706&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/12/p9yOrL9.png#id=ESzj3&originHeight=1156&originWidth=2240&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 33%;" /></p><p>test3和test4也与实验预期相符，这里不过多赘述。</p><h2 id="🍬RSA加密解密算法"><a href="#🍬RSA加密解密算法" class="headerlink" title="🍬RSA加密解密算法"></a>🍬RSA加密解密算法</h2><p>利用实现的RSA加密解密程序对文本加密和解密，因此这一部分直接在程序中定义了所要进行加解密的文本字符串，是编程更为简单。运行结果如下图所示：<br><img src="https://s1.ax1x.com/2023/05/12/p9yODsJ.png#id=fEnto&originHeight=430&originWidth=1857&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><h2 id="🍬RSA加密解密算法与DES算法进行效率对比"><a href="#🍬RSA加密解密算法与DES算法进行效率对比" class="headerlink" title="🍬RSA加密解密算法与DES算法进行效率对比"></a>🍬RSA加密解密算法与DES算法进行效率对比</h2><p>RSA 是一种公钥加密算法，其安全性基于大质数分解难题和离散对数难题。RSA 加密和解密速度较慢，计算复杂度高，适合对数据量较小、安全性要求较高的场合。RSA 算法可以用于数字签名、证书认证等方面。<br>DES 是一种对称加密算法，其安全性基于密钥长度。DES 加密和解密速度很快，计算复杂度低，适合对数据量较大、且对加密解密速度有要求的场合。DES 算法主要应用于数据加密通信、文件加密和存储等方面。<br>RSA 适合加密较小的数据，如密钥、数字签名等，而 DES 适合加密较大的数据，如文件传输等。在实际应用中，可以根据数据量大小、安全性要求和加密解密速度要求等因素综合考虑，选择合适的加密算法。</p><h1 id="🍹程序代码"><a href="#🍹程序代码" class="headerlink" title="🍹程序代码"></a>🍹程序代码</h1><p>程序代码已上传至Github</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF-DES%E5%92%8CRSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A8%8B%E5%BA%8F">Cassie&#x2F;信息安全技术-DES和RSA加密解密程序 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 课程作业 </category>
          
          <category> 信息安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 课程作业 </tag>
            
            <tag> 信息安全技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——入门模拟</title>
      <link href="/2023/05/08/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/"/>
      <url>/2023/05/08/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊入门模拟"><a href="#🎊入门模拟" class="headerlink" title="🎊入门模拟"></a>🎊入门模拟</h1><h2 id="🎀日期处理"><a href="#🎀日期处理" class="headerlink" title="🎀日期处理"></a>🎀日期处理</h2><p>一个二维数组int month[13][2]，用于存放每个月的天数，其中第二维为0表示平年，为1表示闰年<br>具体处理：当加了一天后天数d等于当前月份m所拥有的天数加1，那么月份m+1，同时置天数d为1；若此时月份m为13，则令年份加1，同时置月份m为1</p><h4 id="🎈scanf的用法"><a href="#🎈scanf的用法" class="headerlink" title="🎈scanf的用法"></a>🎈scanf的用法</h4><p>——要读入以下的数据，得到年月日（2019-10-3）因为里面有-字符所以你没有办法直接的把数据读进来scanf(“%d-%d-%d”,&amp;a,&amp;b,&amp;c);，这样你就可以得到年月日，也就是a，b，c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n%<span class="number">400</span>==<span class="number">0</span>|| (n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yyyy,mm,dd,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;yyyy,&amp;mm,&amp;dd);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a=n;</span><br><span class="line">    <span class="keyword">while</span>(a--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        dd--;</span><br><span class="line">        <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">            mm--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((mm)==<span class="number">0</span>)&#123;</span><br><span class="line">            mm=<span class="number">12</span>;yyyy--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">            dd=month[mm][<span class="built_in">year</span>(yyyy)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d&quot;</span>,yyyy,mm,dd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该题中，日月年的减法顺序是很重要的，需要考虑dd为0，mm为1的情况，此时需要跳转到前一年的最后一天</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闰则为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">400</span>==<span class="number">0</span>||(n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2加一天</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;yyyy,<span class="type">int</span> &amp;mm,<span class="type">int</span> &amp;dd)</span></span>&#123;</span><br><span class="line">    dd++;</span><br><span class="line">    <span class="keyword">if</span>(dd==month[mm][<span class="built_in">year</span>(yyyy)]+<span class="number">1</span>)&#123;</span><br><span class="line">        dd=<span class="number">1</span>;mm++;</span><br><span class="line">        <span class="keyword">if</span>(mm==<span class="number">13</span>)&#123;</span><br><span class="line">            mm=<span class="number">1</span>;yyyy++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2减一天</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;yyyy,<span class="type">int</span> &amp;mm,<span class="type">int</span> &amp;dd)</span></span>&#123;</span><br><span class="line">    dd--;</span><br><span class="line">    <span class="keyword">if</span>(dd==<span class="number">0</span>)&#123;</span><br><span class="line">        mm--;</span><br><span class="line">        <span class="keyword">if</span>(mm==<span class="number">0</span>)&#123;</span><br><span class="line">            mm=<span class="number">12</span>;yyyy--;</span><br><span class="line">        &#125;</span><br><span class="line">        dd=month[mm][<span class="built_in">year</span>(yyyy)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1则1比2大 2要加   0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> yyyy1,<span class="type">int</span> yyyy2,<span class="type">int</span> mm1,<span class="type">int</span> mm2,<span class="type">int</span> dd1,<span class="type">int</span> dd2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(yyyy1&gt;yyyy2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(yyyy1&lt;yyyy2)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mm1&gt;mm2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mm1&lt;mm2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dd1&gt;dd2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dd1&lt;dd2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> yyyy1=<span class="number">2020</span>,mm1=<span class="number">2</span>,dd1=<span class="number">28</span>,w=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> yyyy2,mm2,dd2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;yyyy2,&amp;mm2,&amp;dd2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">1</span>)&#123;<span class="comment">//1大 日期2要加1  星期要减1</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(yyyy2,mm2,dd2);</span><br><span class="line">            w=(w<span class="number">-1</span>+<span class="number">7</span>)%<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">compare</span>(yyyy1,yyyy2,mm1,mm2,dd1,dd2)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sub</span>(yyyy2,mm2,dd2);</span><br><span class="line">            w=(w+<span class="number">1</span>)%<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知一个日期是周几，求输入日期的星期数——根据两个日期间的差值求<br>所给日期与当前日期的关系一定要搞清楚！</p><h2 id="🎀进制转换"><a href="#🎀进制转换" class="headerlink" title="🎀进制转换"></a>🎀进制转换</h2><h4 id="🎈将P进制数x转换为十进制数y"><a href="#🎈将P进制数x转换为十进制数y" class="headerlink" title="🎈将P进制数x转换为十进制数y"></a>🎈将P进制数x转换为十进制数y</h4><p>P进制数x为a1a2…an，可以得到十进制数y<br><img src="https://cdn.nlark.com/yuque/__latex/4220159adf7f91c5edf9407589658aef.svg#card=math&code=y%3Da_%7B1%7D%20%2A%20P%5E%7Bn-1%7D%2Ba_%7B2%7D%20%2A%20P%5E%7Bn-2%7D%2B%5Ccdots%2Ba_%7Bn-1%7D%20%2A%20P%2Ba_%7Bn%7D&id=DjBLp"><br>可以利用循环代码实现上述公式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">0</span>, product = <span class="number">1</span>;<span class="comment">//product每次都乘p</span></span><br><span class="line"><span class="keyword">while</span>(x! = <span class="number">0</span>)&#123;</span><br><span class="line">    y = y + (x % <span class="number">10</span>) * product;<span class="comment">//x%10获取x的个位数</span></span><br><span class="line">    x = x/<span class="number">10</span>;</span><br><span class="line">    product = product * p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🎈将十进制数y转换为P进制数z"><a href="#🎈将十进制数y转换为P进制数z" class="headerlink" title="🎈将十进制数y转换为P进制数z"></a>🎈将十进制数y转换为P进制数z</h4><p>采用“除基取余法”，基为将要转化为的进制Q，得到的余数作为低位存储</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> z[<span class="number">40</span>],num = <span class="number">0</span>;<span class="comment">//num为位数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num++] = y % Q;<span class="comment">//除基取余</span></span><br><span class="line">    y = y/Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y != <span class="number">0</span>)<span class="comment">//当商不为0时进行循环</span></span><br></pre></td></tr></table></figure><p>z数组从高位z[num–]到低位z[0]即为Q进制z</p><h2 id="🎀字符串处理"><a href="#🎀字符串处理" class="headerlink" title="🎀字符串处理"></a>🎀字符串处理</h2><p><strong>难题1：</strong><br>给定n个字符串，求它们的公共前缀。<br>——如何获取输入的数值和如何比较公共前缀是本题的两大重点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">51</span>;</span><br><span class="line"><span class="type">char</span> str[MAXN][MAXL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, minL = MAXL;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="comment">//千万不能漏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin.<span class="built_in">getline</span>(str[i], MAXL);<span class="comment">//不要忘记这种读取一行字符串的方式</span></span><br><span class="line">        minL = <span class="built_in">min</span>(minL, (<span class="type">int</span>)<span class="built_in">strlen</span>(str[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; minL; j++) &#123;</span><br><span class="line">        <span class="type">bool</span> isSame = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i][j] != str[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                isSame = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[<span class="number">0</span>][j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>难题2：</strong><br>按从左到右字符出现的顺序，输出每个字符连续出现的个数。<br>其中每个字符输出一行，每行以空格为分隔，输出该字符与出现的个数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(str,<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==str[i+<span class="number">1</span>]&amp;&amp;i+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">            i++;num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>——不要把简单问题想复杂了，所求是连续字符的个数，完全不需要使用二维数组</p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++算法笔记——基础知识</title>
      <link href="/2023/05/05/C-C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/05/C-C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="🎊基础知识"><a href="#🎊基础知识" class="headerlink" title="🎊基础知识"></a>🎊基础知识</h1><h2 id="🎀if-else"><a href="#🎀if-else" class="headerlink" title="🎀if-else"></a>🎀if-else</h2><p>使用如下方式而不使用if-else，更为简便清晰</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(a &gt;= b ? <span class="string">&quot;A &gt;= B&quot;</span> : <span class="string">&quot;A &lt; B&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="🎀getchar函数"><a href="#🎀getchar函数" class="headerlink" title="🎀getchar函数"></a>🎀getchar函数</h2><p>用来输入单个字符，因此需要注意换行符的存在，可以使用getchar()来读取换行符</p><h2 id="🎀数学函数的使用"><a href="#🎀数学函数的使用" class="headerlink" title="🎀数学函数的使用"></a>🎀数学函数的使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span> <span class="comment">//头文件 </span></span></span><br><span class="line"><span class="built_in">fabs</span>(a):a的绝对值</span><br><span class="line"><span class="built_in">floor</span>(a):a的向下取整</span><br><span class="line"><span class="built_in">ceil</span>(a):a的向上取整</span><br><span class="line"><span class="built_in">round</span>(a):a的四舍五入(四舍六入五成双)</span><br><span class="line"><span class="built_in">pow</span>(a,b):a的b次方,b可以为浮点型</span><br><span class="line"><span class="built_in">sqrt</span>(a):a的算术平方根(开根号)</span><br><span class="line"><span class="built_in">log</span>(a):a的以自然对数e为底的对数</span><br></pre></td></tr></table></figure><h2 id="🎀switch-case语句格式"><a href="#🎀switch-case语句格式" class="headerlink" title="🎀switch-case语句格式"></a>🎀switch-case语句格式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常数表达式<span class="number">1</span>：</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常数表达式<span class="number">2</span>：</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀continue语句"><a href="#🎀continue语句" class="headerlink" title="🎀continue语句"></a>🎀continue语句</h2><p>和break类似，continue也是用在循环当中，但区别是break语句执行后循环就被彻底退出，而continue则只是跳过当前这一轮，继续进行下一轮，并不是停止循环，所以很适合在满足某些条件需要不执行循环体内容时使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀比较两数大小"><a href="#🎀比较两数大小" class="headerlink" title="🎀比较两数大小"></a>🎀比较两数大小</h2><p>C语言快速比较两数大小——<strong>fmax，fmin函数</strong><br>头文件include&lt;math.h&gt;，作用是返回两个浮点参数中较大的一个</p><h2 id="🎀冒泡排序"><a href="#🎀冒泡排序" class="headerlink" title="🎀冒泡排序"></a>🎀冒泡排序</h2><p>——本质在于交换，每趟将最大或者最小值移到最后</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//比较趟数，n个数共比较n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//a[0]到a[n-i-1]都与他们的下一个数进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>交换两个数可以用#include<algorithm>中的swap（a,b）</p><h2 id="🎀memset函数"><a href="#🎀memset函数" class="headerlink" title="🎀memset函数"></a>🎀memset函数</h2><p>——头文件#include&lt;string.h&gt;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,值,<span class="built_in">sizeof</span>(数组名));</span><br></pre></td></tr></table></figure><p>一般只建议用memset函数赋值0和-1——memset按照字节赋值，赋值其他数字可以用fill</p><h2 id="🎀字符数组"><a href="#🎀字符数组" class="headerlink" title="🎀字符数组"></a>🎀字符数组</h2><p>char型字符数组的长度比事迹存储字符串的长度至少多1（结束符\0）<br>如果不是使用scanf函数或gets函数输入字符串（如getchar），一定要加入\0，否则会乱码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=<span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>输出和输出——%c用来输入单个字符，%s用来输入一个字符串并存在字符数组中。</li></ul><p>%c格式能够识别空格跟换行并将其输入，%s通过空格或换行来识别一个字符串的结束。<br><strong>scanf在使用%s不需要&amp;取地址</strong></p><ul><li>getchar()输入，putchar()输出单个字符</li></ul><p>str[i][j]&#x3D;getchar() putchar(str[i][j])   注意：<strong>每行末尾有换行符</strong>,有需要的需要通过gets()或getchar()来处理换行符</p><ul><li><strong>gets(str)输入</strong>和puts()输出一行字符串</li></ul><p>gets()识别\n作为输入结束，<strong>puts()输出自带\n换行</strong>，比printf(“%s\n”,str[i]);更便捷</p><ul><li>字符数组的整行输入</li></ul><p>在比较早的C&#x2F;C++版本中，经常可以看到推荐使用gets函数来进行整行字符串的输入，就像下面这样的简单写法即可输入一整行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gets</span>(str);</span><br></pre></td></tr></table></figure><p>但是当输入的字符串长度超过数组长度上限MAX_LEN时，gets函数会把超出的部分也一并读进来，并且会覆盖数组之外的内存空间，这就导致了一定的安全风险，因此C++11标准将gets函数废弃了，然后在C++14时将该函数移除，如果现在想要整行输入的话，推荐使用cin.getline函数；而在C语言标准中gets函数则是在C11时被移除，与此同时增加了gets_s函数，除此之外还有fgets函数可供选择。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namesapce std;</span><br><span class="line">cin.<span class="built_in">getline</span>(str, MAX_LEN);<span class="comment">//第一个参数为字符数组，第二个参数是最大允许读入的字符个数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gets_s(str, MAX_LEN);</span><br></pre></td></tr></table></figure><h3 id="🎈string-h头文件"><a href="#🎈string-h头文件" class="headerlink" title="🎈string.h头文件"></a>🎈string.h头文件</h3><p>strlen()函数——得到字符数组中第一个\0前的字符个数<br>strcmp()函数——返回字符串大小的比较结果，比较原则”字典序”<br>strcmp(str1,str2)——str1&lt;str2返回一个负整数；str1&#x3D;str2返回0；str1&gt;str2返回一个正整数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strcpy()函数——把一个字符串复制给另一个字符串<br>strcpy(str1,str2)——把字符数组2复制给字符数组1，包括\0<br>strcat()函数——把一个字符串接到另一个字符串后面<br>strcat(str1,str2)——把字符数组2接到字符数组1后面</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    cin &gt;&gt; s2;</span><br><span class="line">    cout &lt;&lt; s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈sscanf与springf"><a href="#🎈sscanf与springf" class="headerlink" title="🎈sscanf与springf"></a>🎈sscanf与springf</h3><p>假定一个char数组str[100]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="comment">//把字符数组str中的内容以%d的形式写到n中</span></span><br><span class="line"><span class="comment">//成功返回参数的数目，失败则返回0</span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="comment">//把n以%d的格式写到字符数组str中</span></span><br></pre></td></tr></table></figure><p>%04d可以输出四位数，不够则前面用0补全，与%.2f有异曲同工之处</p><h2 id="🎀Max值"><a href="#🎀Max值" class="headerlink" title="🎀Max值"></a>🎀Max值</h2><p>求三个数中的最大值，不仅可以自定义函数，也可如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(&#123;a, b, c&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀指针"><a href="#🎀指针" class="headerlink" title="🎀指针"></a>🎀指针</h2><p>获得变量的地址——取地址运算符&amp;</p><h3 id="🎈指针变量"><a href="#🎈指针变量" class="headerlink" title="🎈指针变量"></a>🎈指针变量</h3><p>指针变量用来存放指针（可以理解为地址）——int* p;<br>（一次有好几个同种类型的指针变量 要同时定义，星号只会结合第一个变量名）<br>给指针变量赋值的方式——把变量的地址取出来，然后赋给对应类型的指针变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="comment">//(int*)是指针变量的类型 p才是变量名</span></span><br><span class="line">*p = a的值</span><br><span class="line"><span class="comment">//*作为开启房间的钥匙，放在p的前面，这样*p就可以获取到房间里的东西，即存储的数据</span></span><br><span class="line"><span class="comment">//直接对*p进行赋值，也可以起到改变那个保存的元素的功能</span></span><br></pre></td></tr></table></figure><p>指针变量p+1——p所指的int型变量的下一个int型变量地址（也支持++,–操作）</p><h3 id="🎈指针与数组"><a href="#🎈指针与数组" class="headerlink" title="🎈指针与数组"></a>🎈指针与数组</h3><p>对于数组，可以在元素前面加取地址运算符&amp;来获取它的地址，例如a[0]的地址为&amp;a[0]，即数组a的首地址为&amp;a[0]<br>在C语言中，数组名称也作为数组的首地址使用，a&#x3D;&#x3D;&amp;a[0]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);<span class="comment">//a+i等同于&amp;a[i]——数组a的首地址偏移i个int型变量的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(a+i));<span class="comment">//a+i只是一个地址，要想访问其中的元素，还是需要*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针变量可以自增操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span>* p = a; p &lt; a+<span class="number">10</span>; p++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎈使用指针变量作为函数参数"><a href="#🎈使用指针变量作为函数参数" class="headerlink" title="🎈使用指针变量作为函数参数"></a>🎈使用指针变量作为函数参数</h3><p>指针类型也可以作为函数参数的类型，这时视为把变量的地址传入函数。如果在函数中对这个地址中的元素进行改变，原先的数据就会确实地被改变。</p><ul><li>使用指针进行两个数的交换</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span>* temp;</span><br><span class="line">    <span class="comment">//在定义temp时，temp没有被初始化，此时temp中存放的地址是随机的，很有可能出错</span></span><br><span class="line">    <span class="comment">/*可以给temp赋个初值</span></span><br><span class="line"><span class="comment">int x;int* temp = &amp;x;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    *temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法二</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="comment">//直接交换两个数的地址，在swap函数中交换后，在main函数中实际并未交换</span></span><br><span class="line">    <span class="comment">//传入swap中的只是a和b的地址，无符号整型的数字而已，并不能实现main函数中的双向交换</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数参数的传送方式是单向一次性的</span></span><br></pre></td></tr></table></figure><h3 id="🎈引用"><a href="#🎈引用" class="headerlink" title="🎈引用"></a>🎈引用</h3><p>——在函数中想要修改传入的参数，但又不想使用指针<br>引用不产生副本，只是给变量起了个别名，对引用变量的操作就是对原变量的操作（取一个小名）</p><ul><li>在函数参数类型后面加一个&amp;即可</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;<span class="comment">//不需要return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(a);<span class="comment">//a=10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把引用的&amp;和取地址运算符&amp;区分开来，引用≠取地址</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>&#123;<span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对指针本身的修改无法作用到原指针变量上</span></span><br><span class="line"><span class="comment">//可以通过指针的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* &amp;a,<span class="type">int</span>* &amp;b)</span></span>&#123;<span class="comment">//交换</span></span><br><span class="line">    <span class="type">int</span>* temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎀结构体（struct）的使用"><a href="#🎀结构体（struct）的使用" class="headerlink" title="🎀结构体（struct）的使用"></a>🎀结构体（struct）的使用</h2><h3 id="🎈结构体的定义"><a href="#🎈结构体的定义" class="headerlink" title="🎈结构体的定义"></a>🎈结构体的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Name</span>&#123;</span><br><span class="line"><span class="comment">//一些基本的数据结构或者自定义的数据类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> gender;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;Alice,Bob,stu[<span class="number">1000</span>];<span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="comment">//也可以</span></span><br><span class="line">studentInfo Alice;</span><br><span class="line">studentInfo stu[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure><p>结构体里面不能定义自身，但可以定义自身类型的指针变量 studentInfo* next;——√</p><h3 id="🎈访问结构体内的元素"><a href="#🎈访问结构体内的元素" class="headerlink" title="🎈访问结构体内的元素"></a>🎈访问结构体内的元素</h3><p>访问结构体内的元素——“.”操作和“-&gt;”操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">studentInfo* next;</span><br><span class="line">&#125;stu,*p;<span class="comment">//普通变量stu和指针变量p</span></span><br><span class="line">——访问stu变量</span><br><span class="line">stu.id</span><br><span class="line">stu.name</span><br><span class="line">stu.next</span><br><span class="line">——访问指针变量p中的元素</span><br><span class="line">(*p).<span class="built_in">id</span></span><br><span class="line">(*p).<span class="built_in">name</span></span><br><span class="line">(*p).next</span><br><span class="line">——访问结构体指针变量内元素的更简洁的方法</span><br><span class="line">p-&gt;id</span><br><span class="line">p-&gt;name</span><br><span class="line">p-&gt;next</span><br></pre></td></tr></table></figure><h3 id="🎈结构体的初始化"><a href="#🎈结构体的初始化" class="headerlink" title="🎈结构体的初始化"></a>🎈结构体的初始化</h3><p>构造函数的方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//下面的参数用以对结构体内部变量进行赋值</span></span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id,<span class="type">char</span> _gender)&#123;</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        id = _id;</span><br><span class="line">        gender = _gender;</span><br><span class="line">    <span class="comment">//也可以</span></span><br><span class="line">    <span class="built_in">studentInfo</span>(<span class="type">int</span> _id,<span class="type">int</span> _gender):<span class="built_in">id</span>(_id),<span class="built_in">gender</span>(_gender)&#123;&#125;</span><br><span class="line">    <span class="built_in">studentInfo</span>()&#123;&#125;;</span><br><span class="line"><span class="built_in">studentInfo</span>(<span class="type">int</span> _id):<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">studentInfo stu = <span class="built_in">studentInfo</span>(<span class="number">10086</span>,<span class="string">&#x27;M&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了既能不初始化就定义结构变量，又能享受初始化带来的便捷，可以手动加上默认的生成函数，也可以定义参数个数和类型不完全相同的构造函数</p><h2 id="🎀补充"><a href="#🎀补充" class="headerlink" title="🎀补充"></a>🎀补充</h2><h3 id="🎈cin和cout"><a href="#🎈cin和cout" class="headerlink" title="🎈cin和cout"></a>🎈cin和cout</h3><p>——#include<iostream> using namespace std;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;<span class="comment">//endl表示换行</span></span><br></pre></td></tr></table></figure><p>保留小数setprecision（n）的用法<br>——头文件#include<iomanip><br>cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;d;</p><h2 id="🎀黑盒测试"><a href="#🎀黑盒测试" class="headerlink" title="🎀黑盒测试"></a>🎀黑盒测试</h2><h3 id="🎈单点测试"><a href="#🎈单点测试" class="headerlink" title="🎈单点测试"></a>🎈单点测试</h3><h3 id="🎈多点测试"><a href="#🎈多点测试" class="headerlink" title="🎈多点测试"></a>🎈多点测试</h3><ol><li>三种输入方式</li></ol><ul><li><strong>while…EOF型</strong></li></ul><p>题目<strong>没有给定输入的结束条件</strong>，默认读取到文件末尾</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)!=EOF)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入字符串</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">gets</span>(str)!=<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;str)!=EOF)&#123;&#125;</span><br></pre></td></tr></table></figure><p>只要scanf的返回值不为EOF（文件中的数据没有读完）就反复读入a，执行while中的内容</p><ul><li><strong>while…break型</strong></li></ul><p>题目要求当<strong>输入的数据满足某个条件</strong>时，停止输入<br><strong>w</strong>hile…EOF型的衍生</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简略写法</span></span><br><span class="line"><span class="comment">//a和b中有一个不为0就进行循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b),a||b)&#123;<span class="comment">//a!=0||b!=0</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>while（T–）型</strong></li></ul><p>题目会给出测试数据的组数，接着才给出相应数量组数的输入数据</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>三种输出方法</li></ol><ul><li><strong>正常输出</strong></li><li><strong>每组数据输出后都要额外加一个空行</strong></li><li><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机类专业创新实践——家乡静态网页制作</title>
      <link href="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B8%93%E4%B8%9A%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%AE%B6%E4%B9%A1%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B8%93%E4%B8%9A%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%AE%B6%E4%B9%A1%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="🥑主要内容"><a href="#🥑主要内容" class="headerlink" title="🥑主要内容"></a>🥑主要内容</h1><h2 id="🍨内容设计"><a href="#🍨内容设计" class="headerlink" title="🍨内容设计"></a>🍨内容设计</h2><ol><li>设计主页面、城市介绍、美食介绍和网站作者四个界面以组成家乡美食介绍网页。</li><li>每个页面上方都配有导航栏，左边“苏州”按键和右边三个分页面的按钮。</li><li>主页面主要由标题、小标题和跳转按钮组成；</li><li>城市介绍页面主要由段落文字和视频组成；</li><li>美食介绍页面主要由六小段文字以及其对应图片和一个音乐播放功能键组成；</li><li>网站作者页面主要由头像图片以及其对应文字组成。</li></ol><h2 id="🍨功能设计"><a href="#🍨功能设计" class="headerlink" title="🍨功能设计"></a>🍨功能设计</h2><ol><li>导航栏由左侧“苏州”按钮——可实现跳转到主页面的动作，右侧三个按钮可实现对各页面之间的跳转。</li><li>主页面点击圆形按钮即可跳转至第一个分页面——城市介绍，同时也可通过导航栏右侧的三个按钮跳转至对应的页面；</li><li>城市页面——刚点进该页面时对左侧图片实现压缩弹跳功能，并在其右侧附加一段介绍文字；下方增加视频播放功能，链接至bilibili苏州介绍视频；最后一个板块实现该页面向外界网站如微博、百度、bilibili中有关苏州介绍的网址链接；</li><li>美食页面——由六个小方框构成，每个小方框都实现左图加文字的展现形式，并对图片加以弹跳动作；在导航栏中间添加视频播放按钮；</li><li>网站作者——由圆角框构成文字以及图片展示平台，并在刚点进该页面时对头像logo实现缩小放大跳跃功能。</li></ol><h1 id="🥑题目"><a href="#🥑题目" class="headerlink" title="🥑题目"></a>🥑题目</h1><p>前端页面设计（HTML CSS）——家乡风土习俗介绍等（在制作过程中主要侧重家乡美食）</p><h1 id="🥑需求分析与设计"><a href="#🥑需求分析与设计" class="headerlink" title="🥑需求分析与设计"></a>🥑需求分析与设计</h1><h2 id="🍨需求分析"><a href="#🍨需求分析" class="headerlink" title="🍨需求分析"></a>🍨需求分析</h2><h3 id="🍵内容分析"><a href="#🍵内容分析" class="headerlink" title="🍵内容分析"></a>🍵内容分析</h3><ol><li>应设计主页界面主要介绍本网页所介绍的城市，同时增加导入按钮增加美观性；</li><li>在每个网页的上方设置导航栏，点击即可跳转到相应的网页，使交互更加快捷；</li><li>增加网站作者网页，使网页整体化。</li></ol><h3 id="🍵功能分析"><a href="#🍵功能分析" class="headerlink" title="🍵功能分析"></a>🍵功能分析</h3><ol><li>应设置导航栏，点击即可跳转到相应的模块；</li><li>在城市介绍部分插入相关视频，使界面更生动，表达形式更丰富；</li><li>对页面上的图片可以设计抖动等行为，在页面适当增加音乐模块，使页面更生动；</li><li>整体界面应该简洁美观，便于观看。</li></ol><h2 id="🍨系统设计"><a href="#🍨系统设计" class="headerlink" title="🍨系统设计"></a>🍨系统设计</h2><h3 id="🍵内容设计"><a href="#🍵内容设计" class="headerlink" title="🍵内容设计"></a>🍵内容设计</h3><ol><li>设计主页面、城市介绍、美食介绍和网站作者四个界面以组成家乡美食介绍网页。</li><li>每个页面上方都配有导航栏，左边“苏州”按键和右边三个分页面的按钮。</li><li>主页面主要由标题、小标题和跳转按钮组成；</li><li>城市介绍页面主要由段落文字和视频组成；</li><li>美食介绍页面主要由六小段文字以及其对应图片和一个音乐播放功能键组成；</li><li>网站作者页面主要由头像图片以及其对应文字组成。</li></ol><h3 id="🍵功能设计"><a href="#🍵功能设计" class="headerlink" title="🍵功能设计"></a>🍵功能设计</h3><ol><li>导航栏由左侧“苏州”按钮——可实现跳转到主页面的动作，右侧三个按钮可实现对各页面之间的跳转。</li><li>主页面点击圆形按钮即可跳转至第一个分页面——城市介绍，同时也可通过导航栏右侧的三个按钮跳转至对应的页面；</li><li>城市页面——刚点进该页面时对左侧图片实现压缩弹跳功能，并在其右侧附加一段介绍文字；下方增加视频播放功能，链接至bilibili苏州介绍视频；最后一个板块实现该页面向外界网站如微博、百度、bilibili中有关苏州介绍的网址链接；</li><li>美食页面——由六个小方框构成，每个小方框都实现左图加又文字的展现形式，并对图片加以弹跳动作；在导航栏中间添加视频播放按钮；</li><li>网站作者——由圆角框构成文字以及图片展示平台，并在刚点进该页面时对头像logo实现缩小放大跳跃功能。</li></ol><h3 id="🍵代码设计"><a href="#🍵代码设计" class="headerlink" title="🍵代码设计"></a>🍵代码设计</h3><ol><li>HTML是用来在内容组织上告诉浏览器该如何显示其中的内容。</li><li>CSS是用来对内容样式美化展示上，负责HTML页面中元素的展现及排版。</li><li>JS使静态的HTML具有一定的交互行为动画特效等。</li></ol><h1 id="🥑系统实现与使用方法"><a href="#🥑系统实现与使用方法" class="headerlink" title="🥑系统实现与使用方法"></a>🥑系统实现与使用方法</h1><h2 id="🍨系统开发环境"><a href="#🍨系统开发环境" class="headerlink" title="🍨系统开发环境"></a>🍨系统开发环境</h2><h3 id="🍵处理器及设备"><a href="#🍵处理器及设备" class="headerlink" title="🍵处理器及设备"></a>🍵处理器及设备</h3><p><img src="https://s2.loli.net/2023/05/23/RuFmcfN4lBOvw3r.png#height=271&id=JtDJA&originHeight=542&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=552"></p><h3 id="🍵开发软件"><a href="#🍵开发软件" class="headerlink" title="🍵开发软件"></a>🍵开发软件</h3><p><img src="https://s2.loli.net/2023/05/23/4eLUWSZkhGRlPXo.png#height=185&id=wSInn&originHeight=369&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=474"></p><h2 id="🍨系统界面简介"><a href="#🍨系统界面简介" class="headerlink" title="🍨系统界面简介"></a>🍨系统界面简介</h2><p>主界面——由标题、小标题和跳转按钮和上方导航栏组成；<br><img src="https://s2.loli.net/2023/05/23/zco1P7S9pMVjvrX.png#height=609&id=N7YVr&originHeight=1217&originWidth=1816&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=908"><br>城市介绍界面——城市介绍页面主要分为三个部分；介绍、视频、网页链接；<br><img src="https://s2.loli.net/2023/05/23/JbGPtmj31RdZ2Is.png#height=1012&id=JMAot&originHeight=2023&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br>美食介绍界面——由六小段文字以及其对应图片和一个音乐播放功能键组成；<br><img src="https://s2.loli.net/2023/05/23/TO132nvUCJVHNoG.jpg#height=751&id=EFGij&originHeight=1500&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br>网站作者页面——由头像图片以及其对应文字组成。<br><img src="https://s2.loli.net/2023/05/23/JLg98X5nMA1yafZ.png#height=491&id=UVCNg&originHeight=982&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"></p><h2 id="🍨系统功能模块简介"><a href="#🍨系统功能模块简介" class="headerlink" title="🍨系统功能模块简介"></a>🍨系统功能模块简介</h2><ol><li>导航栏由左侧“苏州”按钮——可实现跳转到主页面的动作，右侧三个按钮可实现对各页面之间的跳转。</li><li>主页面点击圆形按钮即可跳转至第一个分页面——城市介绍，同时也可通过导航栏右侧的三个按钮跳转至对应的页面；</li><li>城市页面——刚点进该页面时对左侧图片实现压缩弹跳功能，并在其右侧附加一段介绍文字；下方增加视频播放功能，链接至bilibili苏州介绍视频；最后一个板块实现该页面向外界网站如微博、百度、bilibili中有关苏州介绍的网址链接；</li><li>美食页面——由六个小方框构成，每个小方框都实现左图加又文字的展现形式，并对图片加以弹跳动作；在导航栏中间添加视频播放按钮；</li><li>网站作者——由圆角框构成文字以及图片展示平台，并在刚点进该页面时对头像logo实现缩小放大跳跃功能。</li></ol><h2 id="🍨使用手册"><a href="#🍨使用手册" class="headerlink" title="🍨使用手册"></a>🍨使用手册</h2><p>通过“index.html”文件即可进入家乡主页，通过选择各个按钮即可实现页面之间的跳转，具体操作细则见功能模块介绍。</p><h1 id="🥑运行实例与系统功能测试"><a href="#🥑运行实例与系统功能测试" class="headerlink" title="🥑运行实例与系统功能测试"></a>🥑运行实例与系统功能测试</h1><h2 id="🍨系统功能测试"><a href="#🍨系统功能测试" class="headerlink" title="🍨系统功能测试"></a>🍨系统功能测试</h2><h2 id="🍨系统功能测试-1"><a href="#🍨系统功能测试-1" class="headerlink" title="🍨系统功能测试"></a>🍨系统功能测试</h2><h3 id="🍵"><a href="#🍵" class="headerlink" title="🍵****"></a>🍵**<meta name="viewport" content="width=device-width,initial-scale=1.0">**</h3><p>content属性值 :<br>width:可视区域的宽度，值可为数字或关键词device-width<br>height:同width<br>intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放<br>maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0;可视区域的缩放级别，<br>maximum-scale用户可将页面放大的程序，1.0将禁止用户放大到实际尺寸之上。<br>user-scalable:是否可对页面进行缩放，no 禁止缩放</p><h3 id="🍵导航栏功能介绍"><a href="#🍵导航栏功能介绍" class="headerlink" title="🍵导航栏功能介绍"></a>🍵导航栏功能介绍</h3><p><img src="https://s2.loli.net/2023/05/23/v7F2gAYmr8PJC6f.png#height=363&id=tzBaj&originHeight=726&originWidth=1722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=861"><br>导航栏总体——使用.navbar类来创建一个标准的导航栏，后面紧跟: .navbar -expand -xl | lg | md | sm类来创建响应式的导航栏 (大屏幕水平铺开，小屏幕垂直堆叠)。通过style改变导航栏颜色和高度，<div class="container">实现对导航栏的大小设置。<br>Logo跳转主页部分——“navbar-brand js-scroll-trigger”设置logo自适应导航栏，对链接最有效，将链接链接到图片上，并设置图片的大小。<br>要创建折叠导航栏，需要在按钮上添加navbar-toggler, data-toggle&#x3D;”collapse”与data-target&#x3D;”#id”，然后在设置了class&#x3D;”collapse navbar-collapse”类的div上包裹导航内容（链接），div元素上的id匹配按钮data-target的上指定的id。将导航栏项目放置在右侧，并设置通过class&#x3D;”nav-item nav-link js-scroll-trigger”设置不同的链接导航，相同的导航栏，插入和链接三个分页面。</p><h3 id="🍵主页面"><a href="#🍵主页面" class="headerlink" title="🍵主页面"></a>🍵主页面</h3><p><img src="https://s2.loli.net/2023/05/24/kn2GfNW6zSZPRtb.png#height=364&id=aLeuq&originHeight=728&originWidth=1958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=979"><br>设置块并在其中插入背景图片并实现左右居中，在上方加入文字并设置相应颜色和大小，通过<br>控制换行。与此同时通过调用bootstrap中的圆形按钮模块，并在其上链接城市介绍页面以用来实现页面之间的跳转。</p><h3 id="🍵城市介绍——介绍板块"><a href="#🍵城市介绍——介绍板块" class="headerlink" title="🍵城市介绍——介绍板块"></a>🍵城市介绍——介绍板块</h3><p><img src="https://s2.loli.net/2023/05/24/HDZTtKWoYemUXdM.png#height=369&id=KpjMc&originHeight=738&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br>设置块状元素并通过Bootstrap中的响应式栅格布局对将要存入的图片和文字进行位置的布局安排。插入图片并通过设置入场动画，即进入页面，就执行动画——要给需要执行动画的元素直接加上如rubberBand的动画对应的css。<br>同时继续添加块状元素添加文字以及改变其所在框的大小和文字颜色。</p><h3 id="🍵城市介绍——视频模块"><a href="#🍵城市介绍——视频模块" class="headerlink" title="🍵城市介绍——视频模块"></a>🍵城市介绍——视频模块</h3><p><img src="https://s2.loli.net/2023/05/24/oZ2lVNWxneLj4OT.png#height=231&id=pGaDS&originHeight=461&originWidth=1935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=968"><br>设置download块，同时设置视频与背景部分居中显示，作为将要存放视频的底部，设置大小和背景图片。在该底部上设置导入外部视频链接的框的大小，视频外链部分直接复制所要使用视频链接即可。</p><h3 id="🍵城市介绍——了解更多模块"><a href="#🍵城市介绍——了解更多模块" class="headerlink" title="🍵城市介绍——了解更多模块"></a>🍵城市介绍——了解更多模块</h3><p><img src="https://s2.loli.net/2023/05/24/Jf2P6mjguoCOVKl.png#height=458&id=UoHZi&originHeight=916&originWidth=1938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=969"><br>设置contract块作为外链块，与上面相同设置当前块内容居中。设置文本内容偏移量以确定在网页中的所在位置，通过添加相应logo标志和相应链接，完成向外链接的功能。</p><h3 id="🍵美食介绍"><a href="#🍵美食介绍" class="headerlink" title="🍵美食介绍"></a>🍵美食介绍</h3><p><img src="https://s2.loli.net/2023/05/24/mWn47p9tG1VZFoM.png#height=324&id=T4wa3&originHeight=647&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=910"><br>这一页面有了前两个页面的支持，整体实现较为简单，所实现的功能也很简单，主要通过col-sm-6 item定位每个小块的位置，在每个小块中再通过col-md-12 col-lg-5实现左图右文字的功能，其中<b><b/>用于设置文字的加粗，&amp;nbsp;实现空一个字符的距离。最后为了让界面看起来好看一点，所以在鼠标挪动到图片上时看，图片可以实现上下跳动，通过data-bs-hover-animate&#x3D;”bounce”调用即可。</p><h3 id="🍵网页作者"><a href="#🍵网页作者" class="headerlink" title="🍵网页作者"></a>🍵网页作者</h3><p><img src="https://s2.loli.net/2023/05/24/ZD62BhgptI4bzNs.png#height=427&id=FtYFY&originHeight=854&originWidth=1888&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=944"></p><h2 id="🍨运行实例"><a href="#🍨运行实例" class="headerlink" title="🍨运行实例"></a>🍨运行实例</h2><p>见前面运行界面截图</p><h1 id="🥑总结与进一步改进"><a href="#🥑总结与进一步改进" class="headerlink" title="🥑总结与进一步改进"></a>🥑总结与进一步改进</h1><h2 id="🍨总结（心得体会）"><a href="#🍨总结（心得体会）" class="headerlink" title="🍨总结（心得体会）"></a>🍨总结（心得体会）</h2><p>在高中的时候就有了解过网页，在上大学之前对网页这部分就较为感兴趣，所以也有有事没事去跟着视频和菜鸟教程学习有关前端的知识，所以这次在之前就对html和css有一定的了解的基础上，在学习的过程中看到了bootstrap，就想能不能使用它，正好学习一下相关的知识，但是由于基础掌握的不是太牢固，所以还是出了挺多问题，最后由于临近考试，花在这个作业上的时间也不算特别的多。<br>在编写的过程中基本就是想要实现什么功能就去菜鸟教程上查和找网上有没有相似的网站F12看他的代码，看看能不能套用他的模板，特别是在实现需要设置位置的时候，基本就是每改一次数字运行看一次，来一次次把图片或者框放在所想放的位置。特别是在写城市介绍的时候，对代码极为不熟悉，在写的时候用了很多的时间边写边查，后面几个页面相对就比较轻松了。<br>其次在编写的时候还有一大难点就是让界面看起来怎么好看之类的排版太难了，好多时候选一张图片就要选好久，虽然合理也运用空间，让自己的网页井然有序，留下合适空间这句话看起来挺简单，但实践起来就还是没有什么头绪，基本就是走一步看一步，先排起来，觉得这样排版有点丑就换排版，在制作界面的时候不只是代码，设计也是一个很大的学问。<br>总体来说，通过今对网页设计的学习，还是有很多的收获，通过大作业程序的编写也锻炼了我对界面中各种标签，图片的浮动操作的使用以及点击文字跳转到指定位置的代码运用的能力，让我对他们的实现有了更生动地体会。</p><h2 id="🍨进一步改进"><a href="#🍨进一步改进" class="headerlink" title="🍨进一步改进"></a>🍨进一步改进</h2><p>若后续还需要对当前网页进行改进，主要由以下几个方向进行：</p><ol><li>增加城市景点介绍页面（本来想做这一部分的，后面考试就来不及增加了；</li><li>界面部分文字和图片没有完全对其，由于空行等导致的没有对齐的问题也需要更完善；</li><li>导航栏在最后改进的时候只改进了其中一个界面的高度，导致后面颜色和高度有些不统一；</li><li>在编写的时候很多字体颜色、方框版式等虽然运用到了bootstrap中的东西，但对这一部分还不是了解的特别全面，后面还需要更多地学习。</li></ol><h1 id="🥑对课程设计的建议"><a href="#🥑对课程设计的建议" class="headerlink" title="🥑对课程设计的建议"></a>🥑对课程设计的建议</h1><p>线上上课的时候希望可以增加课程提醒和签到提醒，有一周不小心忘记这周有直播课程了，最后晚进去了，还有的时候中途会因为本来电脑听课后来想换到手机听课，电脑自己拿代码试一试，退出一会儿，实在是不知道有没有签上到。别的都挺好的，在高中的时候就学过网页，没想到到大学还能用上这些知识还是挺开心的。</p><h1 id="🥑源代码"><a href="#🥑源代码" class="headerlink" title="🥑源代码"></a>🥑源代码</h1><p>课程代码已开源至Github</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E4%B8%93%E4%B8%9A%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5-%E5%AE%B6%E4%B9%A1%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C">Cassie&#x2F;计算机类专业创新实践-家乡静态网页制作 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML&amp;CSS </category>
          
          <category> 课程设计 </category>
          
          <category> 创新实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> HTML&amp;CSS </tag>
            
            <tag> 创新实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计——将WHILE语句转换成四元式的程序实现</title>
      <link href="/2022/06/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%B0%86WHILE%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%9B%E5%85%83%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/06/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%B0%86WHILE%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%9B%E5%85%83%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="💐设计目的及设计要求"><a href="#💐设计目的及设计要求" class="headerlink" title="💐设计目的及设计要求"></a>💐设计目的及设计要求</h1><h2 id="🌼设计内容"><a href="#🌼设计内容" class="headerlink" title="🌼设计内容"></a>🌼设计内容</h2><p>设计一个语法制导翻译器,将WHILE语句翻译成四元式。</p><h2 id="🌼要求"><a href="#🌼要求" class="headerlink" title="🌼要求"></a>🌼要求</h2><p>先确定一个定义WHILE语句的文法，为其设计一个语法分析程序,为每条产生式配备一个语义子程序,按照一遍扫描的语法制导翻译方法,实现翻译程序。对用户输入的任意一个正确的WHILE 语句,程序将其转换成四元式输出(可按一定格式输出到指定文件中)。</p><h1 id="💐开发环境描述"><a href="#💐开发环境描述" class="headerlink" title="💐开发环境描述"></a>💐开发环境描述</h1><h2 id="🌼开发工具"><a href="#🌼开发工具" class="headerlink" title="🌼开发工具"></a>🌼开发工具</h2><p>JAVA</p><h2 id="🌼开发环境"><a href="#🌼开发环境" class="headerlink" title="🌼开发环境"></a>🌼开发环境</h2><p><img src="https://s2.loli.net/2023/05/24/Jio9VcNSuTYpMAd.png#height=146&id=k8ahO&originHeight=292&originWidth=621&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=311"></p><h1 id="💐设计内容、主要算法描述"><a href="#💐设计内容、主要算法描述" class="headerlink" title="💐设计内容、主要算法描述"></a>💐设计内容、主要算法描述</h1><h2 id="🌼问题描述"><a href="#🌼问题描述" class="headerlink" title="🌼问题描述"></a>🌼问题描述</h2><p>根据题目要求，需要设计一个语法制导翻译器，将while语句翻译成四元式。</p><h2 id="🌼背景介绍"><a href="#🌼背景介绍" class="headerlink" title="🌼背景介绍"></a>🌼背景介绍</h2><h3 id="🌸文法介绍"><a href="#🌸文法介绍" class="headerlink" title="🌸文法介绍"></a>🌸文法介绍</h3><ol><li><strong>While语句的初始文法描述描述</strong></li></ol><p>while语句：A→w(P){B:}<br>赋值语句： B→g&#x3D;C<br>表达式：   C→CHD<br>项：       D→DIE<br>因子：     E→f | g | (C)<br>加法运算符：H→+|-<br>乘法运算符：I→*|&#x2F;<br>比较运算符：J→&lt; | &gt; | &gt;&#x3D; | &lt;&#x3D;<br>关系表达式：P→CJC<br>无符号整数：f<br>标识符：   g</p><ol start="2"><li><strong>改进为LL(1)文法之后的文法描述</strong></li></ol><p>while语句：A→w(P){B:}<br>赋值语句： B→g&#x3D;C<br>表达式：   C→DM<br>  M→HDM | ℇ<br>项：       D→EN<br>  N→IEN | ℇ<br>因子：     E→f | g | (C)<br>加法运算符：H→+|-<br>乘法运算符：I→*|&#x2F;<br>比较运算符：J→&lt; | &gt; | &gt;&#x3D; | &lt;&#x3D;<br>关系表达式：P→CJC<br>无符号整数：f<br>标识符：   g<br><strong>说明：</strong><br>以上文法中使用w代替while关键字，M和N分别是为了消除左递归引入的符号，无具体对应含义。</p><h3 id="🌸属性文法"><a href="#🌸属性文法" class="headerlink" title="🌸属性文法"></a>🌸属性文法</h3><ol><li>属性文法定义形式</li></ol><p>属性文法是在上下文无关文法的基础上，为每个文法符号（终结符或者非终结符）配备若干相关的“值”（与文法符号相关的属性）。<br>在一个属性文法中，对应于每个产生式A→a都有一套与之相关联的语义规则，每规则的形式为：b:&#x3D;f(c1,c2,…，ck)其中f是一个函数，而且或者b是A的一个综合属性并且c1,c2,…，ck是产生式右边文法符号的属性；或者非终结符既可有综合属性也可有继属性，文法开始符号的所有继承属性作为属性计算前的初始值。</p><ol start="2"><li>while语句的属性文法</li></ol><p>while语句：</p><ul><li>A→w {X1 &#x3D; gotostm} (P) {X2 &#x3D; gotostm}{B;} </li><li>{ backpatch(Ptruelist, M2gotostm);</li><li>backpatch(Pfalselist, tacIndex-1);</li><li>gen(‘J’,  ,  , X1);</li><li>gen( , , ,tacIndex);}</li></ul><p>赋值语句：</p><ul><li>B→g&#x3D;C{B.val&#x3D;C.val; gen(‘&#x3D;’,C.val, ,g.val);}</li></ul><p>表达式：</p><ul><li>C→D{M.i&#x3D;D.val}M{C.val&#x3D;M.s}</li><li>M→HD{ M1.i&#x3D;newtemp; gen(H.val,M.i,D.val, M1.i);}</li><li>M1{M.s&#x3D; M1.s}</li><li>M→ℇ{ M.s&#x3D; M.i}</li></ul><p>项：</p><ul><li>D→E{N.i&#x3D;E.val}N{D.val&#x3D;N.s}</li><li>N→IE{ N1.i&#x3D;newtemp; gen(I.val,N.i,D.val, N1.i);} N1{N.s&#x3D; N1.s}</li><li>N→ℇ{N.s&#x3D; N.i}</li></ul><p>因子：</p><ul><li>E→f{ E.val&#x3D; f.val}</li><li>E→g{ E.val&#x3D; g.val}</li><li>E→(C) { E.val&#x3D; C.val}</li></ul><p>加法运算符：</p><ul><li>H→+|-{H.val&#x3D;+ | H.val&#x3D;-;}</li></ul><p>乘法运算符：</p><ul><li>I→*|&#x2F;{I.val&#x3D;+ | I.val&#x3D;-;}</li></ul><p>比较运算符：</p><ul><li>J→&lt; | &gt; | &gt;&#x3D; | &lt;&#x3D;{J.val &#x3D; &gt; | J.val &#x3D;&lt; |J.val &#x3D; &lt;&#x3D; | J.val &#x3D; &gt;&#x3D;;}</li></ul><p>关系表达式：</p><ul><li>P→C1JC2{P.val&#x3D;newtemp;</li><li>gen(J.val, C1.val,C2.val,P.val);}</li></ul><p>无符号整数：</p><ul><li>f</li></ul><p>标识符：</p><ul><li>g</li></ul><p><strong>说明：</strong><br>上述属性文法中gen(op,arg1,arg2,result)生成四元式，newtemp产生一个未使用过的名字，val表示符号的值，f和g的值由输入时直接确定，tacIndex为生成四元式的标号。X1和X2是为了后续拉链回填添加的符号，无具体对应含义，backpatch(p,i)为拉链回填，将链表P中的每个元素指向i。</p><h3 id="🌸中间代码形成的描述"><a href="#🌸中间代码形成的描述" class="headerlink" title="🌸中间代码形成的描述"></a>🌸中间代码形成的描述</h3><p>四元式是一种比较普遍采用的中间代码形式。<br>它的一般形式为：(op,arg1,arg2,result)。其中， op为一个二元 (也可是一元或零元)运算符；arg1,arg2分别为它的两个运算 (或操作)对象，它们可以是变量、常数或系统定义的临时变量名；运算的结果将放入result中。运算对象和运算结果有时指用户自己定义的变量，有时指编译程序引进的临时变量。需要指出的是，每个四元式只能有一个运算符，所以，一个复杂的表达式须由多个四元式构成的序列来表示。例如，表达式A+B*C可写为序列</p><ol><li><ul><li>B C T1</li></ul></li><li><ul><li>A T1 T2</li></ul></li></ol><p>其中，T1，T2是编译系统所产生的临时变量名。当op为一元、零元运算符 (如无条件转移)时，arg2甚至arg1应缺省，即result∶&#x3D;op arg1或 op result ；对应的一般形式为： (op,arg1,,result)或 (op,,,result)<br>在实际产生的四元式中，op往往用一整型数表示 (操作符的代码)，它可能附带有不止一种属性。</p><h2 id="🌼解决方案"><a href="#🌼解决方案" class="headerlink" title="🌼解决方案"></a>🌼解决方案</h2><p>根据背景介绍的方法，可以将while语句转化为四元式。大致分为以下几个步骤：</p><ol><li>将while语句转换为四元式的第一步为对读入的表达式进行处理，即删除不必要的空格、回车、换行等，保证之后的步骤能够顺利进行。</li><li>通过词法分析判断语句中的每个字符的类型，如：常数、标识符、判断符、界符等。</li><li>分析while语句的文法并将其消除左递归和回溯。</li><li>在语法分析正确的情况下，通过语法分析的中间过程的符号栈输出四元式，四元式的形式为：（op   arg1   arg2   result）。</li></ol><h3 id="🌸程序模块分析"><a href="#🌸程序模块分析" class="headerlink" title="🌸程序模块分析"></a>🌸程序模块分析</h3><p>编译过程一般分为六个阶段的过程，可以由六个模块完成，它们称为词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、代码优化程序、目标代码生成程序，此外，一个完整编译程序还必须包括“表格管理程序”和“出错处理程序”。</p><h3 id="🌸使用的分析法"><a href="#🌸使用的分析法" class="headerlink" title="🌸使用的分析法"></a>🌸使用的分析法</h3><p>在对当前while语句进行语法分析的过程中，由于对自下而上的分析方法的掌握不是很熟练，因此最终决定采用的是递归下降分析法，但由于所用的while语句文法并不符合这一要求，所以要首先对文法进行修改，消除左递归，使得文法符合要求。</p><h3 id="🌸词法分析和语法分析"><a href="#🌸词法分析和语法分析" class="headerlink" title="🌸词法分析和语法分析"></a>🌸词法分析和语法分析</h3><p>这次实验涉及到词法分析、语法分析、语义分析及表格管理和出错管理。<br>其中，词法分析至少要能识别关键字“while”，标识符（即自定义变量），数字，运算符和界符等等；<br>语法分析要分析程序结构的合法性，即是否为文法的句子；<br>语义分析要能够语法制导翻译出中间代码四元式并将其输出；<br>表格管理是指符号表；<br>出错处理是指在语法分析时，所有非文法句子的错误类型处理。</p><h3 id="🌸语义分析和中间代码生成"><a href="#🌸语义分析和中间代码生成" class="headerlink" title="🌸语义分析和中间代码生成"></a>🌸语义分析和中间代码生成</h3><p>根据输入的语义动作进行语法制导翻译，当遇到语义动作的非终结符时，执行相应的语义动作，同时将产生的四元式输出并存储到相应的结构中，作为下一阶段四元式优化的输入部分。<br>对于while语句，由于进行了关系表达式的判断所以要进行语句的跳转，存在三处跳转：<br>第一，while语句的循环条件成立时，则跳转到循环体执行的第一条语句；第二，while语句的循环条件不成立时，则跳转到while语句的下一条语句；第三，循环体执行完毕时，则跳转到循环条件判断处，进行判断。对于跳转，采用拉链回填的方式进行处理。</p><h1 id="💐主要算法描述包括流程图"><a href="#💐主要算法描述包括流程图" class="headerlink" title="💐主要算法描述包括流程图"></a>💐主要算法描述包括流程图</h1><h2 id="🌼词法分析部分"><a href="#🌼词法分析部分" class="headerlink" title="🌼词法分析部分"></a>🌼词法分析部分</h2><p><img src="https://s2.loli.net/2023/05/24/gpaeH4qUfwDlW1C.png#height=327&id=V60DR&originHeight=653&originWidth=1353&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Lexer%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=677" alt="Lexer函数分析" title="Lexer函数分析"><br>Lexer.java主要作用为词法分析器，可以对当前输入源程序进行词法分析。主要过程如下：</p><ul><li>获取当前字符，若当前字母为英文则继续判断下一字符，直到不为英文或数字，则标记为标识符。</li><li>若当前字符为数字则继续判断下一字符直到不为数字，标记为常数。</li><li>若当前字符不为空，则根据字符判断当前为界符或分隔符或运算符。</li></ul><p><img src="https://s2.loli.net/2023/05/24/xlCDTZLhjgrdeyN.png#height=454&id=aIDIK&originHeight=907&originWidth=1379&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE&width=690" alt="词法分析流程图" title="词法分析流程图"></p><h2 id="🌼语法分析部分"><a href="#🌼语法分析部分" class="headerlink" title="🌼语法分析部分"></a>🌼语法分析部分</h2><p><img src="https://s2.loli.net/2023/05/24/F8Lj6ArstMXPB4w.png#height=440&id=Erxzw&originHeight=880&originWidth=1375&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Parsing%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=688" alt="Parsing函数分析" title="Parsing函数分析"><br>Parsing.java主要作用为语法分析器，可以对当前词法分析部分所标定的各个符号根据While语句的初始文法根据消除左递归后的文法进行相应的改进。<br>主要过程如下：</p><ul><li>前半部分首先对当前while句型进行正误判断，定义cut函数用于删去当前位置的值；首先判断while字符是否相等，其次根据while(){}来判断当前当前句型是否有{、}、(、)是否有缺失，若当前语句不为while句型，则输出错误语句，反之进入下一阶段。</li><li>后半部分为文法的改进，根据消除左递归的方法来对while语句文法进行改进，改进方式如下：<table><thead><tr><th>While语句初始文法描述</th><th>消除左递归后的文法描述</th></tr></thead><tbody><tr><td><img src="https://s2.loli.net/2023/05/24/A2L9DZ6CGp4eiKP.png#height=280&id=PVzK7&originHeight=558&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=277"></td><td><img src="https://s2.loli.net/2023/05/24/ZUqSMg8wHnsVLc4.png#height=335&id=f9eXw&originHeight=670&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=273"></td></tr></tbody></table></li></ul><h2 id="🌼定义四元式部分部分"><a href="#🌼定义四元式部分部分" class="headerlink" title="🌼定义四元式部分部分"></a>🌼定义四元式部分部分</h2><p><img src="https://s2.loli.net/2023/05/24/PRFopi6yvsLXQAx.png#height=418&id=h15qS&originHeight=835&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Quaternion%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=442" alt="Quaternion函数分析" title="Quaternion函数分析"><br>在这一部分对四元式进行定义，并设计相应的函数对四元式进行储存、获取以及输出。四元式定义如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quaternion</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String table;<span class="comment">//四元式表号，方面查找</span></span><br><span class="line">    <span class="keyword">private</span> String op;<span class="comment">//操作符</span></span><br><span class="line">    <span class="keyword">private</span> String arg1;<span class="comment">//运算对象1</span></span><br><span class="line">    <span class="keyword">private</span> String arg2;<span class="comment">//运算对象2</span></span><br><span class="line">    <span class="keyword">private</span> String result;<span class="comment">//运算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Quaternion存储四元式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Quaternion</span><span class="params">(String table,String op,String arg1,String arg2,String result)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.table = table;</span><br><span class="line">        <span class="built_in">this</span>.op = op;</span><br><span class="line">        <span class="built_in">this</span>.arg1 = arg1;</span><br><span class="line">        <span class="built_in">this</span>.arg2 = arg2;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🌼语义分析和四元式的生成"><a href="#🌼语义分析和四元式的生成" class="headerlink" title="🌼语义分析和四元式的生成"></a>🌼语义分析和四元式的生成</h2><p><img src="https://s2.loli.net/2023/05/24/zNvX1ubWHPdGwJc.png#height=461&id=oXxUJ&originHeight=922&originWidth=1369&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=ConstructQuaternion%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90&width=685" alt="ConstructQuaternion函数分析" title="ConstructQuaternion函数分析"><br>首先将txt文件中的内容读取到字符串中，并对每一行的信息进行词法分析和语法分析，以便更好的进行递归下降法进行分析。<br>从while（后开始分析，若当前词语为常数或标识符则将当前词语入栈，、反之且当前操作码为空则将操作码入栈，若当前操作码不为空，则比较栈顶位置的操作符和当前所指的优先级进行比较，若当前操作符的优先级大于栈顶操作符，则生成四元式出栈，，反之则将其入栈。<br>当对while（）括号内的预计进行分析完后，将对{}中的语句进行分析，主要分析方法和上述相同，除此以外需要对最后一句四元式进行特殊处理。<br>对于生成四元式的流程图如下所示：<br><img src="https://s2.loli.net/2023/05/24/bmGMDL6PRBxs9zN.jpg#height=407&id=TJ7BW&originHeight=814&originWidth=1418&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=709"><br><img src="https://s2.loli.net/2023/05/24/CTz6Oq3JpEuM5fx.png#id=Mxwbj&originHeight=875&originWidth=1282&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=ConstructQuaternion%E6%B5%81%E7%A8%8B%E5%9B%BE" alt="ConstructQuaternion流程图" title="ConstructQuaternion流程图"></p><h2 id="🌼四元式的输出和图形界面"><a href="#🌼四元式的输出和图形界面" class="headerlink" title="🌼四元式的输出和图形界面"></a>🌼四元式的输出和图形界面</h2><p>这一部分较为简单，主要就是通过调用java的各个图形界面对while转为四元式的项目进行界面的设计，同时通过文件调用命令读取计算机中的txt文件，通过调用之前的函数，对txt中的源程序进行分析，将分析生成的四元式输出在图形界面中，同时在本项目中还生成了当前源程序中的词语和其对应的类型。<br>生成图形界面如下所示：<br><img src="https://s2.loli.net/2023/05/24/eJwDchCKmYnub67.png#height=295&id=mK67v&originHeight=589&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA&width=414" alt="图形界面展示" title="图形界面展示"></p><h1 id="💐设计的输入和输出形式"><a href="#💐设计的输入和输出形式" class="headerlink" title="💐设计的输入和输出形式"></a>💐设计的输入和输出形式</h1><h2 id="🌼输入"><a href="#🌼输入" class="headerlink" title="🌼输入"></a>🌼输入</h2><p>根据题目要求，本程序的输入均为语句或者表达式，由于每次测试程序均输入表达式，则会需要输入大量式子，浪费时间且同意出错。<br>因此本程序采用文件读入的形式，只需要选定在指定位置的文件即可。<br><img src="https://s2.loli.net/2023/05/24/uXO7cSyv2z5PRIf.png#height=109&id=S1NDa&originHeight=217&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=223"></p><h2 id="🌼输出"><a href="#🌼输出" class="headerlink" title="🌼输出"></a>🌼<strong>输出</strong></h2><p>根据题目的要求，针对输入的txt文件中的源文件，对其进行分析后输出词法分析得到的各个词语以及相应的类型，与此同时会输出对应的四元式。具体形式如下所示：<br><img src="https://s2.loli.net/2023/05/24/NaTMIvrVgEwOcnK.png#height=346&id=BLL9U&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></p><h1 id="💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）"><a href="#💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）" class="headerlink" title="💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）"></a>💐程序运行（测试、模拟）的结果（屏幕拷贝、生成结果的打印输出）</h1><p>为了更好的测试程序，在模拟测试阶段共定义了5个while语句。</p><table><thead><tr><th>输入的while语句</th><th>运行截图</th></tr></thead><tbody><tr><td><img src="https://s2.loli.net/2023/05/24/DUGO6EH41wAfQM3.png#height=121&id=BE9Wy&originHeight=241&originWidth=485&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=243"></td><td><img src="https://s2.loli.net/2023/05/24/8aOFQnfGU6ye921.png#height=346&id=FC69Q&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/LxMzbrvDfcSnmO3.png#id=BxqT1&originHeight=373&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td><td><img src="https://s2.loli.net/2023/05/24/VSvcOeHtiBClYXE.png#id=g7H3f&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td></tr><tr><td>While语句报错</td><td></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/mZYrFV96zJnAsgl.png#height=140&id=jGfhc&originHeight=279&originWidth=486&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=243"></td><td><img src="https://s2.loli.net/2023/05/24/2Fyb5Pw7gW6J4te.png#height=346&id=Koejy&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr><tr><td>无右括号报错</td><td></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/VwFpCPD4zUS8c3a.png#height=144&id=hYKjr&originHeight=287&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=237"></td><td><img src="https://s2.loli.net/2023/05/24/hcPi6sEwFfog9nS.png#height=346&id=ltgAp&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr><tr><td>多语句分析</td><td></td></tr><tr><td><img src="https://s2.loli.net/2023/05/24/K2nHCVUNOu4GLip.png#height=134&id=fLNxW&originHeight=267&originWidth=501&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=251"></td><td><img src="https://s2.loli.net/2023/05/24/ZNQKMv4iCdmegYW.png#height=346&id=BoIz7&originHeight=692&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"></td></tr></tbody></table><h1 id="💐总结（体会）"><a href="#💐总结（体会）" class="headerlink" title="💐总结（体会）"></a>💐总结（体会）</h1><p>编译过程一般分为六个阶段的过程，可以由六个模块完成，它们称为词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、代码优化程序、目标代码生成程序，此外，一个完整编译程序还必须包括“表格管理程序”和“出错处理程序”。<br>这次实验采用的方法对文法有一定的要求，要求文法必须是不为左递归和无回溯的文法，由于所用的while语句文法并不符合这一要求，所以要首先对文法进行修改，消除左递归。同时，这次实验涉及到词法分析、语法分析、语义分析及表格管理和出错管理。其中，词法分析至少要能识别关键字“while”，标识符（即自定义变量），数字，运算符和界符等等；语法分析要分析程序结构的合法性，即是否为文法的句子；语义分析要能够语法制导翻译出中间代码四元式并将其输出；表格管理是指符号表；出错处理是指在语法分析时，所有非文法句子的错误类型处理。<br>以下主要叙述我再编写程序过程中遇到的几个难点。</p><ol><li>在刚开始看到这个题目的时候首先想到的是通过while句型的翻译进行手动生成四元式，但手写完成while句型到四元式的转化与通过编程解决还是有一定的差距，由于在之前的学习中我对于递归下降的方法较为熟悉，因此试想能否通过该方法进行四元式的转化。因此我先对while的文法进行的书写，将各个部分通过字母代表的形式，进行了相应的转化，由于该while语句的文法不符合递归下降文法的要求，因此对此进行消除左递归。</li><li>在进行编程时，按照所学将整个文件分为词法分析、语法分析、语义分析和中间代码的生成，在词法分析阶段有了实验一的经验，整体编写过程还是非常通顺的，基本没有遇到问题。语法分析阶段主要根据所定义的while语句文法和相应转化后的文法进行转化，由于文法较为复杂，所定义的参数较多，因此编写过程中只要一不注意就会忘记自己到了那一部分，这一部分在最后运行过程中出现的问题还是比较多的，花了较长的时间来debug。在语义分析和四元式的生成部分，由于吸取了之前编写的经验，首先我先进行了流程图的绘制，对每一部分要进行的代码编写进行了分块和大概的伪代码处理，在这一基础上再进行代码的编写，由于对（）和{}中语句分四元式生成方法基本相同，因此除了对（）内的比较语句和{}最后语句语句的特殊处理，其余部分都只需要按照优先关系的比较进行相应的出栈和入栈操作即可。最后再通过图形界面进行输出即可，由于对于java的图形界面的学习较为少，因此这一次采取了对之前实验中设计的图形界面的改进的方法来进行生成。</li></ol><p>编写本次课程设计的感想是：<br>必需要理清正确的优先级顺序才可以编写程序；要创建好适当的结构体，合适的结构体会使程序的思路更加清晰。同时也要自己多加思考，寻找适合自己的编写代码方法来提高编写效率。<br>这次编译原理课程设计让我受益匪浅，不仅巩固了我平时在课堂上学到的知识，还为接下来的考试打下了坚实的基础。最后衷心的感谢老师们在实验过程中对我们的悉心指导，没有老师的耐心答疑我们很难这么顺利地完成课程设计。</p><h1 id="💐源程序清单"><a href="#💐源程序清单" class="headerlink" title="💐源程序清单"></a>💐源程序清单</h1><table><thead><tr><th>程序名称</th><th>作用</th></tr></thead><tbody><tr><td>Lexer.java</td><td>用于对输出源程序的词法分析</td></tr><tr><td>Prasing.java</td><td>用于对while句型能够进行语法分析</td></tr><tr><td>若不符合句型规则则发出相应报错</td><td></td></tr><tr><td>Quaternion.java</td><td>对四元式进行定义</td></tr><tr><td>ConstructQuaternion.java</td><td>用于进行语义分析和四元式的生成</td></tr><tr><td>Quat_GUI.java</td><td>设计GUI界面并对结果进行相应输出展示</td></tr></tbody></table><p>源程序代码已开源至GitHub</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%B0%86WHILE%E8%AF%AD%E5%8F%A5%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%9B%E5%85%83%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0">Cassie&#x2F;编译原理课程设计-将WHILE语句转换成四元式的程序实现 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 课程设计 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——单周期 CPU 设计与实现—十条指令 CPU</title>
      <link href="/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%81%E6%9D%A1%E6%8C%87%E4%BB%A4-CPU/"/>
      <url>/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%81%E6%9D%A1%E6%8C%87%E4%BB%A4-CPU/</url>
      
        <content type="html"><![CDATA[<h1 id="🍐设计要求"><a href="#🍐设计要求" class="headerlink" title="🍐设计要求"></a>🍐设计要求</h1><p>通过设计并实现支持 10 条指令的 CPU，进一步理解和掌握 CPU 设计的基本原理和过程。</p><h1 id="🍐方案设计"><a href="#🍐方案设计" class="headerlink" title="🍐方案设计"></a>🍐方案设计</h1><p>设计和实现一个支持如下十条指令的单周期 CPU。</p><ol><li>非访存指令</li></ol><ul><li>清除累加器指令 CLA</li><li>累加器取反指令 COM</li><li>算术右移一位指令 SHR：将累加器 ACC 中的数右移一位，结果放回 ACC</li><li>循环左移一位指令 CSL：对累加器中的数据进行操作</li><li>停机指令 STP</li></ul><ol start="2"><li>访存指令</li></ol><ul><li>加法指令 ADD X：[X] + [ACC] –〉ACC，X 为存储器地址，直接寻址</li><li>存数指令 STA X，采用直接寻址方式</li><li>取数指令 LDA X，采用直接寻址</li></ul><ol start="3"><li>转移类指令</li></ol><ul><li>无条件转移指令 JMP imm：signExt(imm) -&gt; PC</li><li>有条件转移（负则转）指令 BAN X：ACC 最高位为 1 则（PC）+ X -&gt; PC,否则 PC不变</li></ul><h2 id="🍑方案原理"><a href="#🍑方案原理" class="headerlink" title="🍑方案原理"></a>🍑方案原理</h2><p>单周期 CPU（Single Cycle Processor）是指一条指令在一个时钟周期内完成并开始下一条指令的执行。它是由数据通路及其控制部件两部分构成。因此，在设计该 CPU 是需要从这两方面入手：</p><ol><li>一是根据指令的功能和格式设计好数据通路并连接；</li><li>二是设计好控制部件。</li></ol><p>CPU 在处理指令时，一般需要经过以下几个步骤：</p><table><thead><tr><th><strong>步骤</strong></th><th><strong>行为</strong></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>取指令</strong> | CPU 根据 PC（程序计数器 - Program Counter）中的指令地址，在指令存储器中获取相应的指令，之后 PC的值会自动改变移动到下一条指令的地址 |<br>| <strong>指令译码</strong> | 对获取的指令进行分析，确定这个指令要完成什么操作，改变相应的控制信号 |<br>| <strong>指令执行</strong> | 相关组件获取控制信号，执行相应操作，并将结果反馈 |<br>| <strong>存储器访问</strong> | 如果指令设计读取、存储内存，则需要对存储器中相应地址进行读取或者写入 |<br>| <strong>结果写回</strong> | 将得到的数据（访问存储器或者修改其它寄存器的值获得）写回相应的寄存器 |</p><h2 id="🍑指令格式定义"><a href="#🍑指令格式定义" class="headerlink" title="🍑指令格式定义"></a>🍑指令格式定义</h2><p>本次实验设计的是一个 16 位的十指令单周期 CPU。</p><ol><li>非访存指令</li></ol><p>清除累加器指令 CLA­——0 —-&gt; ACC<br><img src="https://s2.loli.net/2023/05/26/WBwoi8AJSf1IMc2.png#height=30&id=ZN1qc&originHeight=59&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CLA%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=190" alt="CLA字段分配图" title="CLA字段分配图"><br>累加器取反指令 COM——~ACC→ACC<br><img src="https://s2.loli.net/2023/05/26/KYUNFdaGvzIMj5h.png#height=30&id=AKnpG&originHeight=60&originWidth=384&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=COM%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=192" alt="COM字段分配图" title="COM字段分配图"><br>算术右移一位指令 SHR：将累加器 ACC 中的数右移一位，结果放回 ACC<br><img src="https://s2.loli.net/2023/05/26/UfjGKFiNYgPaWXx.png#height=31&id=Bn5qs&originHeight=61&originWidth=391&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=SHR%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=196" alt="SHR字段分配图" title="SHR字段分配图"><br>循环左移一位指令 CSL：对累加器中的数据进行操作<br><img src="https://s2.loli.net/2023/05/26/D3ifS8MBQEpdKou.png#height=31&id=ZWqzo&originHeight=62&originWidth=393&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=CSL%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=197" alt="CSL字段分配图" title="CSL字段分配图"><br>停机指令 STP<br><img src="https://s2.loli.net/2023/05/26/NFcIhjGbRKAQJp2.png#height=31&id=aq3NF&originHeight=62&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=STP%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=197" alt="STP字段分配图" title="STP字段分配图"></p><ol start="2"><li>访存指令</li></ol><p>加法指令 ADD X：[X] + [ACC] –〉ACC，X 为存储器地址，直接寻址<br>M(X)→MDR(ACC)+MDR→ACC<br><img src="https://s2.loli.net/2023/05/26/JZEmdfsRtY5wFWb.png#height=31&id=kdwj9&originHeight=61&originWidth=390&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=ADD%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=195" alt="ADD字段分配图" title="ADD字段分配图"><br>存数指令 STA X，采用直接寻址方式<br>ACC→MDR MDR→M(X)<br><img src="https://s2.loli.net/2023/05/26/IWRgPz8S9lLQFpc.png#height=31&id=y5Mb2&originHeight=61&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=STA%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=199" alt="STA字段分配图" title="STA字段分配图"><br>取数指令 LDA X，采用直接寻址<br>M(X)→MDR  MDR→ACC<br><img src="https://s2.loli.net/2023/05/26/dt5lfzvmKP1UQcH.png#height=30&id=uZukf&originHeight=60&originWidth=395&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=LDA%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=198" alt="LDA字段分配图" title="LDA字段分配图"></p><ol start="3"><li>转移类指令</li></ol><p>无条件转移指令 JMP imm：signExt(imm) -&gt; PC<br><img src="https://s2.loli.net/2023/05/26/J4kulcr6MwnXy51.png#height=32&id=O5Esz&originHeight=63&originWidth=405&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=JMP%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=203" alt="JMP字段分配图" title="JMP字段分配图"><br>有条件转移（负则转）指令 BAN X: ACC 最高位为 1 则（PC）+ X -&gt; PC,否则 PC不变<br><img src="https://s2.loli.net/2023/05/26/V7LDlYxdIWXZBQn.png#height=31&id=udD08&originHeight=61&originWidth=401&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=BAN%E5%AD%97%E6%AE%B5%E5%88%86%E9%85%8D%E5%9B%BE&width=201" alt="BAN字段分配图" title="BAN字段分配图"></p><h2 id="🍑数据通路设计"><a href="#🍑数据通路设计" class="headerlink" title="🍑数据通路设计"></a>🍑数据通路设计</h2><ul><li><strong>非访存指令</strong></li></ul><p>由上述分析可知，非访存指令的功能是对ACC中的值进行相应的操作以及变化，则可以得到大概的非访存指令数据通路图：<br><img src="https://s2.loli.net/2023/05/26/NzbXUtWm6uFVJnf.png#height=281&id=tH6Wc&originHeight=561&originWidth=1369&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E9%9D%9E%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%9B%BE&width=685" alt="非访存指令数据通路图" title="非访存指令数据通路图"></p><ul><li><strong>访存指令</strong></li></ul><p>根据上述分析可知，访存指令需要根据操作数中的地址码访问相应的存储单元。在直接寻址下，相对于非访存指令，多了一步从数据寄存器取数的过程，根据分析可以画出相对应的数据通路图：<br><img src="https://s2.loli.net/2023/05/26/cO2olnKHQPGVmIR.png#height=425&id=y9vo3&originHeight=849&originWidth=1368&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%9B%BE&width=684" alt="访存指令的数据通路图" title="访存指令的数据通路图"></p><ul><li><strong>转移类指令</strong></li></ul><p>无条件转移：将操作数中的立即数赋给 pc，由 pc 作为 addr 输出<br>有条件跳转：将 ACC 中的数据传入 ALU 进行判断，再根据判断结果传入pc，再由 pc 传出。</p><h2 id="🍑控制单元设计"><a href="#🍑控制单元设计" class="headerlink" title="🍑控制单元设计"></a>🍑控制单元设计</h2><p><img src="https://s2.loli.net/2023/05/26/HKthNxwv5JLiS8j.png#height=246&id=CIRji&originHeight=491&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8F%82%E8%80%83%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1%E5%9B%BE&width=517" alt="参考控制单元设计图" title="参考控制单元设计图"><br><img src="https://s2.loli.net/2023/05/26/1fmeGlH6yW5hijd.png#height=343&id=f7VmN&originHeight=685&originWidth=1436&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1%E5%9B%BE&width=718" alt="控制单元设计图" title="控制单元设计图"><br>根据上述指令功能和数据通路的设计可以得出相关的控制单元设计图，如上图所示。<br>ModelSim仿真所得的相应控制单元连线图如下所示：<br><img src="https://s2.loli.net/2023/05/26/uEGJfdmtSbjnyB9.png#height=221&id=RsL4n&originHeight=442&originWidth=1370&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=modelsim%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%BF%9E%E7%BA%BF%E5%9B%BE&width=685" alt="modelsim控制单元连线图" title="modelsim控制单元连线图"></p><h2 id="🍑控制单元设计-1"><a href="#🍑控制单元设计-1" class="headerlink" title="🍑控制单元设计"></a>🍑控制单元设计</h2><p>指令与操作码对应表如下所示：</p><table><thead><tr><th>指令</th><th>操作码</th><th>指令</th><th>操作码</th></tr></thead><tbody><tr><td>CAL</td><td>0000</td><td>CSL</td><td>0101</td></tr><tr><td>LDA</td><td>0001</td><td>STA</td><td>0110</td></tr><tr><td>ADD</td><td>0010</td><td>BAN</td><td>0111</td></tr><tr><td>COM</td><td>0011</td><td>JMP</td><td>1000</td></tr><tr><td>SHR</td><td>0100</td><td>STOP</td><td>1001</td></tr></tbody></table><h1 id="🍐实验步骤"><a href="#🍐实验步骤" class="headerlink" title="🍐实验步骤"></a>🍐实验步骤</h1><p>在第三部分通过对该 CPU 实现细节的分析、设计，并得到该 CPU 的原理图后，就可以依次实现各个模块，并进行仿真验证了。</p><h2 id="🍑CPU各模块Verilog实现"><a href="#🍑CPU各模块Verilog实现" class="headerlink" title="🍑CPU各模块Verilog实现"></a>🍑CPU各模块Verilog实现</h2><p>在前面实验中，已经分别设计和实现了 PC、指令存储器、寄存器组和 ALU，这里只给出各个模块的功能描述及其接口定义，具体实现可以直接使用或者调整前面试验的实现代码。</p><ul><li><strong>PC模块</strong></li></ul><p>PC模块功能描述如下所示：</p><p>| <strong>输入</strong> | 时钟信号 clk，复位信号 rst<br>有条件转移信号 wr，无条件转移信号</p><p>wr_none,停机信号 stop，输入 data_in |<br>| — | — |<br>| <strong>输出</strong> | 12 位指令地址 data_out |<br>| <strong>功能</strong> | 遇到复位指令清零，遇到停机指令停止，跳转指令按照设置写入，<br>其他正常情况 data_out&#x3D;data_out+1,即 pc&#x3D;pc+1 |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_pc(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> rst,<span class="comment">//复位信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr,<span class="comment">//有条件转移信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr_none,<span class="comment">//无条件转移信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> stop,<span class="comment">//停机信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">reg</span>[<span class="number">11</span>:<span class="number">0</span>] data_in,<span class="comment">//输入的12位跳转所加的数</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">11</span>:<span class="number">0</span>] data_out<span class="comment">//12位指令地址</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    data_out = <span class="number">0</span>; <span class="comment">//初始化data_out</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span> <span class="comment">//下降沿</span></span><br><span class="line">    <span class="keyword">if</span>(stop == <span class="number">1</span>) <span class="comment">//停机信号生效</span></span><br><span class="line">      data_out = data_out; <span class="comment">//即pc的值不变</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rst == <span class="number">1</span>) <span class="comment">//复位信号生效</span></span><br><span class="line">      data_out = <span class="number">0</span>; <span class="comment">//即pc的值变为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      data_out = data_out + <span class="number">1</span>; <span class="comment">//pc=pc+1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span><span class="comment">//上升沿</span></span><br><span class="line">    <span class="keyword">if</span>(wr == <span class="number">1</span>) <span class="comment">//有条件跳转信号生效</span></span><br><span class="line">      data_out = data_out + data_in;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(wr_none == <span class="number">1</span>)<span class="comment">//无条件跳转信号生效</span></span><br><span class="line">      data_out = <span class="number">12&#x27;b000000000011</span>;<span class="comment">//跳转至3指令</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>指令存储器模块</strong></li></ul><p>指令存储器模块功能描述如下所示：</p><table><thead><tr><th><strong>输入</strong></th><th>12 位指令地址 Addr</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>16 位指令码 Ins</td></tr><tr><td><strong>功能</strong></td><td>设置并存放待执行的指令，然后根据地址输出指令</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_imemory (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] Addr,<span class="comment">//12为指令地址</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Ins <span class="comment">//16位指令码</span></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] RAM[<span class="number">255</span>:<span class="number">0</span>]; <span class="comment">//设置数组</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        RAM[<span class="number">0</span>] = <span class="number">16&#x27;h0000</span>;<span class="comment">//清除累加器指令CLA</span></span><br><span class="line">        RAM[<span class="number">1</span>] = <span class="number">16&#x27;h1002</span>;<span class="comment">//取数指令LDA,直接寻址，取出地址为2的内存单元中的数</span></span><br><span class="line">        RAM[<span class="number">2</span>] = <span class="number">16&#x27;h2003</span>;<span class="comment">//加法指令ADD,直接寻址，与地址为3的数相加放入ACC中</span></span><br><span class="line">        RAM[<span class="number">3</span>] = <span class="number">16&#x27;h3000</span>;<span class="comment">//累加器取反指令COM</span></span><br><span class="line">        RAM[<span class="number">4</span>] = <span class="number">16&#x27;h4000</span>;<span class="comment">//算数右移一位指令SHR：将累加器ACC中的数右移一位，结果放回ACC</span></span><br><span class="line">        RAM[<span class="number">5</span>] = <span class="number">16&#x27;h5000</span>;<span class="comment">//循环左移一位指令CSL：对累加器中的数据进行操作</span></span><br><span class="line">        RAM[<span class="number">6</span>] = <span class="number">16&#x27;h6004</span>;<span class="comment">//存数指令STA，直接寻址,放入地址为4的内存单元</span></span><br><span class="line">        RAM[<span class="number">7</span>] = <span class="number">16&#x27;h7001</span>;<span class="comment">//有条件转移指令BAN</span></span><br><span class="line">        RAM[<span class="number">8</span>] = <span class="number">16&#x27;h8000</span>;<span class="comment">//无条件转移指令JMP,转移至第三条指令</span></span><br><span class="line">        RAM[<span class="number">9</span>] = <span class="number">16&#x27;h9000</span>;<span class="comment">//停机指令stop</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    Ins = RAM[Addr];</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>数据存储器模块</strong></li></ul><p>数据存储器模块功能描述如下所示：</p><p>| <strong>输入</strong> | 输入数据存储器写信号 wr_dmemory<br>12 位指令地址 Addr</p><p>16 位输入数据in_dmemory |<br>| — | — |<br>| <strong>输出</strong> | 16 位输出数据 out_dmemory |<br>| <strong>功能</strong> | 用于存放题目要求的数据，在加法等指令中使用 |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_dmemory(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr_dmemory,<span class="comment">//数据寄存器写信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] Addr,<span class="comment">//12为指令地址</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in_dmemory,<span class="comment">//16位输入数据</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_dmemory<span class="comment">//16位输出数据</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] regfile[<span class="number">12&#x27;b111111111111</span>:<span class="number">0</span>]; <span class="comment">//定义为一个数组</span></span><br><span class="line">  <span class="keyword">assign</span> out_dmemory = regfile[Addr];</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">      regfile[<span class="number">0</span>] = <span class="number">16&#x27;h0002</span>; </span><br><span class="line">      regfile[<span class="number">1</span>] = <span class="number">16&#x27;h4df8</span>;</span><br><span class="line">      regfile[<span class="number">2</span>] = <span class="number">16&#x27;h0003</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(wr_dmemory)</span><br><span class="line">     regfile[Addr] = in_dmemory;</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>ALU模块</strong></li></ul><p>ALU模块功能描述如下所示：</p><p>| <strong>输入</strong> | 操作数 in1,in2</p><p>操作选择信号 alu_op |<br>| — | — |<br>| <strong>输出</strong> | 运算结果输出 Z<br>有条件跳转指令的所加大小 ban_len |<br>| <strong>功能</strong> | 根据 alu_op 对 in1，in2 进行计算，并输出 Z |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_ALU(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in1,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in2,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] alu_op,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Z,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>] ban_len</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Z=<span class="number">0</span>;</span><br><span class="line">    ban_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">always</span> @*<span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">case</span>(alu_op)</span><br><span class="line">      <span class="number">4&#x27;b0000</span>:Z = <span class="number">0</span>;<span class="comment">//CLA</span></span><br><span class="line">      <span class="number">4&#x27;b0011</span>:Z = ~in1;<span class="comment">//COM</span></span><br><span class="line">      <span class="number">4&#x27;b0100</span>:Z = in1[<span class="number">15</span>] == <span class="number">1</span>?&#123;<span class="number">1&#x27;b1</span>,in1[<span class="number">15</span>:<span class="number">1</span>]&#125;:&#123;<span class="number">1&#x27;b0</span>,in1[<span class="number">15</span>]&#125;;<span class="comment">//SHR </span></span><br><span class="line">      <span class="number">4&#x27;b0101</span>:Z = &#123;in1[<span class="number">14</span>:<span class="number">0</span>],in1[<span class="number">15</span>]&#125;;<span class="comment">//CSL</span></span><br><span class="line">      <span class="number">4&#x27;b0010</span>:Z = in1+in2;<span class="comment">//ADD</span></span><br><span class="line">      <span class="number">4&#x27;b0110</span>:Z = in1;<span class="comment">//STA</span></span><br><span class="line">      <span class="number">4&#x27;b0001</span>:Z = in2;<span class="comment">//LDA</span></span><br><span class="line">      <span class="number">4&#x27;b0111</span>:<span class="keyword">begin</span> <span class="comment">//BAN</span></span><br><span class="line">        <span class="keyword">if</span>(in1[<span class="number">15</span>] == <span class="number">1</span>)</span><br><span class="line">          ban_len = <span class="number">12&#x27;b000000000010</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ban_len = <span class="number">12&#x27;b000000000000</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="number">4&#x27;b1001</span>: ; <span class="comment">//stop</span></span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>CU控制单元模块</strong></li></ul><p>CU控制单元模块功能描述如下所示：</p><table><thead><tr><th><strong>输入</strong></th><th>指令操作码 opcode</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>wr_pc, wr_none_pc, wr_ACC, wr_dmemory, stop, cu_rst</td></tr><tr><td>操作选择信号alu_op</td><td></td></tr><tr><td><strong>功能</strong></td><td>根据每一条指令的功能，对读写信号进行控制，从而来完成指令的工作</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_CU(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] opcode,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> rst,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> wr_pc,wr_ACC,wr_dmemory,stop,wr_none_pc,cu_rst,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] alu_op</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    wr_pc = <span class="number">0</span>;</span><br><span class="line">    wr_ACC = <span class="number">0</span>;</span><br><span class="line">    wr_dmemory = <span class="number">0</span>;</span><br><span class="line">    stop = <span class="number">0</span>;</span><br><span class="line">    wr_none_pc = <span class="number">0</span>;</span><br><span class="line">    alu_op = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    cu_rst = rst;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//0000为CLA pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0000</span>) <span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">1</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0001为LDA pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0001</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0010为ADD pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0010</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0011为COM pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0011</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0011</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0100为SHR pc=0 acc=1 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0100</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0100</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0101为CSL pc=0 acc=0 mdr=0 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0101</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0101</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0110为STA pc=0 acc=0 mdr=1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0110</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">0</span>;</span><br><span class="line">      wr_dmemory = <span class="number">1</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0110</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//0111为BAN pc=1 acc=0 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b0111</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">1</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">1</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//1000为JMP pc=1 acc=0 mdr=0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b1000</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_none_pc=<span class="number">1</span>;</span><br><span class="line">      wr_ACC = <span class="number">0</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">0</span>;</span><br><span class="line">      alu_op = <span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//1001为STOP pc=1 acc=0 mdr=0 stop=1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opcode == <span class="number">4&#x27;b1001</span>)<span class="keyword">begin</span></span><br><span class="line">      wr_pc = <span class="number">0</span>;</span><br><span class="line">      cu_rst = <span class="number">0</span>;</span><br><span class="line">      wr_ACC = <span class="number">0</span>;</span><br><span class="line">      wr_dmemory = <span class="number">0</span>;</span><br><span class="line">      stop = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//alu_op = 4&#x27;b1001;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><strong>ACC模块</strong></li></ul><p>ACC模块功能描述如下所示：</p><p>| <strong>输入</strong> | 时钟信号 clk</p><p>ACC 写信号 wr_ACC，ACC 输入 in_ACC |<br>| — | — |<br>| <strong>输出</strong> | ACC 输出 out_ACC |<br>| <strong>功能</strong> | 将非访存指令的操作数暂时存放在累加器中 |</p><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_ACC(</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> wr_ACC,<span class="comment">//ACC写信号</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] in_ACC,<span class="comment">//ACC输入</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] out_ACC<span class="comment">//ACC输出</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] ACC; <span class="comment">//定义数组</span></span><br><span class="line">  <span class="keyword">assign</span> out_ACC = ACC; <span class="comment">//用assign对out_ACC赋值</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ACC = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(wr_ACC)</span><br><span class="line">      ACC = in_ACC;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🍑CPU顶层文件封装实现"><a href="#🍑CPU顶层文件封装实现" class="headerlink" title="🍑CPU顶层文件封装实现"></a>🍑CPU顶层文件封装实现</h2><p>通过根据以上定义的模块进行连接、封装就得到了目标 CPU，该 CPU 的输入为系统时钟信号 clk 和重置信号 reset。<br>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_CPU(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,<span class="comment">//时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst<span class="comment">//复位信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> stop,pc_wr,ACC_wr,dmemory_wr,pc_wr_none;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] alu_op;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] Addr;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">11</span>:<span class="number">0</span>] pc_in;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] opcode,in1,in2,Z;</span><br><span class="line"></span><br><span class="line">five_pc pc(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.stop</span>(stop),</span><br><span class="line">    <span class="variable">.wr</span>(pc_wr),</span><br><span class="line">    <span class="variable">.data_in</span>(pc_in),</span><br><span class="line">    <span class="variable">.data_out</span>(Addr),</span><br><span class="line">    <span class="variable">.wr_none</span>(pc_wr_none)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_imemory imemory(</span><br><span class="line">    <span class="variable">.Addr</span>(Addr),</span><br><span class="line">    <span class="variable">.Ins</span>(opcode)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_dmemory dmemory(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.wr_dmemory</span>(dmemory_wr),</span><br><span class="line">    <span class="variable">.Addr</span>(Addr),</span><br><span class="line">    <span class="variable">.in_dmemory</span>(Z),</span><br><span class="line">    <span class="variable">.out_dmemory</span>(in2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_ACC acc(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.wr_ACC</span>(ACC_wr),</span><br><span class="line">    <span class="variable">.in_ACC</span>(Z),</span><br><span class="line">    <span class="variable">.out_ACC</span>(in1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_CU cu(</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.opcode</span>(opcode[<span class="number">15</span>:<span class="number">12</span>]),</span><br><span class="line">    <span class="variable">.stop</span>(stop),</span><br><span class="line">    <span class="variable">.wr_pc</span>(pc_wr),</span><br><span class="line">    <span class="variable">.wr_ACC</span>(ACC_wr),</span><br><span class="line">    <span class="variable">.wr_dmemory</span>(dmemory_wr),</span><br><span class="line">    <span class="variable">.alu_op</span>(alu_op),</span><br><span class="line">    <span class="variable">.wr_none_pc</span>(pc_wr_none),</span><br><span class="line">    <span class="variable">.cu_rst</span>(rst)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">five_ALU alu(</span><br><span class="line">    <span class="variable">.in1</span>(in1),</span><br><span class="line">    <span class="variable">.in2</span>(in2),</span><br><span class="line">    <span class="variable">.alu_op</span>(alu_op),</span><br><span class="line">    <span class="variable">.Z</span>(Z),</span><br><span class="line">    <span class="variable">.ban_len</span>(pc_in)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🍑CPU模拟仿真"><a href="#🍑CPU模拟仿真" class="headerlink" title="🍑CPU模拟仿真"></a>🍑CPU模拟仿真</h2><p>为了仿真验证所实现的 CPU，需要定义测试文件并在测试文件中对指令存储器和寄存器堆中的相应寄存器的值进行初始化，并通过仿真波形图查看是否指令得到了正确执行。</p><ul><li><strong>TestBench关键代码：</strong><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> five_CPU_tb();</span><br><span class="line">  <span class="keyword">reg</span> clk,rst;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      clk=<span class="number">1</span>;</span><br><span class="line">      rst=<span class="number">1</span>;</span><br><span class="line">      #<span class="number">1</span> rst=<span class="number">0</span>;</span><br><span class="line">      #<span class="number">20</span> <span class="built_in">$stop</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">1</span> clk=~clk;</span><br><span class="line"></span><br><span class="line">  five_CPU uut(</span><br><span class="line">      <span class="variable">.clk</span>(clk),</span><br><span class="line">      <span class="variable">.rst</span>(rst)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="🍐实验步骤-1"><a href="#🍐实验步骤-1" class="headerlink" title="🍐实验步骤"></a>🍐实验步骤</h1><ol><li><strong>建立 ModelSim 工程</strong></li></ol><p>打开 ModelSim，选择 File-&gt;New-&gt;Project，出现 Create Project 对话框，填写工程名（Project Name），选择保存目录（Project Location），注意保存目录中不要有中文。<br><img src="https://s2.loli.net/2023/05/26/zhlUjRsEAHtQZVW.png#height=138&id=bRXkF&originHeight=276&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>单击 OK 按钮后，现在可以选 Create New File（新建文件）或者 Add Existing File（添加已存在文件）。这里我们选择 Add Existing File，也就是添加上述所描述的 Verilog 代码。<br>点击 Browse 按钮，添加上述描述的文件。<br>选择要添加的文件后，单击“打开”按钮，即添加完成，在其中选择 copy to project directory，这样就会将 cu.v等文件复制到新的工程目录下，单击OK 按钮。<br>文件添加完成后，ModelSim 主界面会显示所有文件的状态。选中任意一个文件，右键单击，选择 Compile-&gt;Compile All，即开始编辑所有文件。没有出错，文件状态应该都是绿色的对号，否则点击屏幕下方的 Transcript，查看出错信息，直至无误。</p><ol start="2"><li><strong>开始仿真</strong></li></ol><p>切换到 Library，然后展开 work 目录，在 spu_tb.v 文件上单击右键，在弹出菜单中选择 Simulate （without Optimization）。<br>此时会出现一个名为 sim 的界面，展开其中的spu_tb 节点，选择 uut，会在 Objects 窗口显示所有信号：（若没有出现 Objects 窗口，可以通过菜单 View-&gt;Objects调出该窗口）<br>选择 Objects 窗口的所有信号（Ctrl+A），然后单击右键，在弹出菜单中选择 Add to-&gt;Wave-&gt;Selected Signals。<br>单击工具栏中的 Run-All 按钮，便开始仿真，可以得到仿真效果图<br>结束后，请在 Transcript 中输入 quit –sim 命令退出。</p><h1 id="🍐故障与调试"><a href="#🍐故障与调试" class="headerlink" title="🍐故障与调试"></a>🍐故障与调试</h1><h2 id="🍑代码编写问题1"><a href="#🍑代码编写问题1" class="headerlink" title="🍑代码编写问题1"></a>🍑代码编写问题1</h2><p><strong>故障现象：</strong><br>由于本次实验中实验指导书给的提示很少，刚开始接触的时候虽然后实验四的基础，但还是有一点无从下手，所以网上查阅了较多的资料。<br><strong>解决方案：</strong><br>网上查阅了较多资料以及通过学习别人的代码，在实验四的基础上对实验五进行编写，不断尝试下完成本次实验代码的编写。</p><h2 id="🍑实验故障1"><a href="#🍑实验故障1" class="headerlink" title="🍑实验故障1"></a>🍑实验故障1</h2><p><strong>故障现象：</strong><br>只要用到include，编译就出错，爆出Cannot open &#96;include file *.v<br><strong>原因分析：</strong><br>文件调用出现错误。<br><strong>解决方案：</strong><br>将编译文件放在同一个文件夹中，并编译时要在文件区中进行。</p><h2 id="🍑实验故障2"><a href="#🍑实验故障2" class="headerlink" title="🍑实验故障2"></a>🍑实验故障2</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/26/pXoc5mn36GAzkNy.png#height=363&id=nUMDq&originHeight=725&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=465"><br><strong>原因分析：</strong><br>代码中的编码格式系统无法识别.<br><strong>解决方案：</strong><br>所以参考的代码需要手动输入，而且多半问题出在空格和换行符&#x2F;t上，可以利用文本编辑器统一替换。</p><h2 id="🍑实验故障3"><a href="#🍑实验故障3" class="headerlink" title="🍑实验故障3"></a>🍑实验故障3</h2><p>还出现了很多在实验四中遇到过的问题，这里不做过多赘述。</p><h1 id="🍐仿真及分析"><a href="#🍐仿真及分析" class="headerlink" title="🍐仿真及分析"></a>🍐仿真及分析</h1><p>整体模拟波形图如下所示：<br><img src="https://s2.loli.net/2023/05/26/8hd7jpr1gIi5yqS.png#height=353&id=KVQPb&originHeight=705&originWidth=2369&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1185"></p><h2 id="🍑清除累加器CLA指令"><a href="#🍑清除累加器CLA指令" class="headerlink" title="🍑清除累加器CLA指令"></a>🍑清除累加器CLA指令</h2><p>清除累加器CLA指令波形如下所示：</p><p><img src="https://s2.loli.net/2023/05/26/eobWu1kCx9Q58jv.png#height=154&id=kVRYy&originHeight=308&originWidth=606&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>分析：累加器清零指令，即 ACC 清零。in1 操作数表示着 ACC 中的值，可以发现为 0。所以清零成功。</p><h2 id="🍑取数指令LDA"><a href="#🍑取数指令LDA" class="headerlink" title="🍑取数指令LDA"></a>🍑取数指令LDA</h2><p>取数指令 LDA波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/KqiP2CXp8n7ReLv.png#height=133&id=ZKQYx&originHeight=266&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=512"><br>分析：取数指令 LDA：取出地址为 2 的内存单元中的数。<br>该 CPU 中，设置每下降沿 pc 自动加 1，这里变为12’h001，进入取数指令。在数据存储器 dmemory 中，第二内存单元的数设置的是：16’h4df8，即 0100101111111000。又因为在该CPU 中，操作数 in2 可表示 dmemory 中输出的数，z 也输出该数，所以取数成功。</p><h2 id="🍑加法指令ADD"><a href="#🍑加法指令ADD" class="headerlink" title="🍑加法指令ADD"></a>🍑加法指令ADD</h2><p>加法指令ADD波形入下所示：<br><img src="https://s2.loli.net/2023/05/26/rqwvuUlxSA8a6md.png#height=324&id=ehYFs&originHeight=648&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=519"><br>分析：加法指令 ADD。直接寻址，与地址 3 的数相加存入 ACC 中。<br>因为下降沿自动加 1，Addr 至12’h002，所以进入加法指令。首先将上一条指令取出的数，暂存到 ACC 中，可以通过波形看到ACC_wr 为 1，此时 in1变成了所取出的数。Dmemory 中直接寻址到地址为 3 的数，可以通过 in2 验证。相加之后，放入 ACC 中，由于设置的是上升沿写入 ACC  所以在下一个上升沿时，in1 为做加法之后的数，为16’h4dfb。所以，加法指令成功。</p><h2 id="🍑累加器取反指令COM"><a href="#🍑累加器取反指令COM" class="headerlink" title="🍑累加器取反指令COM"></a>🍑累加器取反指令COM</h2><p>累加器取反指令COM波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/3P5c26LnMKqrSQs.png#height=331&id=gQtzg&originHeight=662&originWidth=1040&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=520"><br>分析：累加器取反指令 COM。<br>因为下降沿自动加 1，Addr 至 12’h003，所以进入取反指令。将上一条指令加完的数放入 ACC 中，通过 in1 可以看到。然后对其进行取反操作，变为16’hb204。下一次上升沿写入 ACC，通过 in1 可以看出。所以，取反成功。</p><h2 id="🍑算术右移一位指令SHR"><a href="#🍑算术右移一位指令SHR" class="headerlink" title="🍑算术右移一位指令SHR"></a>🍑算术右移一位指令SHR</h2><p>算术右移一位指令SHR波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/tZIQArTJBc3o8SF.png#height=333&id=uW6ze&originHeight=665&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=418"><br>分析：算术右移一位指令 SHR，将累加器 ACC 中的数右移一位，结果放回 ACC。下降沿自动加 1，Addr 至12’h004，所以进入算术右移指令。In1 右移过后，再存入 ACC，此时 in1 表示的是右移过后的数。由图可以看出，in1 由16’hb204 变为16’hd902，算术右移成功。</p><h2 id="🍑循环左移一位指令CSL"><a href="#🍑循环左移一位指令CSL" class="headerlink" title="🍑循环左移一位指令CSL"></a>🍑循环左移一位指令CSL</h2><p>循环左移一位指令CSL波形如下所示：<br><img src="https://s2.loli.net/2023/05/26/QDU8AFVBIReEys5.png#height=337&id=Z8so1&originHeight=673&originWidth=1054&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=527"><br>分析：循环左移一位指令 CSL，对累加器中的数据进行操作。<br>下降沿自动加 1，Addr 至12’h005，所以进入算术右移指令。In1 循环左移过后，再存入 ACC，此时 in1 表示的是左移过后的数。由图可以看出，in1由16’hd902 变为16’hb205，循环左移成功成功。</p><h2 id="🍑存数指令STA"><a href="#🍑存数指令STA" class="headerlink" title="🍑存数指令STA"></a>🍑存数指令STA</h2><p>存数指令STA波形如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1685101420918-dd17468f-eb3c-4118-9d37-8657105b0d60.png#averageHue=%23424140&clientId=ud353abc6-2561-4&height=329&id=bXkq2&originHeight=658&originWidth=1051&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60727&status=done&style=none&taskId=u7561dbe6-83c7-4de3-a9ec-2f8c61e6edd&title=&width=526" alt="image.png"><br>分析：存数指令 STA：直接寻址，放入地址为 4 的内存单元<br>下降沿自动加 1，Addr 至12’h006，所以进入存数指令。由于本指令不需要进行写入 ACC 的操作，所以 ACC_wr 变为 0，因为要存数，所以写入数据存储器的信号 dmemory_wr 变为 1  在下一个上升沿时，写入 dmemory，此时由 in2可以看出，存入成功。</p><h2 id="🍑有条件跳转指令-无条件跳转指令"><a href="#🍑有条件跳转指令-无条件跳转指令" class="headerlink" title="🍑有条件跳转指令\无条件跳转指令"></a>🍑有条件跳转指令\无条件跳转指令</h2><p>有条件跳转指令\无条件跳转指令波形如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1685101409357-13d044e3-59c5-4c48-8725-a9e520ddfb0b.png#averageHue=%233c3b3a&clientId=ud353abc6-2561-4&height=353&id=KBeHW&originHeight=705&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74664&status=done&style=none&taskId=u7c7cbbad-7a7e-4e39-a5e4-6d05a78f7d7&title=&width=735" alt="image.png"><br>分析：有条件跳转指令：负则转。无条件跳转指令。<br>下降沿自动加 1，Addr 至12’h007，进入有条件跳转指令，在该 CPU中，我设置其跳转是 pc&#x3D;pc+1 是为了跳转至下一条无条件跳转指令，这样方便同时验证这两条指令的正确性。通过波形发现，此时有条件跳转信号 pc_wr 变为 1，ACC 中的数为负，所以发生跳转，在下一个上升沿时，pc+1，进入下一条指令，为无条件跳转。在本 cpu 中，我设置无条件跳转至第三条指令，取反指令，根据波形，可以得出有条件跳转和无条件跳转都能成功运行。</p><h2 id="🍑停机指令stop"><a href="#🍑停机指令stop" class="headerlink" title="🍑停机指令stop"></a>🍑停机指令stop</h2><p>停机指令stop波形如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32676326/1685101395234-b9e7a1e2-9a78-40e7-88c3-925ce036145b.png#averageHue=%233c3b3a&clientId=ud353abc6-2561-4&height=342&id=BBdBB&originHeight=683&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64889&status=done&style=none&taskId=uce77ff7a-45ca-4e1d-b178-5d206ee9821&title=&width=626" alt="image.png"><br>分析：停机指令 stop<br>由于为了验证上述两条跳转指令，该 cpu 无法自动进入 stop 指令。我为了验证停机指令，将有条件跳转指令中的 pc+1 改成 pc+2，跳转至停机指令。<br>跳转至停机指令，由 stop 信号变为 1 以及后面不运行可以看出。</p><h1 id="🍐总结与心得"><a href="#🍐总结与心得" class="headerlink" title="🍐总结与心得"></a>🍐总结与心得</h1><h2 id="🍑实验总结"><a href="#🍑实验总结" class="headerlink" title="🍑实验总结"></a>🍑实验总结</h2><p>本次实验主要完成了如下几点工作：<br><strong>实验四</strong></p><ol><li>完成方案总结——实验四完成了单周期 CPU 设计与实现——单指令 CPU，实验要求为通过设计并实现支持一条指令的 CPU，基本理解和掌握了 CPU 设计的基本原理和过程，根据实验内容设计和实现了一个支持加法指令的单周期 CPU。</li><li>功能总结——该实验所设计的单周期CPU可以实现加法指令要求该加法指令（表示为 add r1，r2，r3）格式约定如下：采用寄存器寻址，r1，r2，r3 为寄存器编号，r1 和 r2 存放两个源操作数，r3为目标寄存器，其功能为[r1] + [r2] -&gt; r3。</li></ol><p><strong>实验五</strong></p><ol><li>完成方案总结——实验五完成了为通过设计并实现支持 10 条指令的 CPU，进一步理解和掌握了 CPU 设计的基本原理和过程，根据实验内容设计和实现一个支持如下十条指令的单周期 CPU。</li><li>功能总结——该实验所设计的单周期CPU可以实现非访存指令、访存指令和转移类指令共10种指令。指令如下：</li></ol><ul><li><strong>非访存指令</strong><ul><li>清除累加器指令 CLA</li><li>累加器取反指令 COM</li><li>算术右移一位指令 SHR：将累加器 ACC 中的数右移一位，结果放回 ACC</li><li>循环左移一位指令 CSL：对累加器中的数据进行操作</li><li>停机指令 STP</li></ul></li><li><strong>访存指令</strong><ul><li>加法指令 ADD X：[X] + [ACC] –〉ACC，X 为存储器地址，直接寻址</li><li>存数指令 STA X，采用直接寻址方式</li><li>取数指令 LDA X，采用直接寻址</li></ul></li><li><strong>转移类指令</strong><ul><li>无条件转移指令 JMP imm：signExt(imm) -&gt; PC</li><li>有条件转移（负则转）指令 BAN X: ACC 最高位为 1 则（PC）+ X -&gt; PC,否则 PC不变</li></ul></li></ul><h2 id="🍑实验心得"><a href="#🍑实验心得" class="headerlink" title="🍑实验心得"></a>🍑实验心得</h2><ol><li>通过实验我知道了单周期 CPU 是指所有指令均在一个时钟周期内完成的 CPU。CPU 由数据通路及其控制部件两部分构成，因而要完成一个支持若干条指令 CPU 的设计，需要依次完成以下两件事：<ol><li>根据指令功能和格式设计 CPU 的数据通路；</li><li>根据指令功能和数据通路设计控制部件。</li></ol></li><li>通过本次实验，我对运算器，存储器以及输入输出的个各个系统内部结构有了更为深刻的了解，同时也增加了我对于计算机组成原理的更为深层次的理解，除此以外此次实验还增加了我对于Verilog语言的理解，锻炼了我对于verilog代码编写和使用的能力，初步掌握了对modelsim的使用，锻炼了我的实验动手能力。</li><li>通过本次实验，我认为，设计一个 CPU 要从这几个方面考虑：<ol><li>首先要确定 CPU 的指令条数、功能，根据指令的类型设计指令格式。</li><li>然后确定该 CPU 是单周期还是多周期。</li><li>接着，根据指令的具体功能设计 CPU 的数据通路，并设计数据通路上的各部件及其控制部件，确定他们的输入输出和功能。</li><li>最后，进行整体封装，再编写测试文件进行测试。然后通过 modelsim 进行波形仿真，验真是否能够实现功能。</li></ol></li><li>总之，这次 cpu 的实验，让我收获颇丰。加深了对计算机组成原理知识的印象，对cpu 的结构更加熟悉，对今后知识进一步的拓展打下基础。</li><li>对于实验的建议，刚开始为了分享实验我是直接做的实验四，就觉得和我自己的水平相差太大了，感觉完全无从下手，后来把实验一二三都看了一遍发现实验四是对于前三个的总结，后来我就将实验一二三都根据实验报告实现了一遍，在进行实验四五的时候，就顺手了很多。总的来说，这次实验还是让我收获了很多的，在通过听取别的同学的实验分享和我分享的时候丁老师对于我的指导也让我收获很多，虽然计组实验期间挺忙的，但是还是觉得很有意义的。</li></ol><h1 id="🍐参考文献"><a href="#🍐参考文献" class="headerlink" title="🍐参考文献"></a>🍐参考文献</h1><p>[1]DAVID A.PATTERSON(美).计算机组成与设计硬件&#x2F;软件接口(原书第5版).北京:机械工业出版社.<br>[2]David Money Harris(美).数字设计和计算机体系结构（第二版）. 机械工业出版社<br>[3]谭志虎,秦磊华,胡迪青.计算机组成原理实践教程.北京:清华大学出版社，2018年.<br>[4]秦磊华，吴非，莫正坤.计算机组成原理. 北京:清华大学出版社，2011年.<br>[5]袁春风编著. 计算机组成与系统结构. 北京:清华大学出版社，2011年.<br>[6]张晨曦，王志英. 计算机系统结构. 高等教育出版社，2008年.</p><h1 id="🍐程序代码"><a href="#🍐程序代码" class="headerlink" title="🍐程序代码"></a>🍐程序代码</h1><p>代码已开源至Github</p><p><a href="https://github.com/xiayi0409/Cassie/tree/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0">Cassie&#x2F;计算机组成原理-单周期CPU设计与实现 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Veliog </category>
          
          <category> 课程作业 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程作业 </tag>
            
            <tag> Veliog </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——单周期 CPU 设计与实现—单指令 CPU</title>
      <link href="/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%95%E6%8C%87%E4%BB%A4-CPU/"/>
      <url>/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%8D%95%E5%91%A8%E6%9C%9F-CPU-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E5%8D%95%E6%8C%87%E4%BB%A4-CPU/</url>
      
        <content type="html"><![CDATA[<h1 id="🍀设计要求"><a href="#🍀设计要求" class="headerlink" title="🍀设计要求"></a>🍀设计要求</h1><p>通过设计并实现支持一条指令的 CPU，理解和掌握 CPU 设计的基本原理和过程。</p><h1 id="🍀方案设计"><a href="#🍀方案设计" class="headerlink" title="🍀方案设计"></a>🍀方案设计</h1><p>设计和实现一个支持加法指令的单周期 CPU。要求该加法指令（表示为 add r1，r2，r3）格式约定如下：</p><ul><li>采用寄存器寻址，r1，r2，r3 为寄存器编号，r1 和 r2 存放两个源操作数，r3为目标寄存器，其功能为[r1] + [r2] -&gt; r3；</li><li>指令字长 16 位，操作码和地址码字段分配如下所示：</li></ul><p><img src="https://s2.loli.net/2023/05/25/mS3bMvoN9H2jeOq.jpg#height=82&id=OImn5&originHeight=163&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=489"></p><h2 id="🌵方案原理"><a href="#🌵方案原理" class="headerlink" title="🌵方案原理"></a>🌵方案原理</h2><p>单周期 CPU 是指所有指令均在一个时钟周期内完成的 CPU。CPU 由数据通路及其控制部件两部分构成，因而要完成一个支持若干条指令 CPU 的设计，需要依次完成以下两件事：</p><ul><li>根据指令功能和格式设计 CPU 的数据通路；</li><li>根据指令功能和数据通路设计控制部件。</li></ul><h2 id="🌵根据功能和格式完成CPU的数据通路设计"><a href="#🌵根据功能和格式完成CPU的数据通路设计" class="headerlink" title="🌵根据功能和格式完成CPU的数据通路设计"></a>🌵根据功能和格式完成CPU的数据通路设计</h2><p>实验需要设计的 CPU 只需要支持一条加法指令，而该指令的功能是在一个时钟周期内从寄存器组中 r1 和 r2 中取出两个操作数，然后送到 ALU 进行加法运算，最后把计算结果保存到 r1 寄存器中。下图给出了改加法指令的数据通路图。<br>此外，还需要确定各个部件的位数，为了简单起见，我们假设目标 CPU 的机器字长、存储字长和指令字长相等均为 16 位，存储单元个数假设为 256，按字寻址，并取 PC 位数为 8。<br><img src="https://s2.loli.net/2023/05/25/r5mwPOS6ACGZs8I.png#height=124&id=YW8mH&originHeight=248&originWidth=491&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4%20add%20r1%2Cr2%2Cr3%20%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF&width=246" alt="加法指令 add r1,r2,r3 数据通路" title="加法指令 add r1,r2,r3 数据通路"></p><h2 id="🌵根据指令功能、数据通路完成控制单元的设计"><a href="#🌵根据指令功能、数据通路完成控制单元的设计" class="headerlink" title="🌵根据指令功能、数据通路完成控制单元的设计"></a>🌵根据指令功能、数据通路完成控制单元的设计</h2><p>控制单元的功能是为当前要执行的指令产生微操作命令从而完成该指令的执行。为了能够完成加法指令的执行，结合上图，控制单元需要在取出指令后根据指令操作码（本例中是加法指令），控制 ALU（参考实验二）做加法（通过给 alu_op 信号线相应赋值），并把结果写回寄存器组（参考实验三）中（通过给 wr_en 赋值为 true）。下图给出了整合控制单元后目标 CPU 的原理图，系统时钟信号也已标注。<br><img src="https://s2.loli.net/2023/05/25/6XjMvkQCg2cLxtr.png#height=218&id=Vzg2O&originHeight=435&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%8D%95%E6%8C%87%E4%BB%A4%20CPU%20%E5%8E%9F%E7%90%86%E5%9B%BE&width=269" alt="单指令 CPU 原理图" title="单指令 CPU 原理图"></p><h1 id="🍀编程步骤"><a href="#🍀编程步骤" class="headerlink" title="🍀编程步骤"></a>🍀编程步骤</h1><p>在第三部分通过对该 CPU 实现细节的分析、设计，并得到该 CPU 的原理图后，就可以依次实现各个模块，并进行仿真验证了。</p><h2 id="🌵CPU各模块Verilog实现"><a href="#🌵CPU各模块Verilog实现" class="headerlink" title="🌵CPU各模块Verilog实现"></a>🌵CPU各模块Verilog实现</h2><p>在前面实验中，已经分别设计和实现了 PC、指令存储器、寄存器组和ALU，这里只给出各个模块的功能描述及其接口定义，具体实现可以直接使用或者调整前面试验的实现代码。</p><h3 id="🌾PC模块"><a href="#🌾PC模块" class="headerlink" title="🌾PC模块"></a>🌾PC模块</h3><p>PC 模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>时钟信号 clk、重置信号 rst</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>指令地址 pc（8 位）</td></tr><tr><td><strong>功能</strong></td><td>每个时钟上升沿 PC 的值自动加 1，并输出</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Pc(</span><br><span class="line">  <span class="comment">//输入的两个信号input c1k，input rst,</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] pc</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="number">1</span>)</span><br><span class="line">      pc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pc = pc + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span><span class="comment">//时钟上升沿触发</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾指令存储模块"><a href="#🌾指令存储模块" class="headerlink" title="🌾指令存储模块"></a>🌾指令存储模块</h3><p>指令存储器模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>8 位指令地址 Addr</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>16 位指令 Ins</td></tr><tr><td><strong>功能</strong></td><td>存放待执行的指令（初始化），并根据地址输出指令</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ins_unit(</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Ins,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] Addr</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">integer</span> i,j;</span><br><span class="line">  <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] unit[<span class="number">255</span>:<span class="number">0</span>];<span class="comment">//256个16位存储单元</span></span><br><span class="line">  initia1 <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i = i + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">      j= i % <span class="number">6</span>;</span><br><span class="line">      unit[i][<span class="number">2</span>:<span class="number">0</span>] = j;</span><br><span class="line">      unit[i][<span class="number">5</span>:<span class="number">3</span>] = j + <span class="number">1</span>;</span><br><span class="line">      unit[i][<span class="number">8</span>:<span class="number">6</span>] = j + <span class="number">2</span>;</span><br><span class="line">      unit[i][<span class="number">15</span>:<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span> <span class="comment">//任何时钟改变均会进入</span></span><br><span class="line">    Ins = unit[Addr] ;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾寄存器堆"><a href="#🌾寄存器堆" class="headerlink" title="🌾寄存器堆"></a>🌾寄存器堆</h3><p>寄存器堆模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>时钟信号 clk、读写控制线 wr_en、读寄存器编号 read_reg1 和read_reg2、写寄存器编号write_reg、写入数据 write_data</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>对应两个读寄存器编号的寄存器值 reg1 和 reg2</td></tr><tr><td><strong>功能</strong></td><td>根据读寄存器编号给出对应寄存器的值；在写允许情况下，把写入端的数据在 clk 下降沿写到写寄存器编号对应的寄存器</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> reg_stk(</span><br><span class="line">  <span class="keyword">input</span> clk，wr_en,<span class="comment">//wr_en读写信号为1时写入(上升沿有效）为0时，读数据input [15:o] write_data,</span></span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] read_reg1,read_reg2,write_reg,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] reg1,reg2</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] unit[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">integer</span> i;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span>(i = o;i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">      unit[i] = i;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span> (/任何时钟改变均会进入</span><br><span class="line">    reg1 = unit[read_reg1];</span><br><span class="line">    reg2 = unit[read_reg2];</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span>@(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span> <span class="comment">//时钟下降沿触发</span></span><br><span class="line">    <span class="keyword">if</span>(wr_en == <span class="number">1</span>)</span><br><span class="line">      unit[write_reg] = write_data;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾ALU"><a href="#🌾ALU" class="headerlink" title="🌾ALU"></a>🌾ALU</h3><p>ALU模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>指令（操作码）</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>寄存器堆的读写控制线 wr_en、ALU 的操作选择信号alu_op</td></tr><tr><td><strong>功能</strong></td><td>根据当前指令功能对 wr_en 和 alu_op 赋值</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] in1,in2,inputalu_op,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(alu_op==<span class="number">0</span>)</span><br><span class="line">      result = in1+in2 ;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="🌾CU"><a href="#🌾CU" class="headerlink" title="🌾CU"></a>🌾CU</h3><p>CU模块功能描述如下：</p><table><thead><tr><th><strong>输入</strong></th><th>操作数 in1 和 in2、操作选择信号 alu_op</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td>ALU 运算结果 Z</td></tr><tr><td><strong>功能</strong></td><td>根据操作选择信号计算 in1 和 in2 的运算结果 Z</td></tr></tbody></table><p>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cu(</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">6</span>:<span class="number">0</span>] Ins_op,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> wr_en,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> alu_op</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">always</span>@* <span class="keyword">begin</span>/任何时钟信号都引起</span><br><span class="line">    <span class="keyword">if</span>(Ins_op == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      wr_en = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      alu_op = <span class="number">0</span>;<span class="comment">//设置ALu的操作码对应为加</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🌵CPU顶层文件封装实现"><a href="#🌵CPU顶层文件封装实现" class="headerlink" title="🌵CPU顶层文件封装实现"></a>🌵CPU顶层文件封装实现</h2><p>通过根据单指令CPU原理图将以上定义的模块进行连接、封装就得到了目标 CPU，该 CPU 的输入为系统时钟信号 clk 和重置信号 reset。<br>Verilog关键代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">modu1e cpu(</span><br><span class="line">  <span class="keyword">input</span> c1k，rst,</span><br><span class="line">  <span class="keyword">output</span> test</span><br><span class="line">);</span><br><span class="line"><span class="keyword">wire</span> wr;</span><br><span class="line"><span class="keyword">wire</span> alu_op;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] result, ins,r1,r2;</span><br><span class="line"></span><br><span class="line">pc pc(</span><br><span class="line">  <span class="variable">.c1k</span>(c1k),<span class="variable">.rst</span>(rst),<span class="variable">.pc</span>(addr)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ins_unit ins_unit(</span><br><span class="line">  <span class="variable">.Addr</span>(addr)，<span class="variable">.Ins</span>(ins)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">cu cu(</span><br><span class="line">  <span class="variable">.Ins_op</span>(ins[<span class="number">15</span>:<span class="number">9</span>])，</span><br><span class="line">  <span class="variable">.wr_en</span>(wr),<span class="variable">.alu_op</span>(alu_op)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg_sta reg_sta(</span><br><span class="line">  <span class="variable">.clk</span>(clk),<span class="variable">.wr_en</span>(wr) ,</span><br><span class="line">  <span class="variable">.read_reg1</span>(ins[<span class="number">8</span>:<span class="number">6</span>]),<span class="variable">.read_reg2</span>(ins[<span class="number">5</span>:<span class="number">3</span>]),<span class="variable">.write_reg</span>(ins[<span class="number">2</span>:<span class="number">0</span>]),<span class="variable">.write_data</span>(result),<span class="variable">.reg1</span>(r1),<span class="variable">.reg2</span>(r2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alu alu(</span><br><span class="line">  <span class="variable">.in1</span>(r1),<span class="variable">.in2</span>(r2),</span><br><span class="line">  <span class="variable">.alu_op</span>(alu_op),<span class="variable">.result</span>(result)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="🌵CPU模拟仿真"><a href="#🌵CPU模拟仿真" class="headerlink" title="🌵CPU模拟仿真"></a>🌵CPU模拟仿真</h2><p>为了仿真验证所实现的 CPU，需要定义测试文件并在测试文件中对指令存储器和寄存器堆中的相应寄存器的值进行初始化，并通过仿真波形图查看是否指令得到了正确执行。</p><h3 id="🌾TestBench关键代码"><a href="#🌾TestBench关键代码" class="headerlink" title="🌾TestBench关键代码"></a>🌾TestBench关键代码</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cpu_sim;</span><br><span class="line">  <span class="keyword">reg</span> c1lk，rst;</span><br><span class="line"><span class="keyword">always</span> #<span class="number">1</span> c1k = ~c1k ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1</span>;</span><br><span class="line">    rst = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">10</span> rst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  cpu uut(</span><br><span class="line">    <span class="variable">.c1k</span>(c1k)，<span class="variable">.rst</span>(rst)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1 id="🍀实验步骤"><a href="#🍀实验步骤" class="headerlink" title="🍀实验步骤"></a>🍀实验步骤</h1><h2 id="🌵建立ModelSim工程"><a href="#🌵建立ModelSim工程" class="headerlink" title="🌵建立ModelSim工程"></a>🌵建立ModelSim工程</h2><p>打开 ModelSim，选择 File-&gt;New-&gt;Project，出现 Create Project 对话框，填写工程名（Project Name）， 选择保存目录（Project Location），注意保存目录中不要有中文，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/Ag9NqwOsMbUyveP.png#height=122&id=lsuZX&originHeight=244&originWidth=272&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=136"><br>单击OK按钮后，会出现下图界面：<br><img src="https://s2.loli.net/2023/05/25/zq9JlKshfkynAUr.png#height=212&id=jRVPz&originHeight=424&originWidth=491&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=246"><br>现在可以选 Create New File（新建文件）或者 Add Existing File（添加已存在文件）。这里我们选择 Add Existing File，也就是添加上述所描述的 Verilog 代码，会出现下图界面：<br><img src="https://s2.loli.net/2023/05/25/WpmyjrFGzvcaOl1.png#height=138&id=K9S4c&originHeight=276&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>点击 Browse 按钮，添加上述描述的文件，会出现下图界面：<br><img src="https://s2.loli.net/2023/05/25/4MeYIKGqHls9orh.png#height=275&id=sghiU&originHeight=550&originWidth=1399&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=700"><br>选择要添加的文件后，单击“打开”按钮，即添加完成，会出现类似下图界面，在其中选择 copy to project directory，这样就会将 cu.v等文件复制到新的工程目录下，单击OK 按钮。<br><img src="https://s2.loli.net/2023/05/25/iyPUB2VqsRDj4ZJ.png#height=138&id=E5K4X&originHeight=275&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=303"><br>文件添加完成后，ModelSim 主界面会显示所有文件的状态。选中任意一个文件，右键单击，选择 Compile-&gt;Compile All，即开始编辑所有文件，会出现下图界面。没有出错，文件状态应该都是绿色的对号，否则点击屏幕下方的 Transcript，查看出错信息，直至无误。<br><img src="https://s2.loli.net/2023/05/25/rCcAokGsZYxbdRO.png#height=161&id=PpKDL&originHeight=321&originWidth=802&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=401"></p><h2 id="🌵开始仿真"><a href="#🌵开始仿真" class="headerlink" title="🌵开始仿真"></a>🌵开始仿真</h2><p>切换到 Library，然后展开 work 目录，在 spu_sim.v 文件上单击右键，在弹出菜单中选择 Simulate （without Optimization），如下图界面：<br><img src="https://s2.loli.net/2023/05/25/fSAB6ElCK19xbcn.png#height=148&id=a96gc&originHeight=296&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=422"><br>此时会出现一个名为 sim 的界面，展开其中的spu_sim 节点，选择 uut，会在 Objects 窗口显示所有信号，如下图所示：（若没有出现 Objects 窗口，可以通过菜单 View-&gt;Objects调出该窗口）<br><img src="https://s2.loli.net/2023/05/25/4F85vkuCVOoZ6Wx.png#height=161&id=Eyki1&originHeight=321&originWidth=1235&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=618"><br>选择 Objects 窗口的所有信号（Ctrl+A），然后单击右键，在弹出菜单中选择 Add to-&gt;Wave-&gt;Selected Signals，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/dZtkp7JqmXR18Os.png#height=246&id=mTXtd&originHeight=492&originWidth=1232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=616"><br>单击工具栏中的 Run-All 按钮，便开始仿真，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/VR3hZtT8QeDrz7l.png#height=50&id=pAF7j&originHeight=100&originWidth=237&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=119"><br>仿真效果图，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/l7N8pT4KiLkomHD.png#height=358&id=cv0zA&originHeight=716&originWidth=2019&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1010"><br>结束后，请在 Transcript 中输入 quit –sim 命令退出，如下图所示：<br><img src="https://s2.loli.net/2023/05/25/1EDCicwyG7bT24B.png#height=84&id=tLdJA&originHeight=167&originWidth=831&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=416"></p><h1 id="🍀故障与调试"><a href="#🍀故障与调试" class="headerlink" title="🍀故障与调试"></a>🍀故障与调试</h1><h2 id="🌵安装故障1"><a href="#🌵安装故障1" class="headerlink" title="🌵安装故障1"></a>🌵安装故障1</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/Qd3Mxi75NYj96Fg.png#height=104&id=fzCJu&originHeight=207&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=226"><br><strong>原因分析：</strong></p><ol><li>在安装过程中一定要通过命令窗口运行该文件，不然下载出的modelsim会无法运行</li></ol><p><img src="https://s2.loli.net/2023/05/25/eRsqCzUuoTbLGWE.png#height=242&id=phkWx&originHeight=484&originWidth=890&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=445"><br>右键打开命令窗口，运行patch_dll.bat文件</p><ol start="2"><li>安装地址一定不能出现中文字符和空格，不然也会出错</li></ol><p><img src="https://s2.loli.net/2023/05/25/xeTlpDYoBiU8vX2.png#height=72&id=i1B04&originHeight=144&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=279"></p><ol start="3"><li>还有一种可能：是因为MAC地址不对。在运patch64_dll.bat之前需要将此文件用文件编辑器打开，添加正确的MAC地址。更改License文件中的网卡Mac地址</li></ol><p><img src="https://s2.loli.net/2023/05/25/eGySOVZsPK92XWr.png#height=342&id=Gb74s&originHeight=684&originWidth=1062&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=531"><br><img src="https://s2.loli.net/2023/05/25/7uNyVdKjGB4faOo.png#height=357&id=pv8bi&originHeight=713&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=376"><br><strong>解决方案：</strong><br>上述方法都尝试过后还是不行，就觉得可能是安装包本身出现问题，于是重新找了一个安装包进行安装，最终解决。</p><h2 id="🌵实验故障2"><a href="#🌵实验故障2" class="headerlink" title="🌵实验故障2"></a>🌵实验故障2</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/ZzPk2gSWslfjtTy.png#height=193&id=OkPOo&originHeight=386&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=600"><br><strong>原因分析：</strong><br>illegal reference to net “***”. 多半是因为没理解Wire 和Reg 的区别，如果用always语句块变量的声明就要用Reg 而不能用Wire，组合逻辑电路可以用Wire。</p><h2 id="🌵实验故障3"><a href="#🌵实验故障3" class="headerlink" title="🌵实验故障3"></a>🌵实验故障3</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/KOewRT6WUQvxgXC.png#height=10&id=PXLMz&originHeight=20&originWidth=385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=193"><br><strong>原因分析：</strong><br>括号打成中文下的括号</p><h2 id="🌵实验故障4"><a href="#🌵实验故障4" class="headerlink" title="🌵实验故障4"></a>🌵实验故障4</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/mXPE1cUanMHdR8x.png#height=66&id=ItJ8P&originHeight=131&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=588"><br><strong>原因分析：</strong><br>不能使用i++，只能是i&#x3D;i+1</p><h2 id="🌵实验故障5"><a href="#🌵实验故障5" class="headerlink" title="🌵实验故障5"></a>🌵实验故障5</h2><p><strong>故障现象：</strong><br><img src="https://s1.ax1x.com/2023/05/25/p9HRjY9.png#height=179&id=pJNKs&originHeight=357&originWidth=1128&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=564"><br><strong>原因分析：</strong><br>需要在端口中，对信号进行先声明，把端口外的声明去掉</p><h2 id="🌵实验故障6"><a href="#🌵实验故障6" class="headerlink" title="🌵实验故障6"></a>🌵实验故障6</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/rLbdRqQn3y8VkoJ.png#height=412&id=TnPVA&originHeight=823&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=633"><br><img src="https://s2.loli.net/2023/05/25/KxseAZSWLE4VFpn.png#height=277&id=CvxF6&originHeight=553&originWidth=1129&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=565"><strong>原因分析：</strong><br>原因是.v文件格式是utf-8编码，modelsim支持ANSI，UTF-8空白字符不是空白的，当把.v转换为ANSI编码可以看到下图所示，空白字符原来不是空白。删除这些异常空白字符就可以。<br>就在modelsim里编写代码，还是不要再其他地方编写再导入了</p><h2 id="🌵实验故障7"><a href="#🌵实验故障7" class="headerlink" title="🌵实验故障7"></a>🌵实验故障7</h2><p><strong>故障现象：</strong><br><img src="https://s2.loli.net/2023/05/25/iTemV92RzvPlHut.png#height=251&id=WYJQ2&originHeight=502&originWidth=1195&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=598"><br><img src="https://s2.loli.net/2023/05/25/G5BOou3iZsLrhPE.png#height=194&id=kzddx&originHeight=388&originWidth=906&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=453"><br><strong>原因分析：</strong><br>仿真时信号出现高阻态和仿真出现问题等，可能是逻辑设计出现了错误，或者是某个文件中模块拼写问题等等</p><h1 id="🍀仿真及分析"><a href="#🍀仿真及分析" class="headerlink" title="🍀仿真及分析"></a>🍀仿真及分析</h1><p><img src="https://s1.ax1x.com/2023/05/25/p9HRvWR.png#height=358&id=Id5za&originHeight=716&originWidth=2019&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1010"><br>测试输出数据表如下：</p><table><thead><tr><th>clk</th><th>时钟周期</th></tr></thead><tbody><tr><td>rst</td><td>重置信号</td></tr><tr><td>addr</td><td>指令地址</td></tr><tr><td>result</td><td>计算结果</td></tr><tr><td>ins</td><td>指令字长 16 位地址</td></tr><tr><td>r1</td><td>操作数r1</td></tr><tr><td>r2</td><td>操作数r2</td></tr></tbody></table><p><img src="https://s2.loli.net/2023/05/25/7YOf1cxDU6ulHq2.png#height=329&id=Thh1R&originHeight=657&originWidth=941&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=471"><br><strong>分析：</strong>根据上图，此时重置信号为1，则当前各周期下的CPU不进行加法运算<br><img src="https://s2.loli.net/2023/05/25/vLJmVECqGMpxgQu.png#height=351&id=T1k7E&originHeight=702&originWidth=2268&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1134"><br><strong>分析：</strong>根据上图，此时重置信号为0，当前各周期下CPU进行加法指令操作，可知r1+r2&#x3D;result，alu根据所指定的加法周期计算出了正确的结果，实验成功。</p>]]></content>
      
      
      <categories>
          
          <category> Veliog </category>
          
          <category> 课程作业 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程作业 </tag>
            
            <tag> Veliog </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程设计——应用小大根交替堆实现双端优先队列</title>
      <link href="/2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="🔮课程设计选题"><a href="#🔮课程设计选题" class="headerlink" title="🔮课程设计选题"></a>🔮课程设计选题</h1><p><strong>应用小大根交替堆实现双端优先队列</strong></p><h1 id="🔮需求和规格说明"><a href="#🔮需求和规格说明" class="headerlink" title="🔮需求和规格说明"></a>🔮需求和规格说明</h1><h2 id="🎠问题描述"><a href="#🎠问题描述" class="headerlink" title="🎠问题描述"></a>🎠问题描述</h2><p>双端优先队列是一个支持如下操作的数据结构：</p><ul><li>Insert （S, x）——将元素x 插入集合S</li><li>Extract –Min （S）——删除S 中的最小关键字</li><li>Extract –Max （S）——删除S 中的最大关键字</li></ul><p>可用小大根交替堆来实现对上述三个操作的支持</p><h2 id="🎠实验要求"><a href="#🎠实验要求" class="headerlink" title="🎠实验要求"></a>🎠实验要求</h2><ol><li>给出双端优先队列的ADT 描述，包括优先队列的逻辑结构及其上基本操作。</li><li>给出小大根交替堆的ADT 描述，并实现该ADT。</li><li>以小大根交替堆结构为辅助结构实现双端优先队列的存储表示并实现其上的基本操作。</li><li>应用双端优先队列的ADT 实现依据学生成绩实现对学生信息的查询。</li><li>学生信息存放在文本文件中（格式自定，内容自行输入）。</li></ol><h1 id="🔮设计"><a href="#🔮设计" class="headerlink" title="🔮设计"></a>🔮设计</h1><h2 id="🎠整体思路"><a href="#🎠整体思路" class="headerlink" title="🎠整体思路"></a>🎠整体思路</h2><ol><li>双端优先队列以抽象类的方式建立ADT</li><li>使用小大根交替堆继承双端优先队列，并对其基本操作进行实现</li><li>建立学生信息类，将学生的相关信息（学生的学号，姓名，出生年月，出生日期，出生地，语文成绩，数学成绩，英语成绩等）</li><li>通过调用小大根交替堆中的基本函数对根据学生的各项成绩对学生的信息进行查询</li></ol><h2 id="🎠小大根交替堆和双端优先队列"><a href="#🎠小大根交替堆和双端优先队列" class="headerlink" title="🎠小大根交替堆和双端优先队列"></a>🎠小大根交替堆和双端优先队列</h2><h3 id="🎨基本介绍"><a href="#🎨基本介绍" class="headerlink" title="🎨基本介绍"></a>🎨基本介绍</h3><p>双端优先队列是指能够同时访问最大元素和最小元素的优先级队列。其主要的操作有：插入一个元素、访问最大元素、删除最大元素、访问最小元素、删除最小元素以及判断队列是否为空。通常双端优先队列的实现是通过最小最大堆来实现的。<br>小大根交替堆是一个满足如下小大根交替条件的完全二元树：如果该二元树不空，那么其上的每个元素都有一个称为关键字的域，且针对该关键字，二元树按层次形成了小大根交替的形式，即对于小大根交替堆中的任何一个结点x，如果x 位于小根层次，那么x 就是以x 为根节点的二元树中键值最小的结点，并称该结点为一个小根结点。同样的道理，如果x 位于大根层次，那么x 就是以x 为根节点的二元树中键值最大的结点，并称该结点为一个大根结点。在小大根交替堆中根结点位于小根层次。</p><h3 id="🎨实现结构"><a href="#🎨实现结构" class="headerlink" title="🎨实现结构"></a>🎨实现结构</h3><p>由于双端优先队列是基于小大根交替堆来实现的，所以在本次实验中，使用小大根交替堆继承双端优先队列来实现相关操作。</p><ol><li><strong>双端优先队列的属性和方法定义</strong></li></ol><img src="https://s1.ax1x.com/2023/05/11/p9sKP0I.png#id=oN1k1&originHeight=335&originWidth=1483&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 80%;" /><ol start="2"><li><strong>小大根交替堆的属性和方法定义</strong></li></ol><img src="https://s1.ax1x.com/2023/05/11/p9sKi7t.png#id=o1Mqt&originHeight=775&originWidth=1983&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 80%;" /><ol start="3"><li><strong>算法设计和分析</strong><ol><li><strong>找出下标为i的结点的儿子和孙子中的最小值</strong></li></ol></li></ol><p>int find_min_child_grandchild(min_max_heap<T>* h, int i)<br>分别表示下标为i的结点元素，通过逐个比较法最后输出其中的最小值</p><ol start="2"><li><strong>找出下标为i的结点的儿子和孙子中的最大值</strong></li></ol><p>int find_max_child_grandchild(min_max_heap<T>* h, int i)<br>分别表示下标为i的结点元素，通过逐个比较法最后输出其中的最大值</p><ol start="3"><li><strong>交换堆中下标为i和j的数据</strong></li></ol><p>void swap(min_max_heap<T>* h, int i, int j)<br>通过一个中间元素值T temp对当前堆中的元素进行交换</p><ol start="4"><li><strong>小层元素下滤操作，保证结构为以小层元素为根的小根堆</strong></li></ol><p>void TrickleDownMin(min_max_heap<T>* h, int i)<br>首先先找到下标为i的小层元素的儿子和孙子中的最小值：</p><ul><li>如果最小值是处于大层的儿子，那么根据小大交替堆的定义可以知道该元素没有孙子，此时比较该元素与儿子的大小关系，如果儿子小于自己，则交换元素来维护当前小根堆的结构。</li><li>如果最小值是孙子，比较孙子和该元素的大小关系：如果孙子大于该元素，证明以该元素为根节点的树的最小值就是它本身，不需要改变就符合小根堆的结构；如果孙子小于该元素，那么交换孙子和该元素，交换后需要判断该元素和父亲节点（也就是原来的儿子结点）的大小：如果父亲结点小于该元素，那么父亲结点不满足大根堆的结构，需要交换父亲节点和该元素，交换后对应孙子节点位置的元素不正确，那么就需要再对该元素进行下滤操作做递归调用。<ol start="5"><li><strong>大层元素下滤操作，保证结构为以大层元素为根的大根堆</strong></li></ol></li></ul><p>void TrickleDownMax(min_max_heap<T>* h, int i)<br>和小层元素的下滤操作有着异曲同工之意<br>首先先找到下标为i的大层元素的儿子和孙子中的最大值：</p><ul><li>如果最大值是处于小层的儿子，那么证明该元素没有孙子，比较该元素与儿子的大小关系，如果儿子大于自己，则交换维护大根堆结构。</li><li>如果有孙子，最大值是孙子，且如果孙子小于该元素，说明以该元素为根节点的树的最大值就是该元素自己，符合大根堆的结构，不需要进行调整；如果孙子大于该元素，则交换孙子与该元素，交换后判断该元素与父亲节点也就是原来的儿子节点的大小，如果父亲节点大于该元素，则父亲节点不满足小根堆结构，交换父亲节点与该元素，交换后就只有父亲节点元素也就是开始下滤操作时对应孙子节点位置的元素不正确，那么再对该元素进行下滤操作递归调用。<ol start="6"><li><strong>小层元素上滤操作，保证结构为以小层元素为根的小根堆</strong></li></ol></li></ul><p>void BubbleUpMin(min_max_heap<T>* h, int i)<br>小层元素的上滤操作，首先先找到下标为i的元素所对应的祖父结点（小根元素层对应的父亲结点所在的层为大根元素层）：</p><ul><li>如果祖父元素值比自己小，则满足小根堆的结构，不需要对此进行调整。</li><li>反之如果祖父元素的元素值比自己大，破坏了定义中的小根堆的结构，此时需要将自己与祖父结点进行交换，交换后需要对于当前结点所在的位置继续向上调整递归调用上滤函数。<ol start="7"><li><strong>大层元素上滤操作，保证结构为以大层元素为根的大根堆</strong></li></ol></li></ul><p>void BubbleUpMax(min_max_heap* h, int i)<br>    和小层元素的上滤操作有着异曲同工之意<br>    大层元素的上滤操作，首先先找到下标为i的元素所对应的祖父结点（大根元素层对应的父亲结点所在的层为小根元素层）：</p><ul><li>如果祖父元素值比自己大，则满足大根堆的结构，不需要对此进行调整。</li><li>反之如果祖父元素的元素值比自己小，破坏了定义中的大根堆的结构，此时需要将自己与祖父结点进行交换，交换后需要对于当前结点所在的位置继续向上调整递归调用上滤函数。<ol start="8"><li><strong>返回下标为i的数据属于大层还是小层</strong></li></ol></li></ul><p>int level(int i)<br>    根据小大根堆的定义即可直到通过对2取对数的方式，可以判断下标是属于大层还是小层，这里调用了floor向下取整。</p><ol start="9"><li><strong>下滤，用于删除后的调整工作</strong></li></ol><p>void TrickleDown(min_max_heap* h, int i)<br>    通过（4）（5）中对于大层和小层元素的下滤操作，主要应用在删除元素后的调整，首先对于下标为i的元素进行判断是属于小层元素还是大层元素，而后直接调用下滤函数，对当前堆进行调整，使之依然满足小大根堆的结构。</p><ol start="10"><li>上滤，用于插入后的调整工作</li></ol><p>void BubbleUp(min_max_heap* h, int i)<br>    对于下标为i的元素进行上滤操作，可用于插入元素后的调整工作，本处和（9）中的直接调用函数不相同，插入操作的时候，新增元素放置在最后的位置可能会破坏当前的结构，所以首先要进行预判断：<br>    首先先对下标为i的元素进行判断，是小层元素还是大层元素：</p><ul><li>如果是小层元素，则比较该元素与父亲结点：如果大层的父亲结点大，则对该元素进行小层上滤操作；如果父亲节点小，则该父亲节点不满足大根堆的结构，交换父亲结点与该元素，而后对于父亲结点进行大层上滤。</li><li>如果是大层元素，则比较该元素与父亲节点，如果父亲节点小，则直接对该元素进行大层上滤，如果父亲节点大，则父亲节点不满足小根堆结构，交换父亲节点与该元素后对父亲节点进行小层上滤。<ol start="11"><li><strong>返回最大值</strong></li></ol></li></ul><p>T&amp; min_max_heap::getmax()<br>    小大根交替堆中的最大值：</p><ul><li>如果对堆中只有一个元素，那么最大值为该元素</li><li>如果堆中有两个元素，由于第一层为小根堆，则最大值必然为第二个元素即儿子节点</li><li>如果有三个及以上的元素，第二层的大根堆结构保证了最大值必然出现在根节点所对应的两个孩子中，由此，比较第二个和第三个元素即两个儿子结点的元素值就可以得到最大值。<ol start="12"><li><strong>返回最小值</strong></li></ol></li></ul><p>T&amp; min_max_heap::getmin()<br>    返回最小值在小大交替堆中非常简单，只要堆不空，则根据性质，最小值一定为根节点元素。</p><ol start="13"><li><strong>删除最小值</strong></li></ol><p>T&amp; min_max_heap::popmin()</p><ul><li>堆中只有一个元素，则直接删除即可</li><li>堆中含有多个元素，删除第一个元素后，将最后一个元素放置在根节点的位置并开始调整当前根堆的结构，即从根节点开始对当前元素进行下滤操作。<ol start="14"><li><strong>删除最大值</strong></li></ol></li></ul><p>T&amp; min_max_heap::popmax()</p><ul><li>堆中只有一个元素，则直接删除即可</li><li>堆中有两个元素，返回二号元素并且将二号元素直接删除</li><li>堆中含有3个以及以上的元素，首先需要判断两个儿子节点中哪一个是最大元素，找到最大元素后，与删除最小元素同理，将最后一个元素填充到相应的位置后开始进行下滤操作来调整堆的结构。<ol start="15"><li><strong>插入元素</strong></li></ol></li></ul><p>void min_max_heap::insert(T&amp; Element)<br>    首先判断堆满则增加堆数组的长度，将插入元素放在堆的最后一个位置后进行元素上滤操作。</p><ol start="16"><li><strong>输出堆元素</strong></li></ol><p>void min_max_heap::output(ostream&amp; out)<br>    首先从第一层即0层开始计算树高和最底层的节点数(bottle_node_count_max);动态创建数组heapTreeMatrix[(high+1)_2][bottle_node_count_max_2];根据堆元素给数组进行赋值（空格和&#x2F;，\也相应的赋值给数组）最后输出。</p><h2 id="🎠学生成绩管理系统的实现"><a href="#🎠学生成绩管理系统的实现" class="headerlink" title="🎠学生成绩管理系统的实现"></a>🎠学生成绩管理系统的实现</h2><h3 id="🎨学生信息类的设计"><a href="#🎨学生信息类的设计" class="headerlink" title="🎨学生信息类的设计"></a>🎨学生信息类的设计</h3><img src="https://s1.ax1x.com/2023/05/11/p9sMFKJ.png#id=oMuqP&originHeight=1036&originWidth=1478&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><h3 id="🎨算法设计和思想"><a href="#🎨算法设计和思想" class="headerlink" title="🎨算法设计和思想"></a>🎨算法设计和思想</h3><p>学生成绩管理系统的实现主要包含学生信息的获取、修改以及类中运算符的重载<br><strong>信息获取：</strong>在学生成绩管理系统中对应输出学生的信息<br><strong>信息设置和修改：</strong>用于新增学生信息是的设置<br><strong>操作符重载：</strong> 由于student类是自己定义的，计算机不知道如何判断两个student类对象是否完全相同。这时候要使用操作符重载，让&#x3D;&#x3D;能够识别两个student类对象。</p><h2 id="🎠主函数"><a href="#🎠主函数" class="headerlink" title="🎠主函数"></a>🎠主函数</h2><img src="https://s1.ax1x.com/2023/05/11/p9sMZUx.png#id=htmZ1&originHeight=187&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:67%;" /><ol><li>读入学生信息：<br>将文件中的学生信息读入到学生类型的数组中，并按数学成绩，语文成绩，英语成绩，和总成绩放入不同的小大根交替堆中。</li><li>小大根交替堆实现的学生成绩管理系统：<br>学生管理系统的简单实现中，此处主要是实现了查询功能，对于最高最低成绩学生的查询，直接到对应查询方式的堆中调用getmax()和getmin()函数即可得到，对于具体成绩查询方式的查询，首先检查数据是否合法，之后遍历学生类数组，找到对应成绩的学生并输出。对于插入学生信息，直接调用insert将学生成绩对应写入不同的堆中，并将该学生信息写入文件。</li><li>输入，并根据输入选项进行相应的输出：<br>本函数主要验证小大根交替堆的功能，包含学生成绩管理系统的选项，实现两部分的连接。</li></ol><h1 id="🔮用户手册"><a href="#🔮用户手册" class="headerlink" title="🔮用户手册"></a>🔮用户手册</h1><p>程序运行时，首先出现“小大根交替堆实现双端优先队列”字样<br>进入主菜单界面<br>通过在下方输入相应指令的字母可以实现相关操作：<br>a.  建立小大根交替堆——请输入小大根交替堆的堆元素：<br>b.  插入元素——请输入插入的元素：<br>c.  删除最大值<br>d.  删除最小值<br>e.  输出最小值<br>f.  输出最大值<br>g.  依据学生成绩对学生信息的查询<br>程序会将学生的数学，语文，英语，总分成绩建立小大根交替堆不断调整的过程输出在当前屏幕上，并打印出“小大根交替堆实现的学生成绩管理系统”主菜单<br>根据菜单界面，用于可以通过输入相应的数字完成相应的操作：</p><ul><li>1-  输出所有学生的信息</li><li>2-  查询成绩最高的学生信息</li><li>3-  查询成绩最低的学生信息</li><li>4-  通过具体的成绩进行查询</li><li>5-  输出学生成绩的平均值</li><li>6-  添加学生信息</li><li>7-  退出</li></ul><p>h.  退出</p><h1 id="🔮调试及测试"><a href="#🔮调试及测试" class="headerlink" title="🔮调试及测试"></a>🔮调试及测试</h1><h2 id="🎠小大根交替堆实现下的双端优先队列"><a href="#🎠小大根交替堆实现下的双端优先队列" class="headerlink" title="🎠小大根交替堆实现下的双端优先队列"></a>🎠小大根交替堆实现下的双端优先队列</h2><p>菜单界面如下：<br><img src="https://s1.ax1x.com/2023/05/11/p9sQJOJ.png#id=a6oIC&originHeight=340&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom: 50%;" /><br>a-建立小大根交替堆<br><img src="https://s1.ax1x.com/2023/05/11/p9sQlWT.png#id=HTBeF&originHeight=574&originWidth=443&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>b-插入元素<br><img src="https://s1.ax1x.com/2023/05/11/p9sQ3SU.png#id=D2lmg&originHeight=574&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>c-删除最大值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQQYV.png#id=ygQ8T&originHeight=103&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>d-删除最小值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQMF0.png#id=JdJmU&originHeight=107&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>e-输出最小值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQGy4.png#id=uP4KQ&originHeight=103&originWidth=270&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>f-输出最大值<br><img src="https://s1.ax1x.com/2023/05/11/p9sQ8lF.png#id=It7aS&originHeight=101&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>g-依据学生成绩对学生信息的查询<br><img src="https://s1.ax1x.com/2023/05/11/p9sQtm9.png#id=AMGJB&originHeight=744&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>小大根交替堆实现的学生成绩管理系统菜单如下：<br><img src="https://s1.ax1x.com/2023/05/11/p9sQNwR.png#id=MPvyx&originHeight=353&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>1-输出所有学生的信息</p><p>2-查询成绩最高的学生信息<br><img src="https://s1.ax1x.com/2023/05/11/p9sQUT1.png#id=OLQCM&originHeight=356&originWidth=886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>3-查询成绩最低的学生信息<br><img src="https://s1.ax1x.com/2023/05/11/p9sQdFx.png#id=J7fAM&originHeight=195&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>4-通过具体的成绩进行查询<br><img src="https://s2.loli.net/2023/05/11/4eZnTHDKtkbyLpY.png#id=O44vI&originHeight=402&originWidth=879&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>5-输出学生成绩的平均值<br><img src="https://s2.loli.net/2023/05/11/GLwIeixBdfv1sT3.png#id=C4aMl&originHeight=97&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>6-添加学生信息<br><img src="https://s2.loli.net/2023/05/11/kMVu1FQZ2PdUWR3.png#id=EXP0D&originHeight=248&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s2.loli.net/2023/05/11/35V6OJqkjXyWTUo.png#id=IDQsb&originHeight=717&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br><img src="https://s2.loli.net/2023/05/11/xqEonrkKIMTyj7A.png#id=x9Cdy&originHeight=775&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /><br>添加学生信息后的txt文件如下<br><img src="https://s2.loli.net/2023/05/11/Z6woNhO5US2PBXt.png#id=u7X1E&originHeight=281&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" style="zoom:50%;" /></p><h1 id="🔮进一步改进"><a href="#🔮进一步改进" class="headerlink" title="🔮进一步改进"></a>🔮进一步改进</h1><ol><li>由于本次实验进行的时间较短，仅仅实现了文本界面——后续改进可以设计一个GUI界面，能够同时实现显示当前文档中的学生信息，小大根交替堆的调整过程等信息。</li><li>该程序对于学生信息的管理系统所包含的内容较少——可以增加包括对学生的不同的成绩进行排序、将学生通过学号、出生地等的进行归类等操作。</li><li>该程序对于学生信息的添加后存入文件后，不能及时的读取进入该程序，需要等退出此次程序，下一次进行操作的时候才能读取今年加入的学生信息，此问题需要后续进行提升改进。</li><li>目前堆设定的长度最大值为50，后续若需要大批量的数据进行读入可以增加。</li></ol><h1 id="🔮心得体会"><a href="#🔮心得体会" class="headerlink" title="🔮心得体会"></a>🔮心得体会</h1><h2 id="🎠程序分析"><a href="#🎠程序分析" class="headerlink" title="🎠程序分析"></a>🎠程序分析</h2><p>本次实验主要进行的内容是数据结构中的小大根交替堆min-max-heap和该数据结构实现的双端优先队列在学生成绩管理系统上的应用，其难点在于对于堆结构的维护和调整。在对于堆的调整的过程中，上滤和下滤的操作是该数据结构中的核心点，小根堆和大根堆的区别在于：在上滤和上滤的过程中需要我们判断该元素是处于小层还是大层，由此来进行相应层的上滤和下滤，在上滤和下滤的过程中，由于大小根堆的的特性值，也会比普通大根堆或是小根堆的上滤和下滤要复杂一点。</p><h2 id="🎠程序性能分析"><a href="#🎠程序性能分析" class="headerlink" title="🎠程序性能分析"></a>🎠程序性能分析</h2><p>对于本实验，程序设计中包含了对异常的处理，对操作符的重载以及对类函数的封装等，在主函数中直接调用类函数对应头文件，由于本实验中小大根交替堆是以堆的形式展现在屏幕上，对于学生成绩的查询系统也没有可提供的大数据验证。程序主要是递归调用上滤下滤函数时的复杂度，复杂度为O(nlog2n)。</p><h2 id="🎠程序编写心得"><a href="#🎠程序编写心得" class="headerlink" title="🎠程序编写心得"></a>🎠程序编写心得</h2><h3 id="🎨语言的选择"><a href="#🎨语言的选择" class="headerlink" title="🎨语言的选择"></a>🎨语言的选择</h3><p>由于大一这一个学期的所有程序的编写基本都选择了使用C语言进行编写，在大一上半年对于C++的学习也几乎没有进行实践，导致对C++十分生疏甚至是不会的；在日常学习的过程中也发现了C++的重要性，因此本次实验采用C++进行编写。<br>在编写的过程中，对于C++中包括类，文件读取和写入等操作都非常生疏，也对于C++进行了一定的学习。其中印象比较深刻的是类中需要对于操作符进行重载，这样做的目的是为了防止用户修改用于基本类型数据的运算符性质。因此通过本次实验，不仅仅让我对于小大根交替堆这个数据结构有了一定的了解，同时也让我对C++的认识更近一步，对于自己来说也算是一举两得了。</p><h3 id="🎨小大根交替堆"><a href="#🎨小大根交替堆" class="headerlink" title="🎨小大根交替堆"></a>🎨<strong>小大根交替堆</strong></h3><p>堆有一个性质，在一个给定优先次序的情况下。堆顶元素的优先级最高。而且这个性质递归的适用于每一个子堆。所以，每次都可以用O(1)的时间得到优先级最高的一个元素。如果要删除，那么只需要O(log2(N))的时间去维护整个堆，使其仍然满足堆的性质。<br>但在课堂上所学习得小根堆和大根堆只能较为方便的查找到所有数字中的最小值或者最大值。而要同时得到最小值和最小值，除了堆，还可以通过平衡二叉树来实现，此时最左孩子和最右孩子就是所求最值。<br>通过本次实验对于小大根交替堆的理解，来实现查找最大值和最小值的功能，而不需要直到其他结果，只需要引入一个最大最小堆即可。<br>在一个系统或者在一个生活场景中，我们需要实时的知道当前的最大值最小值，这个时候，如果我们每次都得通过遍历得到最值，那么效率无疑是低下的。那么这个时候，小大根交替堆就能为此应用场景提供适配。</p><h1 id="🔮程序代码"><a href="#🔮程序代码" class="headerlink" title="🔮程序代码"></a>🔮程序代码</h1><p>代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%BA%94%E7%94%A8%E5%B0%8F%E5%A4%A7%E6%A0%B9%E4%BA%A4%E6%9B%BF%E5%A0%86%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">Cassie&#x2F;数据结构课程设计-应用小大根交替堆实现双端优先队列 at main · xiayi0409&#x2F;Cassie (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
          <category> 课程设计 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 课程设计 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计课程设计——推箱子</title>
      <link href="/2021/01/05/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%8E%A8%E7%AE%B1%E5%AD%90/"/>
      <url>/2021/01/05/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="⛳需求和规格说明"><a href="#⛳需求和规格说明" class="headerlink" title="⛳需求和规格说明"></a>⛳需求和规格说明</h1><p>“推箱子小游戏”要求编写一个推箱子游戏游戏，使用图形界面。<br>推箱子游戏的目：用最少的步数把所有的箱子推到目标位置。</p><h2 id="🎳游戏规则"><a href="#🎳游戏规则" class="headerlink" title="🎳游戏规则"></a>🎳游戏规则</h2><ol><li>游戏开始时，在游戏区域内随机的出现箱子、障碍物、小人以及箱子的目标位置。</li><li>箱子只可以被推动，不可以被拉动。</li><li>用户通过键盘的来控制小人上下左右的移动来推动箱子。记录用户移动小人的次数。</li><li>如果箱子被推到死角，则游戏结束。</li><li>所有箱子被推到目标位置，游戏胜利。</li></ol><h1 id="⛳设计"><a href="#⛳设计" class="headerlink" title="⛳设计"></a>⛳设计</h1><h2 id="🎳需求概要"><a href="#🎳需求概要" class="headerlink" title="🎳需求概要"></a>🎳需求概要</h2><ul><li><p>推箱子游戏的设计目标完成一个比较简单的游戏，使之能够实现推箱子游戏的基本功能，成为一个较为完整的游戏框架。游戏内容为，在一个较为狭小的仓库中，要求把木箱子推到游戏界面中的目标位置，稍不小心就会出现箱子无法移动或者通道被堵住的情况，所以需要玩家巧妙地利用有限的空间和通道，合理安排自己移动的次序和位置，使得顺利完成游戏的任务。</p></li><li><p>用户进入游戏界面后，会出现一个小人，若干个箱子和箱子的目标位置。玩家可以根据自己的想法自由地移动箱子，游戏提供跳关以及退步的功能模块，拼接这些模块，玩家可以实现对游戏的快速通关！</p></li><li><p>由于该程序需要使用图形界面，最终选择使用VS2019软件进行编程。</p></li></ul><h2 id="🎳设计思路"><a href="#🎳设计思路" class="headerlink" title="🎳设计思路"></a>🎳设计思路</h2><p>系统流程图如下所示：<br><img src="https://s1.ax1x.com/2023/05/09/p9BGUkq.jpg#height=363&id=OyCqa&originHeight=726&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=517" style="zoom:50%;" /></p><h2 id="🎳设计表示"><a href="#🎳设计表示" class="headerlink" title="🎳设计表示"></a>🎳设计表示</h2><p>头文件总览：</p><table><thead><tr><th align="center"><strong>include</strong></th><th align="center">#include&lt;stdio.h&gt;</th><th align="center">标准输入输出头文件</th></tr></thead><tbody><tr><td align="center"></td><td align="center">#include&lt;stdlib.h&gt;</td><td align="center">system函数的头文件</td></tr><tr><td align="center"></td><td align="center">#include&lt;windows.h&gt;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">#include&lt;conio.h&gt;</td><td align="center">图形库头文件</td></tr><tr><td align="center"></td><td align="center">#include&lt;graphics.h&gt;</td><td align="center">图形库头文件</td></tr><tr><td align="center">函数总览：</td><td align="center"></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center"><strong>函数</strong></th><th align="center">void DrawMap()</th><th align="center">绘制地图，加载图片</th></tr></thead><tbody><tr><td align="center"></td><td align="center">void PlayGame()</td><td align="center">推箱子游戏的主体</td></tr><tr><td align="center"></td><td align="center">int Win()</td><td align="center">判断该关卡是否通关</td></tr><tr><td align="center"></td><td align="center">void TargetCount()</td><td align="center">遍历地图，查看总共的目的地的个数</td></tr><tr><td align="center"></td><td align="center">void InitGame();</td><td align="center">游戏开始前需要做的准备工作</td></tr><tr><td align="center"></td><td align="center">void SaveStep()</td><td align="center">将玩家的每一步都保存起来</td></tr><tr><td align="center"></td><td align="center">void PreviousStep()</td><td align="center">记录上一步</td></tr></tbody></table><p>宏定义：</p><table><thead><tr><th align="center"><strong>宏定义</strong></th><th align="center">#define SIZE 45</th><th align="center">每张贴图的大小</th></tr></thead><tbody><tr><td align="center"></td><td align="center">#define WINDOWSWIDTH (COL*SIZE)</td><td align="center">窗口的宽</td></tr><tr><td align="center"></td><td align="center">#define WINDOWSHEIGHT (ROW*SIZE)</td><td align="center">窗口的高</td></tr><tr><td align="center"></td><td align="center">#define MAXLEVEL 10</td><td align="center">最大关卡数</td></tr></tbody></table><p>定义的变量：</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>成员名</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">int</td><td align="center">map[20][20]&#x3D;{};</td><td align="center">地图数组</td></tr><tr><td align="center"></td><td align="center">temp[5000][20][20] &#x3D; {}</td><td align="center">临时地图数组</td></tr><tr><td align="center"></td><td align="center">step &#x3D; -1</td><td align="center">计步</td></tr><tr><td align="center"></td><td align="center">ROW &#x3D; 0</td><td align="center">地图的行</td></tr><tr><td align="center"></td><td align="center">COL &#x3D; 0</td><td align="center">地图的列</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">玩家的横坐标</td></tr><tr><td align="center"></td><td align="center">C</td><td align="center">玩家的纵坐标</td></tr><tr><td align="center"></td><td align="center">targetCount &#x3D; 0</td><td align="center">地图中目的地的个数</td></tr><tr><td align="center"></td><td align="center">gameLevel &#x3D; 1</td><td align="center">游戏关卡</td></tr><tr><td align="center">char</td><td align="center">dir &#x3D; ‘s’</td><td align="center">人物当前的方向</td></tr><tr><td align="center"></td><td align="center">fileName[100]</td><td align="center">存放图片路径的字符串</td></tr><tr><td align="center">IMAGE</td><td align="center">bkImg</td><td align="center">没有墙，人物，箱子的空白图片</td></tr><tr><td align="center"></td><td align="center">boxImg</td><td align="center">箱子的图片</td></tr><tr><td align="center"></td><td align="center">dkboxImg</td><td align="center">箱子推到目的地时的图片</td></tr><tr><td align="center"></td><td align="center">targetImg</td><td align="center">目的地的图片</td></tr><tr><td align="center"></td><td align="center">blankImg</td><td align="center">没有墙，人物，箱子的空白图片</td></tr><tr><td align="center"></td><td align="center">wallImg</td><td align="center">墙面的图片</td></tr><tr><td align="center"></td><td align="center">playerImg[4]</td><td align="center">人物的四各方向的图片</td></tr></tbody></table><h1 id="⛳推箱子的功能框架"><a href="#⛳推箱子的功能框架" class="headerlink" title="⛳推箱子的功能框架"></a>⛳推箱子的功能框架</h1><p><img src="https://s1.ax1x.com/2023/05/09/p9BGt7n.jpg#id=tRh9z&originHeight=483&originWidth=1269&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎳初始化模块"><a href="#🎳初始化模块" class="headerlink" title="🎳初始化模块"></a>🎳初始化模块</h2><p>该模块包括屏幕初始化和游戏第一关到最后一关的初始化。屏幕的初始化用于输出操作信息，游戏每一关的初始化时构建每一关的关卡。</p><h2 id="🎳画图模块"><a href="#🎳画图模块" class="headerlink" title="🎳画图模块"></a>🎳画图模块</h2><p>用于画墙，画箱子，画人物，画目的地。</p><h2 id="🎳移动人物模块"><a href="#🎳移动人物模块" class="headerlink" title="🎳移动人物模块"></a>🎳移动人物模块</h2><p>该模块用于移动人物，包括人物与目的地之间，空地与人物之间，空地与箱子之间，箱子与目的地之间的移动变化。</p><h2 id="🎳功能控制模块"><a href="#🎳功能控制模块" class="headerlink" title="🎳功能控制模块"></a>🎳功能控制模块</h2><p>包括判断是否通关，悔步，关卡跳关，关卡重置操作。</p><h1 id="⛳推箱子具有的功能"><a href="#⛳推箱子具有的功能" class="headerlink" title="⛳推箱子具有的功能"></a>⛳推箱子具有的功能</h1><h2 id="🎳能够显示主菜单和游戏界面"><a href="#🎳能够显示主菜单和游戏界面" class="headerlink" title="🎳能够显示主菜单和游戏界面"></a>🎳能够显示主菜单和游戏界面</h2><img src="https://s1.ax1x.com/2023/05/09/p9BGJmj.png#height=325&id=sutgX&originHeight=650&originWidth=440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=220" style="zoom:50%;" />游戏界面上有一个菜单，可以让玩家进行必要的游戏设置。同时可以将地图中的数字信息转化成对应的图像信息显示在游戏界面上。代码展示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setfillcolor</span>(<span class="built_in">RGB</span>(<span class="number">235</span>, <span class="number">227</span>, <span class="number">206</span>));   <span class="comment">//填充当前颜色</span></span><br><span class="line"><span class="built_in">fillrectangle</span>(WINDOWSWIDTH, <span class="number">0</span>, WINDOWSWIDTH + <span class="number">220</span>, WINDOWSHEIGHT);   <span class="comment">//窗口大小</span></span><br><span class="line"><span class="built_in">settextcolor</span>(BLACK);</span><br><span class="line"><span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">0</span>, <span class="string">&quot;宋体&quot;</span>);</span><br><span class="line"><span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH + <span class="number">45</span>, <span class="number">45</span>, <span class="string">&quot;推箱子小游戏&quot;</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">70</span>, <span class="string">&quot;操作说明:&quot;</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">95</span>, <span class="string">&quot;WASD 或者↑↓←→&quot;</span>);</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;关卡           ：%d/%d&quot;</span>, gameLevel, MAXLEVEL);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">120</span>, str);</span><br><span class="line"><span class="type">char</span> stepStr[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现键盘操作的功能"><a href="#🎳能够实现键盘操作的功能" class="headerlink" title="🎳能够实现键盘操作的功能"></a>🎳能够实现键盘操作的功能</h2><p>可以从用户的键盘上获取信息，根据不同的方向键盘所对应的ASCII码数值，实现人物上下左右的移动。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dir = _getch();         <span class="comment">//从键盘上获取数据</span></span><br><span class="line"><span class="keyword">switch</span> (dir)</span><br></pre></td></tr></table></figure><p>通过#include&lt;conio.h&gt;调用getch函数，用来获取键值，再通过switch-case实现人物的移动</p><h3 id="🥌计算说明书部分"><a href="#🥌计算说明书部分" class="headerlink" title="🥌计算说明书部分"></a>🥌计算说明书部分</h3><p>假设空地为0，墙面为1，目的地为3，箱子为4，人物为5。这样子的目的是使得地图看起来更加规则，后面移动时的操作更加简洁明了。<br><img src="https://s1.ax1x.com/2023/05/09/p9BG8XQ.png#height=244&id=OKQgF&originHeight=486&originWidth=301&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=151"><br>上图为第一关的地图</p><ul><li>人物移动到空地上的数值变化就是0-&gt;5</li><li>箱子移动到空地上的数值变化就是0-&gt;4</li><li>人移动到目的地上时的数据变化就是3-&gt;8(3+5)</li><li>箱子移动到目的地上时的数据变化就是3-&gt;7(3+4)</li><li>根据每一次的移动，来改变原来位置和现在移动的位置所对应的数据变化，还原出地图所对应的数字模型。在编写程序的时候，分为四个方向——上下左右，依次分类讨论。由于四个方向的思路几乎相同，则可以重点编写一个方向所对应的数字改变，剩余的四个方向以此类推少做略微改变即可。</li><li>(下面以玩家进行向上移动时的数字改变为例子的代码显示)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">72</span>:               <span class="comment">//方向键上</span></span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">0</span>)  <span class="comment">// 1 人上面是空地（0）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)<span class="comment">// 1.1所站的地方以前是空地（5+0）</span></span><br><span class="line">&#123;<span class="comment">// 1.2所站的地方以前是目的地（3+5）</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">5</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">4</span>)  <span class="comment">// 2 人上面是箱子（4）</span></span><br><span class="line">&#123;<span class="comment">//2.1所站的地方以前是空地（5+0)</span></span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>) <span class="comment">//2.1.1箱子的上面是空地(0)</span></span><br><span class="line">&#123;        <span class="comment">//2.1.2箱子的上面是目的地(3)</span></span><br><span class="line">        <span class="comment">//2.2所站的地方以前是目的地(5+3)</span></span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">2</span>][C] == <span class="number">0</span> || map[R - <span class="number">2</span>][C] == <span class="number">3</span>)<span class="comment">//2.2.1箱子的上面是空地(0)</span></span><br><span class="line">&#123;        <span class="comment">//2.2.2箱子的上面是目的地(3)</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">2</span>][C] += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">3</span>)          <span class="comment">//3人上面是目的地(3)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)                 <span class="comment">//3.1人所站的地方是空地(5+0)</span></span><br><span class="line">&#123;                     <span class="comment">//3.2人所站的地方是目的地(5+3)</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;</span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[R - <span class="number">1</span>][C] == <span class="number">7</span>)            <span class="comment">//4人上面是在目的地的箱子也就是(3+4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R][C] == <span class="number">5</span> || map[R][C] == <span class="number">8</span>)<span class="comment">//4.1人所站的地方以前是空地（0+5） </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[R - <span class="number">2</span>][C] == <span class="number">0</span> || map[R - <span class="number">2</span>][C] == <span class="number">3</span>)          <span class="comment">//4.1.1箱子的上面是空地（0)</span></span><br><span class="line">&#123;               <span class="comment">//4.1.2箱子的上面是目的地（3）</span></span><br><span class="line">map[R][C] -= <span class="number">5</span>;                                    <span class="comment">//4.2人所站的地方以前是目的地（3+5）       </span></span><br><span class="line">map[R - <span class="number">1</span>][C] = <span class="number">8</span>;                                 <span class="comment">//4.2.1箱子的上面是空地（0）</span></span><br><span class="line">map[R - <span class="number">2</span>][C] += <span class="number">4</span>;                                <span class="comment">//4.2.2箱子的上面是目的地（3）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SaveStep</span>();<span class="comment">//将每一步走之后的地图信息都保存起来</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现箱子到达目的地的时候的变色显示"><a href="#🎳能够实现箱子到达目的地的时候的变色显示" class="headerlink" title="🎳能够实现箱子到达目的地的时候的变色显示"></a>🎳能够实现箱子到达目的地的时候的变色显示</h2><p>当玩家把箱子推到指定的位置的时候，需要实现箱子的变色，这样可以明确的告诉玩家，您的箱子已经到达指定的目的地。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:     <span class="comment">//箱子被推到了目的地 4+3</span></span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;dkboxImg);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/05/09/p9BG36g.png#height=359&id=ys0YL&originHeight=717&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=362" style="zoom:50%;" /><h2 id="🎳能够实现人物的方向运动"><a href="#🎳能够实现人物的方向运动" class="headerlink" title="🎳能够实现人物的方向运动"></a>🎳能够实现人物的方向运动</h2><p>当玩家通过上下左右的按键操控游戏中的人物进行运动的时候，人物也会随着方向键的改变，改变其旋转的方向。可以使得游戏更加生动，增加可玩性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (dir)      <span class="comment">//从键盘中获取键值，以改变人物图片的方向</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>W<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">72</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>S<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">1</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">75</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">2</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">77</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">3</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">putimage</span>(j * SIZE, i * SIZE, &amp;playerImg[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>通过玩家的上下左右的操作中获取键值，再次通过switch-case函数通过不同的键值显示不同的人物方向。<br><img src="https://s1.ax1x.com/2023/05/09/p9BGY0s.png#id=B1r8V&originHeight=129&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://s1.ax1x.com/2023/05/09/p9BGrX4.png#id=h1YYX&originHeight=232&originWidth=1386&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="🎳能够实现人物的方向运动-1"><a href="#🎳能够实现人物的方向运动-1" class="headerlink" title="🎳能够实现人物的方向运动"></a>🎳能够实现人物的方向运动</h2><p>在游戏中，当玩家把所有的箱子都推到指定的目的地的时候，系统会进行判断。会跳出一个窗口，提示是否进入下一关游戏还是选择退出该游戏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TargetCount</span><span class="params">()</span>             <span class="comment">//遍历地图，查看总共的目的地的个数，用于判断是否将所有箱子移动到了目的地</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">targetCount = <span class="number">0</span>;<span class="comment">//每次调用函数都需要将targetCount初始化为零，不然就是在上一次的基础上++了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">3</span> || map[i][j] == <span class="number">7</span>)        </span><br><span class="line">targetCount++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Win</span><span class="params">()</span>          <span class="comment">//判断是否通关 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> boxToTargetCount = <span class="number">0</span>;       <span class="comment">//在目的地的箱子个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)           <span class="comment">//遍历整张地图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)       </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">7</span>)         <span class="comment">//所有的箱子到达目的地（3+4=7）</span></span><br><span class="line">&#123;</span><br><span class="line">boxToTargetCount++; </span><br><span class="line"><span class="keyword">if</span> (boxToTargetCount == targetCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (gameLevel == MAXLEVEL)        <span class="comment">//是否通过了全部的关卡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;恭喜你全部通关，太棒了！&quot;</span>, <span class="string">&quot;通关&quot;</span>, MB_OKCANCEL | MB_SYSTEMMODAL);       <span class="comment">//弹框函数</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过关，返回选择函数值 1 确定 2取消</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">&quot;你真棒，继续下一关吧！&quot;</span>, <span class="string">&quot;获胜&quot;</span>, MB_OKCANCEL | MB_SYSTEMMODAL));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个函数的共同作用，以判断该关卡是否成功。</p><ul><li>void TargetCount()遍历地图，查看总共的目的地的个数</li><li>int Win()判断该关卡是否通关</li></ul><p>再通过Win函数中弹框函数获取用户点击的选项所对应的数值判断是进去下一关还是退出游戏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> select = <span class="built_in">Win</span>();      <span class="comment">//是否继续下一关，1 确定 2  取消</span></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        gameLevel++;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/05/09/p9BGat0.png#height=156&id=m0YFt&originHeight=312&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=237" style="zoom:50%;" />点击确定则进去下一个关卡，点击取消则直接退出游戏。<h2 id="🎳能够实现跳过关卡的功能"><a href="#🎳能够实现跳过关卡的功能" class="headerlink" title="🎳能够实现跳过关卡的功能"></a>🎳能够实现跳过关卡的功能</h2><p>玩家可以通过对应的按键进行选择上一关或者下一关的选择，进行跳关选项。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:<span class="comment">//上一关</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gameLevel &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gameLevel--;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:<span class="comment">//下一关</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gameLevel &lt; MAXLEVEL)</span><br><span class="line">&#123;</span><br><span class="line">gameLevel++;</span><br><span class="line"><span class="built_in">InitGame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎳能够实现悔步的操作"><a href="#🎳能够实现悔步的操作" class="headerlink" title="🎳能够实现悔步的操作"></a>🎳能够实现悔步的操作</h2><p>系统会记录每一步的运动，玩家可以通过按键的操控，实现悔步。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveStep</span><span class="params">()</span>                  <span class="comment">//将玩家的每一步都保存起来，以便于回退操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">step += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp[step][i][j] = map[i][j];        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">PreviousStep</span><span class="params">()</span><span class="comment">//上一步，以实现回退操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">step--;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j] = temp[step][i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个函数的共同协助完成悔步的操作。</p><ul><li>void SaveStep()——将玩家的每一步都保存起来</li><li>void  PreviousStep()——记录上一步</li></ul><p>在人物移动的每一步时，都会通过SaveStep()函数，保存玩家的每一步。（通过ESC实现回退操作的代码显示）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">27</span>:<span class="comment">//ESC按键ASCII值   回退</span></span><br><span class="line"><span class="built_in">PreviousStep</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>(下图为通过按ESC实现悔步操作)<br><img src="https://s1.ax1x.com/2023/05/09/p9BG0pT.png#height=437&id=VR5TM&originHeight=874&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627" style="zoom:50%;" /><br><img src="https://s1.ax1x.com/2023/05/09/p9BGDcF.png#height=437&id=kvJXb&originHeight=874&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=627" style="zoom:50%;" /></p><h2 id="🎳能够实现记录步数的操作"><a href="#🎳能够实现记录步数的操作" class="headerlink" title="🎳能够实现记录步数的操作"></a>🎳能够实现记录步数的操作</h2><p>在功能菜单界面，会显示当前步数，随时记录玩家都在游戏过程中的总步数。每启用一次SaveStep()函数就会实现Step+1</p><ul><li>这里需要注意的是：</li></ul><p>判断是不是重新开始，因为运行程序开始和按了R开始两种情况是不一样的；如果是第一次开始，在主函数中执行DrawMap函数之后就会等待玩家按了按键之后，才再次执行DrawMap函数，这种情况step是从-1开始计步的，这时显示时就需要+1。而如果按了R重新开始，这时执行了InitGame函数，然后PlayGame函数执行完毕，就会继续执行DrawMap函数，这时step是为0的就不需要+1了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (step == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(stepStr, <span class="string">&quot;步数           ：%d&quot;</span>, step + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">145</span>, stepStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(stepStr, <span class="string">&quot;步数           ：%d&quot;</span>, step);</span><br><span class="line"><span class="built_in">outtextxy</span>(WINDOWSWIDTH, <span class="number">145</span>, stepStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="⛳用户手册"><a href="#⛳用户手册" class="headerlink" title="⛳用户手册"></a>⛳用户手册</h1><p>本游戏一共有10关，从易到难，每一关都可以进行重新开始，回退，记录步数，返回上一关，进入下一关等操作。</p><h2 id="🎳操作说明"><a href="#🎳操作说明" class="headerlink" title="🎳操作说明"></a>🎳操作说明</h2><ul><li>可以通过按动键盘“WASD”或者“↑↓←→”对游戏中的小人物进行操控；</li><li>可以通过按动键盘“Esc”键来进行回退上一步，及允许用户悔步；</li><li>可以通过按动键盘“R”对该局游戏重新开始；</li><li>可以通过按动键盘“X”直接进入上一关；</li><li>可以通过按动键盘“N”直接进入下一关；</li><li>通过界面上的步数，可以直接看出本局用户行走的步数。</li></ul><h1 id="⛳调试及测试"><a href="#⛳调试及测试" class="headerlink" title="⛳调试及测试"></a>⛳调试及测试</h1><h2 id="🎳地图部分"><a href="#🎳地图部分" class="headerlink" title="🎳地图部分"></a>🎳地图部分</h2><p>刚开始只编辑了一张地图并且直接在程序中体现<br><img src="https://s1.ax1x.com/2023/05/09/p9BGdhV.png#id=H8qux&originHeight=411&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>后续为了实现选关和增加关卡的数量，选择使用TXT文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载地图</span></span><br><span class="line"><span class="type">char</span>  fileName[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;      <span class="comment">//定义</span></span><br><span class="line"><span class="built_in">sprintf</span>(fileName, <span class="string">&quot;./第%d关.txt&quot;</span>, gameLevel);      <span class="comment">//为了简化代码以及便于增加游戏关卡数，采用读取TXT文件的方法</span></span><br><span class="line"></span><br><span class="line">FILE* file;         </span><br><span class="line"><span class="keyword">if</span> ((file = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;ROW);       <span class="comment">//地图的行</span></span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;COL);       <span class="comment">//地图的列    （读取行列数以便控制窗口的大小和遍历）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(file, <span class="string">&quot;%d&quot;</span>, &amp;map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">rewind</span>(file);     <span class="comment">//文件指针回绕到文件起始处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🎳步数计算部分"><a href="#🎳步数计算部分" class="headerlink" title="🎳步数计算部分"></a>🎳步数计算部分</h2><p>关卡重置后会发现当前步数多1<br>需要判断是不是重新开始，因为运行程序开始和按了R开始两种情况是不一样的。如果是第一次开始，在主函数中执行DrawMap函数之后就会等待玩家按了按键之后，才再次执行DrawMap函数，这种情况step是从-1开始计步的，这时显示时就需要+1。而如果按了R重新开始，这时执行了InitGame函数，然后PlayGame函数执行完毕。就会继续执行DrawMap函数，这时step是为0的就不需要+1了。</p><h1 id="⛳运行示例"><a href="#⛳运行示例" class="headerlink" title="⛳运行示例"></a>⛳运行示例</h1><img src="https://s1.ax1x.com/2023/05/09/p9BGB1U.png#height=392&id=cHGpX&originHeight=784&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=492" style="zoom:50%;" /><img src="https://s1.ax1x.com/2023/05/09/p9BGynJ.png#height=392&id=nXW0X&originHeight=784&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=582" style="zoom:50%;" /><h1 id="⛳进一步改进"><a href="#⛳进一步改进" class="headerlink" title="⛳进一步改进"></a>⛳进一步改进</h1><ol><li>可以增加一个菜单界面，使用户更加清楚自己接下来的操作（如增加游戏规则说明，选择关卡等）；</li><li>可以增加背景音乐，使得该小游戏更加可玩，有趣；</li><li>可以改变背景颜色，增加人物颜色的可选择性等；</li><li>代码可以更加简单明了一些。</li></ol><h1 id="💡程序代码"><a href="#💡程序代码" class="headerlink" title="💡程序代码"></a>💡程序代码</h1><p>代码已开源至Github<a href="https://github.com/xiayi0409/Cassie/tree/main/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F">Cassie&#x2F;程序设计课程设计-推箱子小游戏 at main · xiayi0409&#x2F;Cassie · GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言/C++ </category>
          
          <category> 课程设计 </category>
          
          <category> 程序设计技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言/C++ </tag>
            
            <tag> 课程设计 </tag>
            
            <tag> 程序设计技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
